{"version":3,"file":"break-styled-lines.cjs.production.min.js","sources":["../src/break-lines.ts"],"sourcesContent":["type TextDescriptor = { text: string; font?: string };\n\nfunction isStringArray(\n  text: string | string[] | TextDescriptor[]\n): text is string[] {\n  return (\n    Array.isArray(text) &&\n    (text.length > 0 ? typeof text[0] === \"string\" : true)\n  );\n}\n\nfunction isTextDescriptorArray(\n  text: string | string[] | TextDescriptor[]\n): text is TextDescriptor[] {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\n\nfunction withNewLines(\n  descriptor: { text: string; font: string },\n  width: Number,\n  startingX: number,\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n): { lastLineWidth: number; text: string } {\n  // Break up all the parts into whitespace and words\n  const elements = descriptor.text\n    .split(\"\")\n    .reduce((elements: string[], char: string) => {\n      const runningElement = elements[elements.length - 1] || \"\";\n      const lastChar = runningElement.slice(-1);\n\n      if (char === \" \" && lastChar !== \" \") {\n        return [...elements, char];\n      }\n\n      if (char !== \" \" && lastChar === \" \") {\n        return [...elements, char];\n      }\n\n      return [...elements.slice(0, -1), `${runningElement}${char}`];\n    }, []);\n\n  const { lastLineWidth, lines } = elements.reduce(\n    (result, element: string) => {\n      ctx.font = descriptor.font;\n      const { width: elementWidth } = ctx.measureText(element);\n      const completeTextWidth = result.lastLineWidth + elementWidth;\n\n      const itFits = completeTextWidth <= width;\n\n      // If it fits, remove the last line from current results\n      // append the current element into it\n      // and insert it back in\n      if (itFits) {\n        const appendedLine = [...result.lines.slice(-1), element].join(\"\");\n\n        return {\n          lastLineWidth: completeTextWidth,\n          lines: [...result.lines.slice(0, -1), appendedLine]\n        };\n      }\n\n      // Now it doesn't fit.\n\n      // If the element itself didn't fit on a line\n      // Then we should force a break\n      if (elementWidth > width && result.lastLineWidth === 0) {\n        return {\n          lastLineWidth: elementWidth,\n          lines: [...result.lines.slice(0, -1), element]\n        };\n      }\n\n      // Trim any whitespace at the end of the line\n      // which is being broken.\n      const previousLine = result.lines.slice(-1).join(\"\");\n      const precedingLines = [\n        ...result.lines.slice(0, -1),\n        previousLine.trimEnd()\n      ];\n\n      // If the element that doesn't fit is a whitespace\n      // we should just insert a newline\n      if (element.trim().length === 0) {\n        return {\n          lastLineWidth: 0,\n          lines: [...precedingLines, \"\"]\n        };\n      }\n\n      // Otherwise we should just start a new line with the element\n      return {\n        lastLineWidth: elementWidth,\n        lines: [...precedingLines, element]\n      };\n    },\n    { lastLineWidth: startingX, lines: [] as string[] }\n  );\n\n  return { lastLineWidth, text: lines.join(\"\\n\") };\n}\n\nfunction breakLines(\n  descriptors: { text: string; font: string }[],\n  width: number\n): string[] {\n  const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n\n  const canvasEl = document.createElement(\"canvas\");\n\n  const canvas = supportsOffscreenCanvas\n    ? canvasEl.transferControlToOffscreen()\n    : canvasEl;\n\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\") as\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D;\n\n  if (ctx) {\n    return descriptors.reduce(\n      (result, descriptor) => {\n        const { lastLineWidth, text } = withNewLines(\n          descriptor,\n          width,\n          result.lastLineWidth,\n          ctx\n        );\n\n        return {\n          lastLineWidth,\n          lines: [...result.lines, text]\n        };\n      },\n      { lastLineWidth: 0, lines: [] as string[] }\n    ).lines;\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(({ text }) => text);\n}\n\nfunction toTextDescriptors(\n  text: string | string[] | TextDescriptor[],\n  defaultFont: string\n): { text: string; font: string }[] {\n  if (isTextDescriptorArray(text)) {\n    return text.map(({ text, font }) => ({\n      text: stripNewlines(text),\n      font: font || defaultFont\n    }));\n  }\n\n  if (isStringArray(text)) {\n    return text.map(member => ({\n      text: stripNewlines(member),\n      font: defaultFont\n    }));\n  }\n\n  return [{ text: stripNewlines(text), font: defaultFont }];\n}\n\nconst newlineRegex = /(\\r\\n|\\n|\\r)/gm;\n\nfunction stripNewlines(text: string) {\n  return text.replace(newlineRegex, \" \");\n}\n\nfunction breakLinesEntry(text: string, width: number, font: string): string;\nfunction breakLinesEntry(text: string[], width: number, font: string): string[];\nfunction breakLinesEntry(\n  text: TextDescriptor[],\n  width: number,\n  font: string\n): string[];\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(\n  text: string | string[] | TextDescriptor[],\n  width: number,\n  font: string\n): string | string[] {\n  const descriptors = toTextDescriptors(text, font);\n\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  return breakLines(descriptors, width)[0];\n}\n\nexport default breakLinesEntry;\n"],"names":["isStringArray","text","Array","isArray","length","isTextDescriptorArray","breakLines","descriptors","width","supportsOffscreenCanvas","window","canvasEl","document","createElement","canvas","transferControlToOffscreen","ctx","getContext","reduce","result","descriptor","startingX","split","elements","char","runningElement","lastChar","slice","element","font","elementWidth","measureText","completeTextWidth","lastLineWidth","appendedLine","lines","join","previousLine","precedingLines","trimEnd","trim","withNewLines","console","warn","map","newlineRegex","stripNewlines","replace","defaultFont","member","toTextDescriptors"],"mappings":"aAEA,SAASA,EACPC,UAGEC,MAAMC,QAAQF,OACbA,EAAKG,OAAS,IAAuB,iBAAZH,EAAK,IAInC,SAASI,EACPJ,UAEOC,MAAMC,QAAQF,OAAUA,EAAKG,OAAS,KAAKJ,EAAcC,IAuFlE,SAASK,EACPC,EACAC,OAEMC,EAA0B,oBAAqBC,OAE/CC,EAAWC,SAASC,cAAc,UAElCC,EAASL,EACXE,EAASI,6BACTJ,EAEJG,EAAON,MAAQA,MACTQ,EAAMF,EAAOG,WAAW,aAI1BD,EACKT,EAAYW,QACjB,SAACC,EAAQC,SAvGf,SACEA,EACAZ,EACAa,EACAL,SAGiBI,EAAWnB,KACzBqB,MAAM,IACNJ,QAAO,SAACK,EAAoBC,OACrBC,EAAiBF,EAASA,EAASnB,OAAS,IAAM,GAClDsB,EAAWD,EAAeE,OAAO,SAE1B,MAATH,GAA6B,MAAbE,GAIP,MAATF,GAA6B,MAAbE,YAHPH,GAAUC,cAOZD,EAASI,MAAM,GAAI,OAAOF,EAAiBD,MACrD,IAEqCN,QACxC,SAACC,EAAQS,GACPZ,EAAIa,KAAOT,EAAWS,SACPC,EAAiBd,EAAIe,YAAYH,GAAxCpB,MACFwB,EAAoBb,EAAOc,cAAgBH,KAElCE,GAAqBxB,EAKxB,KACJ0B,EAAe,UAAIf,EAAOgB,MAAMR,OAAO,IAAIC,IAASQ,KAAK,UAExD,CACLH,cAAeD,EACfG,gBAAWhB,EAAOgB,MAAMR,MAAM,GAAI,IAAIO,QAQtCJ,EAAetB,GAAkC,IAAzBW,EAAOc,oBAC1B,CACLA,cAAeH,EACfK,gBAAWhB,EAAOgB,MAAMR,MAAM,GAAI,IAAIC,SAMpCS,EAAelB,EAAOgB,MAAMR,OAAO,GAAGS,KAAK,IAC3CE,YACDnB,EAAOgB,MAAMR,MAAM,GAAI,IAC1BU,EAAaE,mBAKe,IAA1BX,EAAQY,OAAOpC,OACV,CACL6B,cAAe,EACfE,gBAAWG,GAAgB,MAKxB,CACLL,cAAeH,EACfK,gBAAWG,GAAgBV,OAG/B,CAAEK,cAAeZ,EAAWc,MAAO,WAG9B,CAAEF,gBAzDDA,cAyDgBhC,OAzDDkC,MAyDaC,KAAK,OAuBHK,CAC9BrB,EACAZ,EACAW,EAAOc,cACPjB,SAGK,CACLiB,gBARMA,cASNE,gBAAWhB,EAAOgB,SATGlC,UAYzB,CAAEgC,cAAe,EAAGE,MAAO,KAC3BA,OAGJO,QAAQC,KAAK,8DACNpC,EAAYqC,KAAI,qBAAG3C,gEAwB5B,IAAM4C,EAAe,iBAErB,SAASC,EAAc7C,UACdA,EAAK8C,QAAQF,EAAc,qBAkBpC,SACE5C,EACAO,EACAqB,OAEMtB,EA/CR,SACEN,EACA+C,UAEI3C,EAAsBJ,GACjBA,EAAK2C,KAAI,gBAASf,IAAAA,WAAY,CACnC5B,KAAM6C,IADW7C,MAEjB4B,KAAMA,GAAQmB,MAIdhD,EAAcC,GACTA,EAAK2C,KAAI,SAAAK,SAAW,CACzBhD,KAAM6C,EAAcG,GACpBpB,KAAMmB,MAIH,CAAC,CAAE/C,KAAM6C,EAAc7C,GAAO4B,KAAMmB,IA6BvBE,CAAkBjD,EAAM4B,UAExC7B,EAAcC,IAIdI,EAAsBJ,GAHjBK,EAAWC,EAAaC,GAO1BF,EAAWC,EAAaC,GAAO"}