{"version":3,"file":"break-styled-lines.esm.js","sources":["../src/break-lines.ts"],"sourcesContent":["type TextDescriptor = { text: string; font?: string };\n\nfunction isStringArray(\n  text: string | string[] | TextDescriptor[]\n): text is string[] {\n  return (\n    Array.isArray(text) &&\n    (text.length > 0 ? typeof text[0] === \"string\" : true)\n  );\n}\n\nfunction isTextDescriptorArray(\n  text: string | string[] | TextDescriptor[]\n): text is TextDescriptor[] {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\n\nfunction withNewLines(\n  descriptor: { text: string; font: string },\n  width: Number,\n  startingX: number,\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n): { lastLineWidth: number; text: string } {\n  // Break up all the parts into whitespace and words\n  const elements = descriptor.text\n    .split(\"\")\n    .reduce((elements: string[], char: string) => {\n      const runningElement = elements[elements.length - 1] || \"\";\n      const lastChar = runningElement.slice(-1);\n\n      if (char === \" \" && lastChar !== \" \") {\n        return [...elements, char];\n      }\n\n      if (char !== \" \" && lastChar === \" \") {\n        return [...elements, char];\n      }\n\n      return [...elements.slice(0, -1), `${runningElement}${char}`];\n    }, []);\n\n  const { lastLineWidth, lines } = elements.reduce(\n    (result, element: string) => {\n      ctx.font = descriptor.font;\n      const { width: elementWidth } = ctx.measureText(element);\n      const completeTextWidth = result.lastLineWidth + elementWidth;\n\n      const itFits = completeTextWidth <= width;\n\n      // If it fits, remove the last line from current results\n      // append the current element into it\n      // and insert it back in\n      if (itFits) {\n        const appendedLine = [...result.lines.slice(-1), element].join(\"\");\n\n        return {\n          lastLineWidth: completeTextWidth,\n          lines: [...result.lines.slice(0, -1), appendedLine]\n        };\n      }\n\n      // Now it doesn't fit.\n\n      // If the element itself didn't fit on a line\n      // Then we should force a break\n      if (elementWidth > width && result.lastLineWidth === 0) {\n        return {\n          lastLineWidth: elementWidth,\n          lines: [...result.lines.slice(0, -1), element]\n        };\n      }\n\n      // Trim any whitespace at the end of the line\n      // which is being broken.\n      const previousLine = result.lines.slice(-1).join(\"\");\n      const precedingLines = [\n        ...result.lines.slice(0, -1),\n        previousLine.trimEnd()\n      ];\n\n      // If the element that doesn't fit is a whitespace\n      // we should just insert a newline\n      if (element.trim().length === 0) {\n        return {\n          lastLineWidth: 0,\n          lines: [...precedingLines, \"\"]\n        };\n      }\n\n      // Otherwise we should just start a new line with the element\n      return {\n        lastLineWidth: elementWidth,\n        lines: [...precedingLines, element]\n      };\n    },\n    { lastLineWidth: startingX, lines: [] as string[] }\n  );\n\n  return { lastLineWidth, text: lines.join(\"\\n\") };\n}\n\nfunction breakLines(\n  descriptors: { text: string; font: string }[],\n  width: number\n): string[] {\n  const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n\n  const canvasEl = document.createElement(\"canvas\");\n\n  const canvas = supportsOffscreenCanvas\n    ? canvasEl.transferControlToOffscreen()\n    : canvasEl;\n\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\") as\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D;\n\n  if (ctx) {\n    return descriptors.reduce(\n      (result, descriptor) => {\n        const { lastLineWidth, text } = withNewLines(\n          descriptor,\n          width,\n          result.lastLineWidth,\n          ctx\n        );\n\n        return {\n          lastLineWidth,\n          lines: [...result.lines, text]\n        };\n      },\n      { lastLineWidth: 0, lines: [] as string[] }\n    ).lines;\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(({ text }) => text);\n}\n\nfunction toTextDescriptors(\n  text: string | string[] | TextDescriptor[],\n  defaultFont: string\n): { text: string; font: string }[] {\n  if (isTextDescriptorArray(text)) {\n    return text.map(({ text, font }) => ({\n      text: stripNewlines(text),\n      font: font || defaultFont\n    }));\n  }\n\n  if (isStringArray(text)) {\n    return text.map(member => ({\n      text: stripNewlines(member),\n      font: defaultFont\n    }));\n  }\n\n  return [{ text: stripNewlines(text), font: defaultFont }];\n}\n\nconst newlineRegex = /(\\r\\n|\\n|\\r)/gm;\n\nfunction stripNewlines(text: string) {\n  return text.replace(newlineRegex, \" \");\n}\n\nfunction breakLinesEntry(text: string, width: number, font: string): string;\nfunction breakLinesEntry(text: string[], width: number, font: string): string[];\nfunction breakLinesEntry(\n  text: TextDescriptor[],\n  width: number,\n  font: string\n): string[];\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(\n  text: string | string[] | TextDescriptor[],\n  width: number,\n  font: string\n): string | string[] {\n  const descriptors = toTextDescriptors(text, font);\n\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  return breakLines(descriptors, width)[0];\n}\n\nexport default breakLinesEntry;\n"],"names":["isStringArray","text","Array","isArray","length","isTextDescriptorArray","withNewLines","descriptor","width","startingX","ctx","elements","split","reduce","char","runningElement","lastChar","slice","result","element","font","measureText","elementWidth","completeTextWidth","lastLineWidth","itFits","appendedLine","lines","join","previousLine","precedingLines","trimEnd","trim","breakLines","descriptors","supportsOffscreenCanvas","window","canvasEl","document","createElement","canvas","transferControlToOffscreen","getContext","console","warn","map","toTextDescriptors","defaultFont","stripNewlines","member","newlineRegex","replace","breakLinesEntry"],"mappings":"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"}