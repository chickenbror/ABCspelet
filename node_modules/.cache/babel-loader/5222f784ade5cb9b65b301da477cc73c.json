{"ast":null,"code":"/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar Predicate = require('./Predicate'); // logger.setLevel('INFO');\n\n\nvar categoryWildCard = '*';\n\nfunction TransformationRule(c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2];\n  this.predicate = new Predicate(predicate, parameter1, parameter2);\n  this.oldCategory = c1;\n  this.newCategory = c2; // These members are for the learning algorithm\n\n  this.neutral = 0;\n  this.negative = 0;\n  this.positive = 0;\n  this.hasBeenSelectedAsHighRuleBefore = false;\n}\n\nTransformationRule.prototype.key = function () {\n  return this.literal.toString();\n};\n\nTransformationRule.prototype.apply = function (sentence, position) {\n  if (sentence.taggedWords[position].tag === this.oldCategory || this.oldCategory === categoryWildCard) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.newCategory;\n    }\n  }\n}; //\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\n\n\nTransformationRule.prototype.isApplicableAt = function (sentence, taggedSentence, i) {\n  var applies = taggedSentence.taggedWords[i].tag === this.oldCategory && this.predicate.evaluate(taggedSentence, i); // Set newTag to let the trainer know what the new tag would become\n\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.newCategory;\n  }\n\n  return applies;\n};\n\nTransformationRule.prototype.prettyPrint = function () {\n  var result = ''; // Old category and new category\n\n  result += this.oldCategory + ' ' + this.newCategory; // Predicate name\n\n  result += ' ' + this.predicate.name; // Parameter 1 and 2\n\n  if (this.predicate.parameter1) {\n    result += ' ' + this.predicate.parameter1;\n\n    if (this.predicate.parameter2) {\n      result += ' ' + this.predicate.parameter2;\n    }\n  }\n\n  return result;\n}; // Applies the rule the given location (if it applies)\n\n\nTransformationRule.prototype.applyAt = function (sentence, i) {\n  var taggedSentence = sentence.clone();\n  this.apply(sentence, i); // Assign the new tag to the corpus site\n\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag;\n}; // Calculate the net score of this rule\n\n\nTransformationRule.prototype.score = function () {\n  return this.positive - this.negative;\n};\n\nmodule.exports = TransformationRule;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/TransformationRule.js"],"names":["Predicate","require","categoryWildCard","TransformationRule","c1","c2","predicate","parameter1","parameter2","literal","oldCategory","newCategory","neutral","negative","positive","hasBeenSelectedAsHighRuleBefore","prototype","key","toString","apply","sentence","position","taggedWords","tag","evaluate","isApplicableAt","taggedSentence","i","applies","newTag","prettyPrint","result","name","applyAt","clone","testTag","score","module","exports"],"mappings":"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","sourcesContent":["/*\n  Transformation rules for the Brill tagger\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst Predicate = require('./Predicate')\n\n// logger.setLevel('INFO');\n\nconst categoryWildCard = '*'\n\nfunction TransformationRule (c1, c2, predicate, parameter1, parameter2) {\n  this.literal = [c1, c2, predicate, parameter1, parameter2]\n  this.predicate = new Predicate(predicate, parameter1, parameter2)\n  this.oldCategory = c1\n  this.newCategory = c2\n  // These members are for the learning algorithm\n  this.neutral = 0\n  this.negative = 0\n  this.positive = 0\n  this.hasBeenSelectedAsHighRuleBefore = false\n}\n\nTransformationRule.prototype.key = function () {\n  return (this.literal.toString())\n}\n\nTransformationRule.prototype.apply = function (sentence, position) {\n  if ((sentence.taggedWords[position].tag === this.oldCategory) ||\n      (this.oldCategory === categoryWildCard)) {\n    if (this.predicate.evaluate(sentence, position)) {\n      sentence.taggedWords[position].tag = this.newCategory\n    }\n  }\n}\n\n//\n// Methods for processing sentences from a corpus that consist of an array of tokens\n//\n\n// Returns true if the rule applies at site. As a side effect it assigns the new\n// category to newTag\nTransformationRule.prototype.isApplicableAt = function (sentence, taggedSentence, i) {\n  const applies = (taggedSentence.taggedWords[i].tag === this.oldCategory) &&\n    this.predicate.evaluate(taggedSentence, i)\n\n  // Set newTag to let the trainer know what the new tag would become\n  if (applies) {\n    sentence.taggedWords[i].newTag = this.newCategory\n  }\n  return (applies)\n}\n\nTransformationRule.prototype.prettyPrint = function () {\n  let result = ''\n  // Old category and new category\n  result += this.oldCategory + ' ' + this.newCategory\n  // Predicate name\n  result += ' ' + this.predicate.name\n  // Parameter 1 and 2\n  if (this.predicate.parameter1) {\n    result += ' ' + this.predicate.parameter1\n    if (this.predicate.parameter2) {\n      result += ' ' + this.predicate.parameter2\n    }\n  }\n  return result\n}\n\n// Applies the rule the given location (if it applies)\nTransformationRule.prototype.applyAt = function (sentence, i) {\n  const taggedSentence = sentence.clone()\n\n  this.apply(sentence, i)\n  // Assign the new tag to the corpus site\n  sentence.taggedWords[i].testTag = taggedSentence.taggedWords[i].tag\n}\n\n// Calculate the net score of this rule\nTransformationRule.prototype.score = function () {\n  return (this.positive - this.negative)\n}\n\nmodule.exports = TransformationRule\n"]},"metadata":{},"sourceType":"script"}