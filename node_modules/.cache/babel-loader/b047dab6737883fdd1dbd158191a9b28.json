{"ast":null,"code":"/*\n    Classifier class that provides functionality for training and\n    classification\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar fs = require('fs');\n\nvar Context = require('./Context');\n\nvar Element = require('./Element');\n\nvar Sample = require('./Sample');\n\nvar Scaler = require('./GISScaler');\n\nvar FeatureSet = require('./FeatureSet');\n\nfunction Classifier(features, sample) {\n  if (features) {\n    this.features = features;\n  } else {\n    this.features = new FeatureSet();\n  }\n\n  this.features = features;\n\n  if (sample) {\n    this.sample = sample;\n  } else {\n    this.sample = new Sample();\n  }\n} // Loads a classifier from file.\n// Caveat: feature functions are generated from the sample elements. You need\n// to create your own specialisation of the Element class that can generate\n// your own specific feature functions\n\n\nClassifier.prototype.load = function (filename, ElementClass, callback) {\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (!err) {\n      var classifierData = JSON.parse(data);\n      var sample = new Sample();\n      classifierData.sample.elements.forEach(function (elementData) {\n        var elt = new ElementClass(elementData.a, new Context(elementData.b.data));\n        sample.addElement(elt);\n      });\n      var featureSet = new FeatureSet();\n      sample.generateFeatures(featureSet);\n      var classifier = new Classifier(featureSet, sample);\n      callback(err, classifier);\n    } else {\n      if (callback) {\n        callback(err);\n      }\n    }\n  });\n};\n\nClassifier.prototype.save = function (filename, callback) {\n  var data = JSON.stringify(this, null, 2);\n  var classifier = this;\n  fs.writeFile(filename, data, 'utf8', function (err) {\n    if (callback) {\n      callback(err, err ? null : classifier);\n    }\n  });\n};\n\nClassifier.prototype.addElement = function (x) {\n  this.sample.addElement(x);\n};\n\nClassifier.prototype.addDocument = function (context, classification, ElementClass) {\n  Classifier.prototype.addElement(new ElementClass(classification, context));\n};\n\nClassifier.prototype.train = function (maxIterations, minImprovement, approxExpectation) {\n  this.scaler = new Scaler(this.features, this.sample);\n  this.p = this.scaler.run(maxIterations, minImprovement, approxExpectation);\n};\n\nClassifier.prototype.getClassifications = function (b) {\n  var scores = [];\n  var that = this;\n  this.sample.getClasses().forEach(function (a) {\n    var x = new Element(a, b);\n    scores.push({\n      label: a,\n      value: that.p.calculateAPriori(x)\n    });\n  });\n  return scores;\n};\n\nClassifier.prototype.classify = function (b) {\n  var scores = this.getClassifications(b); // Sort the scores in an array\n\n  scores.sort(function (a, b) {\n    return b.value - a.value;\n  }); // Check if the classifier discriminates\n\n  var min = scores[scores.length - 1].value;\n  var max = scores[0].value;\n\n  if (min === max) {\n    return '';\n  } else {\n    // Return the highest scoring classes\n    return scores[0].label;\n  }\n};\n\nmodule.exports = Classifier;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/classifiers/maxent/Classifier.js"],"names":["fs","require","Context","Element","Sample","Scaler","FeatureSet","Classifier","features","sample","prototype","load","filename","ElementClass","callback","readFile","err","data","classifierData","JSON","parse","elements","forEach","elementData","elt","a","b","addElement","featureSet","generateFeatures","classifier","save","stringify","writeFile","x","addDocument","context","classification","train","maxIterations","minImprovement","approxExpectation","scaler","p","run","getClassifications","scores","that","getClasses","push","label","value","calculateAPriori","classify","sort","min","length","max","module","exports"],"mappings":"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","sourcesContent":["/*\n    Classifier class that provides functionality for training and\n    classification\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst fs = require('fs')\n\nconst Context = require('./Context')\nconst Element = require('./Element')\nconst Sample = require('./Sample')\nconst Scaler = require('./GISScaler')\nconst FeatureSet = require('./FeatureSet')\n\nfunction Classifier (features, sample) {\n  if (features) {\n    this.features = features\n  } else {\n    this.features = new FeatureSet()\n  }\n  this.features = features\n  if (sample) {\n    this.sample = sample\n  } else {\n    this.sample = new Sample()\n  }\n}\n\n// Loads a classifier from file.\n// Caveat: feature functions are generated from the sample elements. You need\n// to create your own specialisation of the Element class that can generate\n// your own specific feature functions\nClassifier.prototype.load = function (filename, ElementClass, callback) {\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (!err) {\n      const classifierData = JSON.parse(data)\n      const sample = new Sample()\n      classifierData.sample.elements.forEach(function (elementData) {\n        const elt = new ElementClass(elementData.a, new Context(elementData.b.data))\n        sample.addElement(elt)\n      })\n      const featureSet = new FeatureSet()\n      sample.generateFeatures(featureSet)\n      const classifier = new Classifier(featureSet, sample)\n      callback(err, classifier)\n    } else {\n      if (callback) {\n        callback(err)\n      }\n    }\n  })\n}\n\nClassifier.prototype.save = function (filename, callback) {\n  const data = JSON.stringify(this, null, 2)\n  const classifier = this\n  fs.writeFile(filename, data, 'utf8', function (err) {\n    if (callback) {\n      callback(err, err ? null : classifier)\n    }\n  })\n}\n\nClassifier.prototype.addElement = function (x) {\n  this.sample.addElement(x)\n}\n\nClassifier.prototype.addDocument = function (context, classification, ElementClass) {\n  Classifier.prototype.addElement(new ElementClass(classification, context))\n}\n\nClassifier.prototype.train = function (maxIterations, minImprovement, approxExpectation) {\n  this.scaler = new Scaler(this.features, this.sample)\n  this.p = this.scaler.run(maxIterations, minImprovement, approxExpectation)\n}\n\nClassifier.prototype.getClassifications = function (b) {\n  const scores = []\n  const that = this\n  this.sample.getClasses().forEach(function (a) {\n    const x = new Element(a, b)\n    scores.push({\n      label: a,\n      value: that.p.calculateAPriori(x)\n    })\n  })\n  return scores\n}\n\nClassifier.prototype.classify = function (b) {\n  const scores = this.getClassifications(b)\n  // Sort the scores in an array\n  scores.sort(function (a, b) {\n    return b.value - a.value\n  })\n  // Check if the classifier discriminates\n  const min = scores[scores.length - 1].value\n  const max = scores[0].value\n  if (min === max) {\n    return ''\n  } else {\n    // Return the highest scoring classes\n    return scores[0].label\n  }\n}\n\nmodule.exports = Classifier\n"]},"metadata":{},"sourceType":"script"}