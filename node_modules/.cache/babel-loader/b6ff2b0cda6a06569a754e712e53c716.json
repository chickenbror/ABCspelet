{"ast":null,"code":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Matrix class - depends on Vector.\nvar fs = require('fs');\n\nvar Sylvester = require('./sylvester');\n\nvar Vector = require('./vector'); // augment a matrix M with identity rows/cols\n\n\nfunction identSize(M, m, n, k) {\n  var e = M.elements;\n  var i = k - 1;\n\n  while (i--) {\n    var row = [];\n\n    for (var j = 0; j < n; j++) {\n      row.push(j == i ? 1 : 0);\n    }\n\n    e.unshift(row);\n  }\n\n  for (var i = k - 1; i < m; i++) {\n    while (e[i].length < n) {\n      e[i].unshift(0);\n    }\n  }\n\n  return $M(e);\n}\n\nfunction pca(X) {\n  var Sigma = X.transpose().x(X).x(1 / X.rows());\n  var svd = Sigma.svd();\n  return {\n    U: svd.U,\n    S: svd.S\n  };\n}\n\nfunction Matrix() {}\n\nMatrix.prototype = {\n  pcaProject: function pcaProject(k, U) {\n    var U = U || pca(this).U;\n    var Ureduce = U.slice(1, U.rows(), 1, k);\n    return {\n      Z: this.x(Ureduce),\n      U: U\n    };\n  },\n  pcaRecover: function pcaRecover(U) {\n    var k = this.cols();\n    var Ureduce = U.slice(1, U.rows(), 1, k);\n    return this.x(Ureduce.transpose());\n  },\n  triu: function triu(k) {\n    if (!k) k = 0;\n    return this.map(function (x, i, j) {\n      return j - i >= k ? x : 0;\n    });\n  },\n  svd: function svd() {\n    var A = this;\n    var U = Matrix.I(A.rows());\n    var S = A.transpose();\n    var V = Matrix.I(A.cols());\n    var err = Number.MAX_VALUE;\n    var i = 0;\n    var maxLoop = 100;\n\n    while (err > 2.2737e-13 && i < maxLoop) {\n      var qr = S.transpose().qr();\n      S = qr.R;\n      U = U.x(qr.Q);\n      qr = S.transpose().qr();\n      V = V.x(qr.Q);\n      S = qr.R;\n      var e = S.triu(1).unroll().norm();\n      var f = S.diagonal().norm();\n      if (f == 0) f = 1;\n      err = e / f;\n      i++;\n    }\n\n    var ss = S.diagonal();\n    var s = [];\n\n    for (var i = 1; i <= ss.cols(); i++) {\n      var ssn = ss.e(i);\n      s.push(Math.abs(ssn));\n\n      if (ssn < 0) {\n        for (var j = 0; j < U.rows(); j++) {\n          U.elements[j][i - 1] = -U.elements[j][i - 1];\n        }\n      }\n    }\n\n    return {\n      U: U,\n      S: $V(s).toDiagonalMatrix(),\n      V: V\n    };\n  },\n  unroll: function unroll() {\n    var v = [];\n\n    for (var i = 1; i <= this.cols(); i++) {\n      for (var j = 1; j <= this.rows(); j++) {\n        v.push(this.e(j, i));\n      }\n    }\n\n    return $V(v);\n  },\n  qr: function qr() {\n    var m = this.rows();\n    var n = this.cols();\n    var Q = Matrix.I(m);\n    var A = this;\n\n    for (var k = 1; k < Math.min(m, n); k++) {\n      var ak = A.slice(k, 0, k, k).col(1);\n      var oneZero = [1];\n\n      while (oneZero.length <= m - k) {\n        oneZero.push(0);\n      }\n\n      oneZero = $V(oneZero);\n      var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));\n      var Vk = $M(vk);\n      var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));\n      var Qk = identSize(Hk, m, n, k);\n      A = Qk.x(A);\n      Q = Q.x(Qk);\n    }\n\n    return {\n      Q: Q,\n      R: A\n    };\n  },\n  slice: function slice(startRow, endRow, startCol, endCol) {\n    var x = [];\n    if (endRow == 0) endRow = this.rows();\n    if (endCol == 0) endCol = this.cols();\n\n    for (i = startRow; i <= endRow; i++) {\n      var row = [];\n\n      for (j = startCol; j <= endCol; j++) {\n        row.push(this.e(i, j));\n      }\n\n      x.push(row);\n    }\n\n    return $M(x);\n  },\n  // Returns element (i,j) of the matrix\n  e: function e(i, j) {\n    if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) {\n      return null;\n    }\n\n    return this.elements[i - 1][j - 1];\n  },\n  // Returns row k of the matrix as a vector\n  row: function row(i) {\n    if (i > this.elements.length) {\n      return null;\n    }\n\n    return $V(this.elements[i - 1]);\n  },\n  // Returns column k of the matrix as a vector\n  col: function col(j) {\n    if (j > this.elements[0].length) {\n      return null;\n    }\n\n    var col = [],\n        n = this.elements.length;\n\n    for (var i = 0; i < n; i++) {\n      col.push(this.elements[i][j - 1]);\n    }\n\n    return $V(col);\n  },\n  // Returns the number of rows/columns the matrix has\n  dimensions: function dimensions() {\n    return {\n      rows: this.elements.length,\n      cols: this.elements[0].length\n    };\n  },\n  // Returns the number of rows in the matrix\n  rows: function rows() {\n    return this.elements.length;\n  },\n  // Returns the number of columns in the matrix\n  cols: function cols() {\n    return this.elements[0].length;\n  },\n  // Returns true iff the matrix is equal to the argument. You can supply\n  // a vector as the argument, in which case the receiver must be a\n  // one-column matrix equal to the vector.\n  eql: function eql(matrix) {\n    var M = matrix.elements || matrix;\n\n    if (typeof M[0][0] == 'undefined') {\n      M = Matrix.create(M).elements;\n    }\n\n    if (this.elements.length != M.length || this.elements[0].length != M[0].length) {\n      return false;\n    }\n\n    var i = this.elements.length,\n        nj = this.elements[0].length,\n        j;\n\n    while (i--) {\n      j = nj;\n\n      while (j--) {\n        if (Math.abs(this.elements[i][j] - M[i][j]) > Sylvester.precision) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n  // Returns a copy of the matrix\n  dup: function dup() {\n    return Matrix.create(this.elements);\n  },\n  // Maps the matrix to another matrix (of the same dimensions) according to the given function\n  map: function map(fn) {\n    var els = [],\n        i = this.elements.length,\n        nj = this.elements[0].length,\n        j;\n\n    while (i--) {\n      j = nj;\n      els[i] = [];\n\n      while (j--) {\n        els[i][j] = fn(this.elements[i][j], i + 1, j + 1);\n      }\n    }\n\n    return Matrix.create(els);\n  },\n  // Returns true iff the argument has the same dimensions as the matrix\n  isSameSizeAs: function isSameSizeAs(matrix) {\n    var M = matrix.elements || matrix;\n\n    if (typeof M[0][0] == 'undefined') {\n      M = Matrix.create(M).elements;\n    }\n\n    return this.elements.length == M.length && this.elements[0].length == M[0].length;\n  },\n  // Returns the result of adding the argument to the matrix\n  add: function add(matrix) {\n    if (typeof matrix == 'number') {\n      return this.map(function (x, i, j) {\n        return x + matrix;\n      });\n    } else {\n      var M = matrix.elements || matrix;\n\n      if (typeof M[0][0] == 'undefined') {\n        M = Matrix.create(M).elements;\n      }\n\n      if (!this.isSameSizeAs(M)) {\n        return null;\n      }\n\n      return this.map(function (x, i, j) {\n        return x + M[i - 1][j - 1];\n      });\n    }\n  },\n  // Returns the result of subtracting the argument from the matrix\n  subtract: function subtract(matrix) {\n    if (typeof matrix == 'number') {\n      return this.map(function (x, i, j) {\n        return x - matrix;\n      });\n    } else {\n      var M = matrix.elements || matrix;\n\n      if (typeof M[0][0] == 'undefined') {\n        M = Matrix.create(M).elements;\n      }\n\n      if (!this.isSameSizeAs(M)) {\n        return null;\n      }\n\n      return this.map(function (x, i, j) {\n        return x - M[i - 1][j - 1];\n      });\n    }\n  },\n  // Returns true iff the matrix can multiply the argument from the left\n  canMultiplyFromLeft: function canMultiplyFromLeft(matrix) {\n    var M = matrix.elements || matrix;\n\n    if (typeof M[0][0] == 'undefined') {\n      M = Matrix.create(M).elements;\n    } // this.columns should equal matrix.rows\n\n\n    return this.elements[0].length == M.length;\n  },\n  // Returns the result of a multiplication-style operation the matrix from the right by the argument.\n  // If the argument is a scalar then just operate on all the elements. If the argument is\n  // a vector, a vector is returned, which saves you having to remember calling\n  // col(1) on the result.\n  mulOp: function mulOp(matrix, op) {\n    if (!matrix.elements) {\n      return this.map(function (x) {\n        return op(x, matrix);\n      });\n    }\n\n    var returnVector = matrix.modulus ? true : false;\n    var M = matrix.elements || matrix;\n    if (typeof M[0][0] == 'undefined') M = Matrix.create(M).elements;\n    if (!this.canMultiplyFromLeft(M)) return null;\n    var e = this.elements,\n        rowThis,\n        rowElem,\n        elements = [],\n        sum,\n        m = e.length,\n        n = M[0].length,\n        o = e[0].length,\n        i = m,\n        j,\n        k;\n\n    while (i--) {\n      rowElem = [];\n      rowThis = e[i];\n      j = n;\n\n      while (j--) {\n        sum = 0;\n        k = o;\n\n        while (k--) {\n          sum += op(rowThis[k], M[k][j]);\n        }\n\n        rowElem[j] = sum;\n      }\n\n      elements[i] = rowElem;\n    }\n\n    var M = Matrix.create(elements);\n    return returnVector ? M.col(1) : M;\n  },\n  // Returns the result of dividing the matrix from the right by the argument.\n  // If the argument is a scalar then just divide all the elements. If the argument is\n  // a vector, a vector is returned, which saves you having to remember calling\n  // col(1) on the result.\n  div: function div(matrix) {\n    return this.mulOp(matrix, function (x, y) {\n      return x / y;\n    });\n  },\n  // Returns the result of multiplying the matrix from the right by the argument.\n  // If the argument is a scalar then just multiply all the elements. If the argument is\n  // a vector, a vector is returned, which saves you having to remember calling\n  // col(1) on the result.\n  multiply: function multiply(matrix) {\n    return this.mulOp(matrix, function (x, y) {\n      return x * y;\n    });\n  },\n  x: function x(matrix) {\n    return this.multiply(matrix);\n  },\n  elementMultiply: function elementMultiply(v) {\n    return this.map(function (k, i, j) {\n      return v.e(i, j) * k;\n    });\n  },\n  sum: function sum() {\n    var sum = 0;\n    this.map(function (x) {\n      sum += x;\n    });\n    return sum;\n  },\n  // Returns a Vector of each colum averaged.\n  mean: function mean() {\n    var dim = this.dimensions();\n    var r = [];\n\n    for (var i = 1; i <= dim.cols; i++) {\n      r.push(this.col(i).sum() / dim.rows);\n    }\n\n    return $V(r);\n  },\n  column: function column(n) {\n    return this.col(n);\n  },\n  log: function log() {\n    return this.map(function (x) {\n      return Math.log(x);\n    });\n  },\n  // Returns a submatrix taken from the matrix\n  // Argument order is: start row, start col, nrows, ncols\n  // Element selection wraps if the required index is outside the matrix's bounds, so you could\n  // use this to perform row/column cycling or copy-augmenting.\n  minor: function minor(a, b, c, d) {\n    var elements = [],\n        ni = c,\n        i,\n        nj,\n        j;\n    var rows = this.elements.length,\n        cols = this.elements[0].length;\n\n    while (ni--) {\n      i = c - ni - 1;\n      elements[i] = [];\n      nj = d;\n\n      while (nj--) {\n        j = d - nj - 1;\n        elements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];\n      }\n    }\n\n    return Matrix.create(elements);\n  },\n  // Returns the transpose of the matrix\n  transpose: function transpose() {\n    var rows = this.elements.length,\n        i,\n        cols = this.elements[0].length,\n        j;\n    var elements = [],\n        i = cols;\n\n    while (i--) {\n      j = rows;\n      elements[i] = [];\n\n      while (j--) {\n        elements[i][j] = this.elements[j][i];\n      }\n    }\n\n    return Matrix.create(elements);\n  },\n  // Returns true iff the matrix is square\n  isSquare: function isSquare() {\n    return this.elements.length == this.elements[0].length;\n  },\n  // Returns the (absolute) largest element of the matrix\n  max: function max() {\n    var m = 0,\n        i = this.elements.length,\n        nj = this.elements[0].length,\n        j;\n\n    while (i--) {\n      j = nj;\n\n      while (j--) {\n        if (Math.abs(this.elements[i][j]) > Math.abs(m)) {\n          m = this.elements[i][j];\n        }\n      }\n    }\n\n    return m;\n  },\n  // Returns the indeces of the first match found by reading row-by-row from left to right\n  indexOf: function indexOf(x) {\n    var index = null,\n        ni = this.elements.length,\n        i,\n        nj = this.elements[0].length,\n        j;\n\n    for (i = 0; i < ni; i++) {\n      for (j = 0; j < nj; j++) {\n        if (this.elements[i][j] == x) {\n          return {\n            i: i + 1,\n            j: j + 1\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n  // If the matrix is square, returns the diagonal elements as a vector.\n  // Otherwise, returns null.\n  diagonal: function diagonal() {\n    if (!this.isSquare) {\n      return null;\n    }\n\n    var els = [],\n        n = this.elements.length;\n\n    for (var i = 0; i < n; i++) {\n      els.push(this.elements[i][i]);\n    }\n\n    return $V(els);\n  },\n  // Make the matrix upper (right) triangular by Gaussian elimination.\n  // This method only adds multiples of rows to other rows. No rows are\n  // scaled up or switched, and the determinant is preserved.\n  toRightTriangular: function toRightTriangular() {\n    var M = this.dup(),\n        els;\n    var n = this.elements.length,\n        i,\n        j,\n        np = this.elements[0].length,\n        p;\n\n    for (i = 0; i < n; i++) {\n      if (M.elements[i][i] == 0) {\n        for (j = i + 1; j < n; j++) {\n          if (M.elements[j][i] != 0) {\n            els = [];\n\n            for (p = 0; p < np; p++) {\n              els.push(M.elements[i][p] + M.elements[j][p]);\n            }\n\n            M.elements[i] = els;\n            break;\n          }\n        }\n      }\n\n      if (M.elements[i][i] != 0) {\n        for (j = i + 1; j < n; j++) {\n          var multiplier = M.elements[j][i] / M.elements[i][i];\n          els = [];\n\n          for (p = 0; p < np; p++) {\n            // Elements with column numbers up to an including the number\n            // of the row that we're subtracting can safely be set straight to\n            // zero, since that's the point of this routine and it avoids having\n            // to loop over and correct rounding errors later\n            els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);\n          }\n\n          M.elements[j] = els;\n        }\n      }\n    }\n\n    return M;\n  },\n  toUpperTriangular: function toUpperTriangular() {\n    return this.toRightTriangular();\n  },\n  // Returns the determinant for square matrices\n  determinant: function determinant() {\n    if (!this.isSquare()) {\n      return null;\n    }\n\n    if (this.cols == 1 && this.rows == 1) {\n      return this.row(1);\n    }\n\n    if (this.cols == 0 && this.rows == 0) {\n      return 1;\n    }\n\n    var M = this.toRightTriangular();\n    var det = M.elements[0][0],\n        n = M.elements.length;\n\n    for (var i = 1; i < n; i++) {\n      det = det * M.elements[i][i];\n    }\n\n    return det;\n  },\n  det: function det() {\n    return this.determinant();\n  },\n  // Returns true iff the matrix is singular\n  isSingular: function isSingular() {\n    return this.isSquare() && this.determinant() === 0;\n  },\n  // Returns the trace for square matrices\n  trace: function trace() {\n    if (!this.isSquare()) {\n      return null;\n    }\n\n    var tr = this.elements[0][0],\n        n = this.elements.length;\n\n    for (var i = 1; i < n; i++) {\n      tr += this.elements[i][i];\n    }\n\n    return tr;\n  },\n  tr: function tr() {\n    return this.trace();\n  },\n  // Returns the rank of the matrix\n  rank: function rank() {\n    var M = this.toRightTriangular(),\n        rank = 0;\n    var i = this.elements.length,\n        nj = this.elements[0].length,\n        j;\n\n    while (i--) {\n      j = nj;\n\n      while (j--) {\n        if (Math.abs(M.elements[i][j]) > Sylvester.precision) {\n          rank++;\n          break;\n        }\n      }\n    }\n\n    return rank;\n  },\n  rk: function rk() {\n    return this.rank();\n  },\n  // Returns the result of attaching the given argument to the right-hand side of the matrix\n  augment: function augment(matrix) {\n    var M = matrix.elements || matrix;\n\n    if (typeof M[0][0] == 'undefined') {\n      M = Matrix.create(M).elements;\n    }\n\n    var T = this.dup(),\n        cols = T.elements[0].length;\n    var i = T.elements.length,\n        nj = M[0].length,\n        j;\n\n    if (i != M.length) {\n      return null;\n    }\n\n    while (i--) {\n      j = nj;\n\n      while (j--) {\n        T.elements[i][cols + j] = M[i][j];\n      }\n    }\n\n    return T;\n  },\n  // Returns the inverse (if one exists) using Gauss-Jordan\n  inverse: function inverse() {\n    if (!this.isSquare() || this.isSingular()) {\n      return null;\n    }\n\n    var n = this.elements.length,\n        i = n,\n        j;\n    var M = this.augment(Matrix.I(n)).toRightTriangular();\n    var np = M.elements[0].length,\n        p,\n        els,\n        divisor;\n    var inverse_elements = [],\n        new_element; // Matrix is non-singular so there will be no zeros on the diagonal\n    // Cycle through rows from last to first\n\n    while (i--) {\n      // First, normalise diagonal elements to 1\n      els = [];\n      inverse_elements[i] = [];\n      divisor = M.elements[i][i];\n\n      for (p = 0; p < np; p++) {\n        new_element = M.elements[i][p] / divisor;\n        els.push(new_element); // Shuffle off the current row of the right hand side into the results\n        // array as it will not be modified by later runs through this loop\n\n        if (p >= n) {\n          inverse_elements[i].push(new_element);\n        }\n      }\n\n      M.elements[i] = els; // Then, subtract this row from those above it to\n      // give the identity matrix on the left hand side\n\n      j = i;\n\n      while (j--) {\n        els = [];\n\n        for (p = 0; p < np; p++) {\n          els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);\n        }\n\n        M.elements[j] = els;\n      }\n    }\n\n    return Matrix.create(inverse_elements);\n  },\n  inv: function inv() {\n    return this.inverse();\n  },\n  // Returns the result of rounding all the elements\n  round: function round() {\n    return this.map(function (x) {\n      return Math.round(x);\n    });\n  },\n  // Returns a copy of the matrix with elements set to the given value if they\n  // differ from it by less than Sylvester.precision\n  snapTo: function snapTo(x) {\n    return this.map(function (p) {\n      return Math.abs(p - x) <= Sylvester.precision ? x : p;\n    });\n  },\n  // Returns a string representation of the matrix\n  inspect: function inspect() {\n    var matrix_rows = [];\n    var n = this.elements.length;\n\n    for (var i = 0; i < n; i++) {\n      matrix_rows.push($V(this.elements[i]).inspect());\n    }\n\n    return matrix_rows.join('\\n');\n  },\n  // Returns a array representation of the matrix\n  toArray: function toArray() {\n    var matrix_rows = [];\n    var n = this.elements.length;\n\n    for (var i = 0; i < n; i++) {\n      matrix_rows.push(this.elements[i]);\n    }\n\n    return matrix_rows;\n  },\n  // Set the matrix's elements from an array. If the argument passed\n  // is a vector, the resulting matrix will be a single column.\n  setElements: function setElements(els) {\n    var i,\n        j,\n        elements = els.elements || els;\n\n    if (typeof elements[0][0] != 'undefined') {\n      i = elements.length;\n      this.elements = [];\n\n      while (i--) {\n        j = elements[i].length;\n        this.elements[i] = [];\n\n        while (j--) {\n          this.elements[i][j] = elements[i][j];\n        }\n      }\n\n      return this;\n    }\n\n    var n = elements.length;\n    this.elements = [];\n\n    for (i = 0; i < n; i++) {\n      this.elements.push([elements[i]]);\n    }\n\n    return this;\n  },\n  maxColumnIndexes: function maxColumnIndexes() {\n    var maxes = [];\n\n    for (var i = 1; i <= this.rows(); i++) {\n      var max = null;\n      var maxIndex = -1;\n\n      for (var j = 1; j <= this.cols(); j++) {\n        if (max === null || this.e(i, j) > max) {\n          max = this.e(i, j);\n          maxIndex = j;\n        }\n      }\n\n      maxes.push(maxIndex);\n    }\n\n    return $V(maxes);\n  },\n  maxColumns: function maxColumns() {\n    var maxes = [];\n\n    for (var i = 1; i <= this.rows(); i++) {\n      var max = null;\n\n      for (var j = 1; j <= this.cols(); j++) {\n        if (max === null || this.e(i, j) > max) {\n          max = this.e(i, j);\n        }\n      }\n\n      maxes.push(max);\n    }\n\n    return $V(maxes);\n  },\n  minColumnIndexes: function minColumnIndexes() {\n    var mins = [];\n\n    for (var i = 1; i <= this.rows(); i++) {\n      var min = null;\n      var minIndex = -1;\n\n      for (var j = 1; j <= this.cols(); j++) {\n        if (min === null || this.e(i, j) < min) {\n          min = this.e(i, j);\n          minIndex = j;\n        }\n      }\n\n      mins.push(minIndex);\n    }\n\n    return $V(mins);\n  },\n  minColumns: function minColumns() {\n    var mins = [];\n\n    for (var i = 1; i <= this.rows(); i++) {\n      var min = null;\n\n      for (var j = 1; j <= this.cols(); j++) {\n        if (min === null || this.e(i, j) < min) {\n          min = this.e(i, j);\n        }\n      }\n\n      mins.push(min);\n    }\n\n    return $V(mins);\n  }\n}; // Constructor function\n\nMatrix.create = function (elements) {\n  var M = new Matrix();\n  return M.setElements(elements);\n}; // Identity matrix of size n\n\n\nMatrix.I = function (n) {\n  var els = [],\n      i = n,\n      j;\n\n  while (i--) {\n    j = n;\n    els[i] = [];\n\n    while (j--) {\n      els[i][j] = i == j ? 1 : 0;\n    }\n  }\n\n  return Matrix.create(els);\n};\n\nMatrix.loadFile = function (file) {\n  var contents = fs.readFileSync(file, 'utf-8');\n  var matrix = [];\n  var rowArray = contents.split('\\n');\n\n  for (var i = 0; i < rowArray.length; i++) {\n    var d = rowArray[i].split(',');\n\n    if (d.length > 1) {\n      matrix.push(d);\n    }\n  }\n\n  var M = new Matrix();\n  return M.setElements(matrix);\n}; // Diagonal matrix - all off-diagonal elements are zero\n\n\nMatrix.Diagonal = function (elements) {\n  var i = elements.length;\n  var M = Matrix.I(i);\n\n  while (i--) {\n    M.elements[i][i] = elements[i];\n  }\n\n  return M;\n}; // Rotation matrix about some axis. If no axis is\n// supplied, assume we're after a 2D transform\n\n\nMatrix.Rotation = function (theta, a) {\n  if (!a) {\n    return Matrix.create([[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]]);\n  }\n\n  var axis = a.dup();\n\n  if (axis.elements.length != 3) {\n    return null;\n  }\n\n  var mod = axis.modulus();\n  var x = axis.elements[0] / mod,\n      y = axis.elements[1] / mod,\n      z = axis.elements[2] / mod;\n  var s = Math.sin(theta),\n      c = Math.cos(theta),\n      t = 1 - c; // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n  // That proof rotates the co-ordinate system so theta\n  // becomes -theta and sin becomes -sin here.\n\n  return Matrix.create([[t * x * x + c, t * x * y - s * z, t * x * z + s * y], [t * x * y + s * z, t * y * y + c, t * y * z - s * x], [t * x * z - s * y, t * y * z + s * x, t * z * z + c]]);\n}; // Special case rotations\n\n\nMatrix.RotationX = function (t) {\n  var c = Math.cos(t),\n      s = Math.sin(t);\n  return Matrix.create([[1, 0, 0], [0, c, -s], [0, s, c]]);\n};\n\nMatrix.RotationY = function (t) {\n  var c = Math.cos(t),\n      s = Math.sin(t);\n  return Matrix.create([[c, 0, s], [0, 1, 0], [-s, 0, c]]);\n};\n\nMatrix.RotationZ = function (t) {\n  var c = Math.cos(t),\n      s = Math.sin(t);\n  return Matrix.create([[c, -s, 0], [s, c, 0], [0, 0, 1]]);\n}; // Random matrix of n rows, m columns\n\n\nMatrix.Random = function (n, m) {\n  if (arguments.length === 1) m = n;\n  return Matrix.Zero(n, m).map(function () {\n    return Math.random();\n  });\n};\n\nMatrix.Fill = function (n, m, v) {\n  if (arguments.length === 2) {\n    v = m;\n    m = n;\n  }\n\n  var els = [],\n      i = n,\n      j;\n\n  while (i--) {\n    j = m;\n    els[i] = [];\n\n    while (j--) {\n      els[i][j] = v;\n    }\n  }\n\n  return Matrix.create(els);\n}; // Matrix filled with zeros\n\n\nMatrix.Zero = function (n, m) {\n  return Matrix.Fill(n, m, 0);\n}; // Matrix filled with zeros\n\n\nMatrix.Zeros = function (n, m) {\n  return Matrix.Zero(n, m);\n}; // Matrix filled with ones\n\n\nMatrix.One = function (n, m) {\n  return Matrix.Fill(n, m, 1);\n}; // Matrix filled with ones\n\n\nMatrix.Ones = function (n, m) {\n  return Matrix.One(n, m);\n};\n\nmodule.exports = Matrix;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/sylvester/lib/node-sylvester/matrix.js"],"names":["fs","require","Sylvester","Vector","identSize","M","m","n","k","e","elements","i","row","j","push","unshift","length","$M","pca","X","Sigma","transpose","x","rows","svd","U","S","Matrix","prototype","pcaProject","Ureduce","slice","Z","pcaRecover","cols","triu","map","A","I","V","err","Number","MAX_VALUE","maxLoop","qr","R","Q","unroll","norm","f","diagonal","ss","s","ssn","Math","abs","$V","toDiagonalMatrix","v","min","ak","col","oneZero","vk","add","sign","Vk","Hk","subtract","div","Qk","startRow","endRow","startCol","endCol","dimensions","eql","matrix","create","nj","precision","dup","fn","els","isSameSizeAs","canMultiplyFromLeft","mulOp","op","returnVector","modulus","rowThis","rowElem","sum","o","y","multiply","elementMultiply","mean","dim","r","column","log","minor","a","b","c","d","ni","isSquare","max","indexOf","index","toRightTriangular","np","p","multiplier","toUpperTriangular","determinant","det","isSingular","trace","tr","rank","rk","augment","T","inverse","divisor","inverse_elements","new_element","inv","round","snapTo","inspect","matrix_rows","join","toArray","setElements","maxColumnIndexes","maxes","maxIndex","maxColumns","minColumnIndexes","mins","minIndex","minColumns","loadFile","file","contents","readFileSync","rowArray","split","Diagonal","Rotation","theta","cos","sin","axis","mod","z","t","RotationX","RotationY","RotationZ","Random","arguments","Zero","random","Fill","Zeros","One","Ones","module","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2011, Chris Umbel, James Coglan\n// Matrix class - depends on Vector.\n\nvar fs = require('fs');\nvar Sylvester = require('./sylvester');\nvar Vector = require('./vector');\n\n// augment a matrix M with identity rows/cols\nfunction identSize(M, m, n, k) {\n    var e = M.elements;\n    var i = k - 1;\n\n    while(i--) {\n\tvar row = [];\n\t\n\tfor(var j = 0; j < n; j++)\n\t    row.push(j == i ? 1 : 0);\n\t\n        e.unshift(row);\n    }\n    \n    for(var i = k - 1; i < m; i++) {\n        while(e[i].length < n)\n            e[i].unshift(0);\n    }\n\n    return $M(e);\n}\n\nfunction pca(X) {\n    var Sigma = X.transpose().x(X).x(1 / X.rows());\n    var svd = Sigma.svd();\n    return {U: svd.U, S: svd.S};\n}\n\nfunction Matrix() {}\nMatrix.prototype = {\n    pcaProject: function(k, U) {\n\tvar U = U || pca(this).U;\n\tvar Ureduce= U.slice(1, U.rows(), 1, k);\n\treturn {Z: this.x(Ureduce), U: U};\n    },\n\n    pcaRecover: function(U) {\n\tvar k = this.cols();\n\tvar Ureduce = U.slice(1, U.rows(), 1, k);\n\treturn this.x(Ureduce.transpose());\n    },    \n\n    triu: function(k) {\n\tif(!k)\n\t    k = 0;\n\t\n\treturn this.map(function(x, i, j) {\n\t    return j - i >= k ? x : 0;\n\t});\n    },\n\n    svd: function() {\n\tvar A = this;\n\tvar U = Matrix.I(A.rows());\n\tvar S = A.transpose();\n\tvar V = Matrix.I(A.cols());\n\tvar err = Number.MAX_VALUE;\n\tvar i = 0;\n\tvar maxLoop = 100;\n\n\twhile(err > 2.2737e-13 && i < maxLoop) {\n\t    var qr = S.transpose().qr();\n\t    S = qr.R;\n\t    U = U.x(qr.Q);\n\t    qr = S.transpose().qr();\n\t    V = V.x(qr.Q);\n\t    S = qr.R;\n\n\t    var e = S.triu(1).unroll().norm();\n\t    var f = S.diagonal().norm();\n\n\t    if(f == 0)\n\t\tf = 1;\n\n\t    err = e / f;\n\n\t    i++;\n\t}\n\n\tvar ss = S.diagonal();\n\tvar s = [];\n\n\tfor(var i = 1; i <= ss.cols(); i++) {\n\t    var ssn = ss.e(i);\n\t    s.push(Math.abs(ssn));\n\n\t    if(ssn < 0) {\n\t\tfor(var j = 0; j < U.rows(); j++) {\n\t\t    U.elements[j][i - 1] = -(U.elements[j][i - 1]);\n\t\t}\n\t    }\n\t}\n\n\treturn {U: U, S: $V(s).toDiagonalMatrix(), V: V};\n    },\n\n    unroll: function() {\n\tvar v = [];\n\t\n\tfor(var i = 1; i <= this.cols(); i++) {\n\t    for(var j = 1; j <= this.rows(); j++) {\n\t\tv.push(this.e(j, i));\n\t    }\n\t}\n\n\treturn $V(v);\n    },\n\n    qr: function() {\n\tvar m = this.rows();\n\tvar n = this.cols();\n\tvar Q = Matrix.I(m);\n\tvar A = this;\n\t\n\tfor(var k = 1; k < Math.min(m, n); k++) {\n\t    var ak = A.slice(k, 0, k, k).col(1);\n\t    var oneZero = [1];\n\t    \n\t    while(oneZero.length <=  m - k)\n\t\toneZero.push(0);\n\t    \n\t    oneZero = $V(oneZero);\n\t    var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));\n\t    var Vk = $M(vk);\n\t    var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));\n\t    var Qk = identSize(Hk, m, n, k);\n\t    A = Qk.x(A);\n\t    Q = Q.x(Qk);\n\t}\n\n\treturn {Q: Q, R: A};\n    },\n\n\n    slice: function(startRow, endRow, startCol, endCol) {\n\tvar x = [];\n\t\n\tif(endRow == 0)\n\t    endRow = this.rows();\n\t\n\tif(endCol == 0)\n\t    endCol = this.cols();\n\n\tfor(i = startRow; i <= endRow; i++) {\n\t    var row = [];\n\n\t    for(j = startCol; j <= endCol; j++) {\n\t\trow.push(this.e(i, j));\n\t    }\n\n\t    x.push(row);\n\t}\n\n\treturn $M(x);\n    },\n\n    // Returns element (i,j) of the matrix\n    e: function(i,j) {\n\tif (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) { return null; }\n\treturn this.elements[i - 1][j - 1];\n    },\n\n    // Returns row k of the matrix as a vector\n    row: function(i) {\n\tif (i > this.elements.length) { return null; }\n\treturn $V(this.elements[i - 1]);\n    },\n\n    // Returns column k of the matrix as a vector\n    col: function(j) {\n\tif (j > this.elements[0].length) { return null; }\n\tvar col = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) { col.push(this.elements[i][j - 1]); }\n\treturn $V(col);\n    },\n\n    // Returns the number of rows/columns the matrix has\n    dimensions: function() {\n\treturn {rows: this.elements.length, cols: this.elements[0].length};\n    },\n\n    // Returns the number of rows in the matrix\n    rows: function() {\n\treturn this.elements.length;\n    },\n\n    // Returns the number of columns in the matrix\n    cols: function() {\n\treturn this.elements[0].length;\n    },\n\n    // Returns true iff the matrix is equal to the argument. You can supply\n    // a vector as the argument, in which case the receiver must be a\n    // one-column matrix equal to the vector.\n    eql: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tif (this.elements.length != M.length ||\n            this.elements[0].length != M[0].length) { return false; }\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      while (j--) {\n\t\t\t  if (Math.abs(this.elements[i][j] - M[i][j]) > Sylvester.precision) { return false; }\n\t\t      }\n\t\t    }\n\treturn true;\n    },\n\n    // Returns a copy of the matrix\n    dup: function() {\n\treturn Matrix.create(this.elements);\n    },\n\n    // Maps the matrix to another matrix (of the same dimensions) according to the given function\n    map: function(fn) {\n    var els = [], i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      els[i] = [];\n\t\t      while (j--) {\n\t\t\t  els[i][j] = fn(this.elements[i][j], i + 1, j + 1);\n\t\t      }\n\t\t    }\n\treturn Matrix.create(els);\n    },\n\n    // Returns true iff the argument has the same dimensions as the matrix\n    isSameSizeAs: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\treturn (this.elements.length == M.length &&\n\t\tthis.elements[0].length == M[0].length);\n    },\n\n    // Returns the result of adding the argument to the matrix\n    add: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x + matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x + M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns the result of subtracting the argument from the matrix\n    subtract: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x - matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x - M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns true iff the matrix can multiply the argument from the left\n    canMultiplyFromLeft: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t// this.columns should equal matrix.rows\n\treturn (this.elements[0].length == M.length);\n    },\n\n    // Returns the result of a multiplication-style operation the matrix from the right by the argument.\n    // If the argument is a scalar then just operate on all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    mulOp: function(matrix, op) {\n\tif (!matrix.elements) {\n\t    return this.map(function(x) { return op(x, matrix); });\n\t}\n\n\tvar returnVector = matrix.modulus ? true : false;\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') \n\t    M = Matrix.create(M).elements;\n\tif (!this.canMultiplyFromLeft(M)) \n\t    return null; \n\tvar e = this.elements, rowThis, rowElem, elements = [],\n        sum, m = e.length, n = M[0].length, o = e[0].length, i = m, j, k;\n\n\twhile (i--) {\n            rowElem = [];\n            rowThis = e[i];\n            j = n;\n\n            while (j--) {\n\t\tsum = 0;\n\t\tk = o;\n\n\t\twhile (k--) {\n                    sum += op(rowThis[k], M[k][j]);\n\t\t}\n\n\t\trowElem[j] = sum;\n            }\n\n            elements[i] = rowElem;\n\t}\n\n\tvar M = Matrix.create(elements);\n\treturn returnVector ? M.col(1) : M;\n    },\n\n    // Returns the result of dividing the matrix from the right by the argument.\n    // If the argument is a scalar then just divide all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    div: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x / y});\n    },\n\n    // Returns the result of multiplying the matrix from the right by the argument.\n    // If the argument is a scalar then just multiply all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    multiply: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x * y});\n    },\n\n    x: function(matrix) { return this.multiply(matrix); },\n\n    elementMultiply: function(v) {\n        return this.map(function(k, i, j) {\n            return v.e(i, j) * k;\n        });\n    },\n\n    sum: function() {\n        var sum = 0;\n\n        this.map(function(x) { sum += x;});\n\n        return sum;\n    },\n\n    // Returns a Vector of each colum averaged.\n    mean: function() {\n      var dim = this.dimensions();\n      var r = [];\n      for (var i = 1; i <= dim.cols; i++) {\n        r.push(this.col(i).sum() / dim.rows);\n      }\n      return $V(r);\n    },\n\n    column: function(n) {\n\treturn this.col(n);\n    },\n\n    log: function() {\n\treturn this.map(function(x) { return Math.log(x); });\n    },\n\n    // Returns a submatrix taken from the matrix\n    // Argument order is: start row, start col, nrows, ncols\n    // Element selection wraps if the required index is outside the matrix's bounds, so you could\n    // use this to perform row/column cycling or copy-augmenting.\n    minor: function(a, b, c, d) {\n\tvar elements = [], ni = c, i, nj, j;\n\tvar rows = this.elements.length, cols = this.elements[0].length;\n\twhile (ni--) {\n\t    i = c - ni - 1;\n\t    elements[i] = [];\n\t    nj = d;\n\t    while (nj--) {\n\t\tj = d - nj - 1;\n\t\telements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns the transpose of the matrix\n    transpose: function() {\n    var rows = this.elements.length, i, cols = this.elements[0].length, j;\n\tvar elements = [], i = cols;\n\twhile (i--) {\n\t    j = rows;\n\t    elements[i] = [];\n\t    while (j--) {\n\t\telements[i][j] = this.elements[j][i];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns true iff the matrix is square\n    isSquare: function() {\n\treturn (this.elements.length == this.elements[0].length);\n    },\n\n    // Returns the (absolute) largest element of the matrix\n    max: function() {\n\tvar m = 0, i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(this.elements[i][j]) > Math.abs(m)) { m = this.elements[i][j]; }\n\t    }\n\t}\n\treturn m;\n    },\n\n    // Returns the indeces of the first match found by reading row-by-row from left to right\n    indexOf: function(x) {\n\tvar index = null, ni = this.elements.length, i, nj = this.elements[0].length, j;\n\tfor (i = 0; i < ni; i++) {\n\t    for (j = 0; j < nj; j++) {\n\t\tif (this.elements[i][j] == x) { return {i: i + 1, j: j + 1}; }\n\t    }\n\t}\n\treturn null;\n    },\n\n    // If the matrix is square, returns the diagonal elements as a vector.\n    // Otherwise, returns null.\n    diagonal: function() {\n\tif (!this.isSquare) { return null; }\n\tvar els = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    els.push(this.elements[i][i]);\n\t}\n\treturn $V(els);\n    },\n\n    // Make the matrix upper (right) triangular by Gaussian elimination.\n    // This method only adds multiples of rows to other rows. No rows are\n    // scaled up or switched, and the determinant is preserved.\n    toRightTriangular: function() {\n\tvar M = this.dup(), els;\n\tvar n = this.elements.length, i, j, np = this.elements[0].length, p;\n\tfor (i = 0; i < n; i++) {\n\t    if (M.elements[i][i] == 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    if (M.elements[j][i] != 0) {\n\t\t\tels = [];\n\t\t\tfor (p = 0; p < np; p++) { els.push(M.elements[i][p] + M.elements[j][p]); }\n\t\t\tM.elements[i] = els;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (M.elements[i][i] != 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    var multiplier = M.elements[j][i] / M.elements[i][i];\n\t\t    els = [];\n\t\t    for (p = 0; p < np; p++) {\n\t\t\t// Elements with column numbers up to an including the number\n\t\t\t// of the row that we're subtracting can safely be set straight to\n\t\t\t// zero, since that's the point of this routine and it avoids having\n\t\t\t// to loop over and correct rounding errors later\n\t\t\tels.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);\n\t\t    }\n\t\t    M.elements[j] = els;\n\t\t}\n\t    }\n\t}\n\treturn M;\n    },\n\n    toUpperTriangular: function() { return this.toRightTriangular(); },\n\n    // Returns the determinant for square matrices\n    determinant: function() {\n\tif (!this.isSquare()) { return null; }\n\tif (this.cols == 1 && this.rows == 1) { return this.row(1); }\n\tif (this.cols == 0 && this.rows == 0) { return 1; }\n\tvar M = this.toRightTriangular();\n\tvar det = M.elements[0][0], n = M.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    det = det * M.elements[i][i];\n\t}\n\treturn det;\n    },\n    det: function() { return this.determinant(); },\n\n    // Returns true iff the matrix is singular\n    isSingular: function() {\n\treturn (this.isSquare() && this.determinant() === 0);\n    },\n\n    // Returns the trace for square matrices\n    trace: function() {\n\tif (!this.isSquare()) { return null; }\n\tvar tr = this.elements[0][0], n = this.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    tr += this.elements[i][i];\n\t}\n\treturn tr;\n    },\n\n    tr: function() { return this.trace(); },\n\n    // Returns the rank of the matrix\n    rank: function() {\n\tvar M = this.toRightTriangular(), rank = 0;\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(M.elements[i][j]) > Sylvester.precision) { rank++; break; }\n\t    }\n\t}\n\treturn rank;\n    },\n\n    rk: function() { return this.rank(); },\n\n    // Returns the result of attaching the given argument to the right-hand side of the matrix\n    augment: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tvar T = this.dup(), cols = T.elements[0].length;\n\tvar i = T.elements.length, nj = M[0].length, j;\n\tif (i != M.length) { return null; }\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tT.elements[i][cols + j] = M[i][j];\n\t    }\n\t}\n\treturn T;\n    },\n\n    // Returns the inverse (if one exists) using Gauss-Jordan\n    inverse: function() {\n\tif (!this.isSquare() || this.isSingular()) { return null; }\n\tvar n = this.elements.length, i = n, j;\n\tvar M = this.augment(Matrix.I(n)).toRightTriangular();\n\tvar np = M.elements[0].length, p, els, divisor;\n\tvar inverse_elements = [], new_element;\n\t// Matrix is non-singular so there will be no zeros on the diagonal\n\t// Cycle through rows from last to first\n\twhile (i--) {\n\t    // First, normalise diagonal elements to 1\n\t    els = [];\n\t    inverse_elements[i] = [];\n\t    divisor = M.elements[i][i];\n\t    for (p = 0; p < np; p++) {\n        new_element = M.elements[i][p] / divisor;\n\t\tels.push(new_element);\n\t\t// Shuffle off the current row of the right hand side into the results\n\t\t// array as it will not be modified by later runs through this loop\n\t\tif (p >= n) { inverse_elements[i].push(new_element); }\n\t    }\n\t    M.elements[i] = els;\n\t    // Then, subtract this row from those above it to\n\t    // give the identity matrix on the left hand side\n\t    j = i;\n\t    while (j--) {\n\t\tels = [];\n\t\tfor (p = 0; p < np; p++) {\n\t\t    els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);\n\t\t}\n\t\tM.elements[j] = els;\n\t    }\n\t}\n\treturn Matrix.create(inverse_elements);\n    },\n\n    inv: function() { return this.inverse(); },\n\n    // Returns the result of rounding all the elements\n    round: function() {\n\treturn this.map(function(x) { return Math.round(x); });\n    },\n\n    // Returns a copy of the matrix with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n\treturn this.map(function(p) {\n\t    return (Math.abs(p - x) <= Sylvester.precision) ? x : p;\n\t});\n    },\n\n    // Returns a string representation of the matrix\n    inspect: function() {\n\tvar matrix_rows = [];\n\tvar n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    matrix_rows.push($V(this.elements[i]).inspect());\n\t}\n\treturn matrix_rows.join('\\n');\n    },\n\n    // Returns a array representation of the matrix\n    toArray: function() {\n    \tvar matrix_rows = [];\n    \tvar n = this.elements.length;\n    \tfor (var i = 0; i < n; i++) {\n        matrix_rows.push(this.elements[i]);\n    \t}\n      return matrix_rows;\n    },\n\n\n    // Set the matrix's elements from an array. If the argument passed\n    // is a vector, the resulting matrix will be a single column.\n    setElements: function(els) {\n\tvar i, j, elements = els.elements || els;\n\tif (typeof(elements[0][0]) != 'undefined') {\n\t    i = elements.length;\n\t    this.elements = [];\n\t    while (i--) {\n\t\tj = elements[i].length;\n\t\tthis.elements[i] = [];\n\t\twhile (j--) {\n\t\t    this.elements[i][j] = elements[i][j];\n\t\t}\n\t    }\n\t    return this;\n\t}\n\tvar n = elements.length;\n\tthis.elements = [];\n\tfor (i = 0; i < n; i++) {\n\t    this.elements.push([elements[i]]);\n\t}\n\treturn this;\n    },\n\n    maxColumnIndexes: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\t    var maxIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t    maxIndex = j;\n\t\t}\n\t    }\n\n\t    maxes.push(maxIndex);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    maxColumns: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t}\n\t    }\n\n\t    maxes.push(max);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    minColumnIndexes: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\t    var minIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t    minIndex = j;\n\t\t}\n\t    }\n\n\t    mins.push(minIndex);\n\t}\n\n\treturn $V(mins);\n    },\n\n    minColumns: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t}\n\t    }\n\n\t    mins.push(min);\n\t}\n\n\treturn $V(mins);\n    }\n};\n\n// Constructor function\nMatrix.create = function(elements) {\n    var M = new Matrix();\n    return M.setElements(elements);\n};\n\n// Identity matrix of size n\nMatrix.I = function(n) {\n    var els = [], i = n, j;\n    while (i--) {\n\tj = n;\n\tels[i] = [];\n\twhile (j--) {\n\t    els[i][j] = (i == j) ? 1 : 0;\n\t}\n    }\n    return Matrix.create(els);\n};\n\nMatrix.loadFile = function(file) {\n    var contents = fs.readFileSync(file, 'utf-8');\n    var matrix = [];\n\n    var rowArray = contents.split('\\n');\n    for (var i = 0; i < rowArray.length; i++) {\n\tvar d = rowArray[i].split(',');\n\tif (d.length > 1) {\n\t    matrix.push(d);\n\t}\n    }\n\n    var M = new Matrix();\n    return M.setElements(matrix);\n};\n\n// Diagonal matrix - all off-diagonal elements are zero\nMatrix.Diagonal = function(elements) {\n    var i = elements.length;\n    var M = Matrix.I(i);\n    while (i--) {\n\tM.elements[i][i] = elements[i];\n    }\n    return M;\n};\n\n// Rotation matrix about some axis. If no axis is\n// supplied, assume we're after a 2D transform\nMatrix.Rotation = function(theta, a) {\n    if (!a) {\n\treturn Matrix.create([\n\t    [Math.cos(theta), -Math.sin(theta)],\n\t    [Math.sin(theta), Math.cos(theta)]\n\t]);\n  }\n    var axis = a.dup();\n    if (axis.elements.length != 3) { return null; }\n    var mod = axis.modulus();\n    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;\n    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;\n    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n    // That proof rotates the co-ordinate system so theta\n    // becomes -theta and sin becomes -sin here.\n    return Matrix.create([\n\t[t * x * x + c, t * x * y - s * z, t * x * z + s * y],\n\t[t * x * y + s * z, t * y * y + c, t * y * z - s * x],\n\t[t * x * z - s * y, t * y * z + s * x, t * z * z + c]\n    ]);\n};\n\n// Special case rotations\nMatrix.RotationX = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[1, 0, 0],\n\t[0, c, -s],\n\t[0, s, c]\n    ]);\n};\n\nMatrix.RotationY = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, 0, s],\n\t[0, 1, 0],\n\t[-s, 0, c]\n    ]);\n};\n\nMatrix.RotationZ = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, -s, 0],\n\t[s, c, 0],\n\t[0, 0, 1]\n    ]);\n};\n\n// Random matrix of n rows, m columns\nMatrix.Random = function(n, m) {\n    if (arguments.length === 1) m = n;\n    return Matrix.Zero(n, m).map(\n\tfunction() { return Math.random(); }\n  );\n};\n\nMatrix.Fill = function(n, m, v) {\n    if (arguments.length === 2) {\n\tv = m;\n\tm = n;\n    }\n\n    var els = [], i = n, j;\n\n    while (i--) {\n\tj = m;\n\tels[i] = [];\n\n\twhile (j--) {\n\t    els[i][j] = v;\n\t}\n    }\n\n    return Matrix.create(els);\n};\n\n// Matrix filled with zeros\nMatrix.Zero = function(n, m) {\n    return Matrix.Fill(n, m, 0);\n};\n\n// Matrix filled with zeros\nMatrix.Zeros = function(n, m) {\n    return Matrix.Zero(n, m);\n};\n\n// Matrix filled with ones\nMatrix.One = function(n, m) {\n    return Matrix.Fill(n, m, 1);\n};\n\n// Matrix filled with ones\nMatrix.Ones = function(n, m) {\n    return Matrix.One(n, m);\n};\n\nmodule.exports = Matrix;\n"]},"metadata":{},"sourceType":"script"}