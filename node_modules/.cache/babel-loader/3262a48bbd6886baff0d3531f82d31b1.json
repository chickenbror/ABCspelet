{"ast":null,"code":"/*\n  Corpus class for parsing and analysing corpora\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar Lexicon = require('./Lexicon');\n\nvar BROWN = 1;\nvar JSON = 2; // sentences: an array of annotated sentences\n// A sentence is an array of annotated tokens\n// A token is an object with (token, tag, testTag, ruleList)\n\nfunction Corpus(data, typeOfCorpus, SentenceClass) {\n  this.wordCount = 0;\n  this.sentences = [];\n  var that = this;\n\n  if (data) {\n    // For other types of corpora add a case here and supply a parsing method\n    switch (typeOfCorpus) {\n      case BROWN:\n        this.parseBrownCorpus(data, SentenceClass);\n        break;\n\n      case JSON:\n        // Assume it is a JSON object of a corpus\n        data.sentences.forEach(function (s) {\n          var taggedSentence = new SentenceClass(s.taggedWords);\n          that.sentences.push(taggedSentence);\n          that.wordCount += s.taggedWords.length;\n        });\n        break;\n    }\n  }\n} // data is raw text\n// A corpus parsing method should split the corpus in sentences each of which\n// consist of an array of tokens.\n\n\nCorpus.prototype.parseBrownCorpus = function (data, SentenceClass) {\n  var that = this;\n  var lines = data.split('\\n');\n  lines.forEach(function (line) {\n    var trimmedLine = line.trim(); // Only parse lines that contain characters\n\n    if (trimmedLine !== '') {\n      var taggedSentence = new SentenceClass();\n      var tokens = line.trim().split(/\\s+/);\n      tokens.forEach(function (token) {\n        that.wordCount++; // Create a tagged sentences consisting of tokens\n\n        var wordPlusTag = token.split('_');\n        taggedSentence.addTaggedWord(wordPlusTag[0], wordPlusTag[1]);\n      }); // Add the sentence to the corpus\n\n      that.sentences.push(taggedSentence);\n    }\n  });\n}; // Returns an array of all POS tags used in the corpus\n\n\nCorpus.prototype.getTags = function () {\n  return Object.keys(this.posTags);\n}; // Splits the corpus in a training and testing set.\n// percentageTrain is the size of the training corpus in percent\n// Returns an array with two elements: training corpus, testing corpus\n\n\nCorpus.prototype.splitInTrainAndTest = function (percentageTrain) {\n  var corpusTrain = new Corpus();\n  var corpusTest = new Corpus();\n  var p = percentageTrain / 100;\n  this.sentences.forEach(function (sentence, i) {\n    if (Math.random() < p) {\n      corpusTrain.sentences.push(sentence);\n    } else {\n      corpusTest.sentences.push(sentence);\n    }\n  });\n  return [corpusTrain, corpusTest];\n}; // Analyses the corpus:\n// - registers used POS tags\n// - records the frequency of POS tag for each word\n\n\nCorpus.prototype.analyse = function () {\n  this.tagFrequencies = {};\n  this.posTags = {};\n  this.wordCount = 0;\n  var that = this;\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      that.wordCount++; // Register the tags used in the corpus\n\n      that.posTags[token.tag] = true; // Register the frequency of the tag\n\n      if (!that.tagFrequencies[token.token]) {\n        that.tagFrequencies[token.token] = {};\n      }\n\n      if (!that.tagFrequencies[token.token][token.tag]) {\n        that.tagFrequencies[token.token][token.tag] = 0;\n      }\n\n      that.tagFrequencies[token.token][token.tag]++;\n    });\n  });\n}; // Creates a lexicon by taking the most frequently occurring tag of a word\n// as the right tag\n\n\nCorpus.prototype.buildLexicon = function () {\n  var lexicon = new Lexicon();\n  var that = this;\n  this.analyse();\n  Object.keys(this.tagFrequencies).forEach(function (token) {\n    var catToFreq = that.tagFrequencies[token];\n    var categories = Object.keys(catToFreq);\n\n    function compareByFrequency(a, b) {\n      if (catToFreq[a] > catToFreq[b]) {\n        return -1;\n      } else {\n        if (catToFreq[a] < catToFreq[b]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    }\n\n    var sortedCategories = categories.sort(compareByFrequency);\n    lexicon.addWord(token, sortedCategories);\n  });\n  return lexicon;\n};\n\nCorpus.prototype.tag = function (lexicon) {\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      // tagWord returns a list of categories, take the first category\n      token.testTag = lexicon.tagWord(token.token)[0];\n    });\n  });\n};\n\nCorpus.prototype.nrSentences = function () {\n  return this.sentences.length;\n};\n\nCorpus.prototype.nrWords = function () {\n  return this.wordCount;\n};\n\nCorpus.prototype.generateFeatures = function () {\n  var features = [];\n  this.sentences.forEach(function (sentence) {\n    features = sentence.generateFeatures(features);\n  }); // console.log(JSON.stringify(features));\n\n  return features;\n};\n\nCorpus.prototype.prettyPrint = function () {\n  this.sentences.forEach(function (sentence, index) {// logger.debug(\"sentence no \" + index + \"\\n\" +\n    //  JSON.stringify(sentence, null, 2));\n  });\n};\n\nmodule.exports = Corpus;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/Corpus.js"],"names":["Lexicon","require","BROWN","JSON","Corpus","data","typeOfCorpus","SentenceClass","wordCount","sentences","that","parseBrownCorpus","forEach","s","taggedSentence","taggedWords","push","length","prototype","lines","split","line","trimmedLine","trim","tokens","token","wordPlusTag","addTaggedWord","getTags","Object","keys","posTags","splitInTrainAndTest","percentageTrain","corpusTrain","corpusTest","p","sentence","i","Math","random","analyse","tagFrequencies","tag","buildLexicon","lexicon","catToFreq","categories","compareByFrequency","a","b","sortedCategories","sort","addWord","testTag","tagWord","nrSentences","nrWords","generateFeatures","features","prettyPrint","index","module","exports"],"mappings":"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","sourcesContent":["/*\n  Corpus class for parsing and analysing corpora\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst Lexicon = require('./Lexicon')\n\nconst BROWN = 1\nconst JSON = 2\n\n// sentences: an array of annotated sentences\n// A sentence is an array of annotated tokens\n// A token is an object with (token, tag, testTag, ruleList)\nfunction Corpus (data, typeOfCorpus, SentenceClass) {\n  this.wordCount = 0\n  this.sentences = []\n  const that = this\n  if (data) {\n    // For other types of corpora add a case here and supply a parsing method\n    switch (typeOfCorpus) {\n      case BROWN:\n        this.parseBrownCorpus(data, SentenceClass)\n        break\n      case JSON:\n        // Assume it is a JSON object of a corpus\n        data.sentences.forEach(function (s) {\n          const taggedSentence = new SentenceClass(s.taggedWords)\n          that.sentences.push(taggedSentence)\n          that.wordCount += s.taggedWords.length\n        })\n        break\n    }\n  }\n}\n\n// data is raw text\n// A corpus parsing method should split the corpus in sentences each of which\n// consist of an array of tokens.\nCorpus.prototype.parseBrownCorpus = function (data, SentenceClass) {\n  const that = this\n\n  const lines = data.split('\\n')\n  lines.forEach(function (line) {\n    const trimmedLine = line.trim()\n    // Only parse lines that contain characters\n    if (trimmedLine !== '') {\n      const taggedSentence = new SentenceClass()\n      const tokens = line.trim().split(/\\s+/)\n      tokens.forEach(function (token) {\n        that.wordCount++\n        // Create a tagged sentences consisting of tokens\n        const wordPlusTag = token.split('_')\n        taggedSentence.addTaggedWord(wordPlusTag[0], wordPlusTag[1])\n      })\n\n      // Add the sentence to the corpus\n      that.sentences.push(taggedSentence)\n    }\n  })\n}\n\n// Returns an array of all POS tags used in the corpus\nCorpus.prototype.getTags = function () {\n  return Object.keys(this.posTags)\n}\n\n// Splits the corpus in a training and testing set.\n// percentageTrain is the size of the training corpus in percent\n// Returns an array with two elements: training corpus, testing corpus\nCorpus.prototype.splitInTrainAndTest = function (percentageTrain) {\n  const corpusTrain = new Corpus()\n  const corpusTest = new Corpus()\n\n  const p = percentageTrain / 100\n  this.sentences.forEach(function (sentence, i) {\n    if (Math.random() < p) {\n      corpusTrain.sentences.push(sentence)\n    } else {\n      corpusTest.sentences.push(sentence)\n    }\n  })\n  return [corpusTrain, corpusTest]\n}\n\n// Analyses the corpus:\n// - registers used POS tags\n// - records the frequency of POS tag for each word\nCorpus.prototype.analyse = function () {\n  this.tagFrequencies = {}\n  this.posTags = {}\n  this.wordCount = 0\n\n  const that = this\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      that.wordCount++\n\n      // Register the tags used in the corpus\n      that.posTags[token.tag] = true\n\n      // Register the frequency of the tag\n      if (!that.tagFrequencies[token.token]) {\n        that.tagFrequencies[token.token] = {}\n      }\n      if (!that.tagFrequencies[token.token][token.tag]) {\n        that.tagFrequencies[token.token][token.tag] = 0\n      }\n      that.tagFrequencies[token.token][token.tag]++\n    })\n  })\n}\n\n// Creates a lexicon by taking the most frequently occurring tag of a word\n// as the right tag\nCorpus.prototype.buildLexicon = function () {\n  const lexicon = new Lexicon()\n  const that = this\n\n  this.analyse()\n  Object.keys(this.tagFrequencies).forEach(function (token) {\n    const catToFreq = that.tagFrequencies[token]\n    const categories = Object.keys(catToFreq)\n\n    function compareByFrequency (a, b) {\n      if (catToFreq[a] > catToFreq[b]) {\n        return -1\n      } else {\n        if (catToFreq[a] < catToFreq[b]) {\n          return 1\n        } else {\n          return 0\n        }\n      }\n    }\n\n    const sortedCategories = categories.sort(compareByFrequency)\n    lexicon.addWord(token, sortedCategories)\n  })\n  return lexicon\n}\n\nCorpus.prototype.tag = function (lexicon) {\n  this.sentences.forEach(function (sentence) {\n    sentence.taggedWords.forEach(function (token) {\n      // tagWord returns a list of categories, take the first category\n      token.testTag = lexicon.tagWord(token.token)[0]\n    })\n  })\n}\n\nCorpus.prototype.nrSentences = function () {\n  return this.sentences.length\n}\n\nCorpus.prototype.nrWords = function () {\n  return this.wordCount\n}\n\nCorpus.prototype.generateFeatures = function () {\n  let features = []\n  this.sentences.forEach(function (sentence) {\n    features = sentence.generateFeatures(features)\n  })\n  // console.log(JSON.stringify(features));\n  return features\n}\n\nCorpus.prototype.prettyPrint = function () {\n  this.sentences.forEach(function (sentence, index) {\n    // logger.debug(\"sentence no \" + index + \"\\n\" +\n    //  JSON.stringify(sentence, null, 2));\n  })\n}\n\nmodule.exports = Corpus\n"]},"metadata":{},"sourceType":"script"}