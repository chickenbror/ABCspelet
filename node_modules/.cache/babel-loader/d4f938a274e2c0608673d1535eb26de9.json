{"ast":null,"code":"import _toConsumableArray from \"C:/CodingProjects/ABCgame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:/CodingProjects/ABCgame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { assign, send } from \"xstate\"; //Instantiate a new obj for each new round of game\n\nimport { makeNewQuestions, randomChoice } from './game_codes/game';\n\nvar quesJSON = require('./game_codes/questions.json'); //Source of game questions; require() only works on server\n// let qs=makeNewQuestions(quesJSON)\n// console.log(qs.letter)\n// console.log(qs.ques)\n//Using \"Natural\" NLP library\n\n\nvar natural = require('natural'),\n    nounInflector = new natural.NounInflector(); // let singular = nounInflector.singularize('those tomatoes');\n// console.log(singular); //>>those tomato\n//Add context.skips, context.hintsGiven & guard states??\n\n\nvar clearRecResult = assign(function (context) {\n  return {\n    recResult: ''\n  };\n});\nvar clearTTSAgenda = assign(function (context) {\n  return {\n    ttsAgenda: ''\n  };\n});\nvar resetTally = assign(function (context) {\n  return {\n    tally: 0\n  };\n});\nvar clearLetter = assign(function (context) {\n  return {\n    letter: undefined\n  };\n});\nvar confettiOn = assign(function (context) {\n  return {\n    confettiSwitch: true\n  };\n});\nvar confettiOff = assign(function (context) {\n  return {\n    confettiSwitch: false\n  };\n});\nvar gameOn = assign(function (context) {\n  return {\n    playingNow: true\n  };\n});\nvar gameOff = assign(function (context) {\n  return {\n    playingNow: false\n  };\n}); //Initiate a questions object & assign values to context.letter/questions/tally\n\nvar newGameRound = assign(function (context) {\n  var qs = makeNewQuestions(quesJSON);\n  console.log(\"Last round:\".concat(context.lastLetter));\n  console.log(qs.ques);\n  return {\n    letter: qs.letter,\n    questions: qs.ques,\n    tally: 0,\n    skipped: 0,\n    hinted: 0,\n    confettiSwitch: false\n  };\n}); //After chosen a letter and before going saying it, remember it for referece of next game round\n\nvar rememberLetter = assign(function (context) {\n  return {\n    lastLetter: context.letter\n  };\n}); // const remember3Letters: Action<SDSContext, SDSEvent> = assign((context) => { \n//     let last3Letters= context.lastLetters? context.lastLetters : []\n//     last3Letters.push(context.letter)\n//     if(last3Letters.length>3){\n//         last3Letters.shift()\n//     }\n//     return { lastLetters: last3Letters} \n// })\n//Say the current random letter and a 'spelling/phonetic' alphabet\n\nfunction letterNow(context) {\n  var alphabet = {\n    'a': 'Adam',\n    'b': 'Bella',\n    'c': 'Cindy',\n    'd': 'Daniel',\n    'e': 'Eva',\n    'f': 'Francesca',\n    'g': 'Gabriel',\n    'h': 'Harry',\n    'i': 'Ida',\n    'j': 'Julia',\n    'k': 'Kevin',\n    'l': 'Laura',\n    'm': 'Michael',\n    'n': 'Nicole',\n    'o': 'Oscar',\n    'p': 'Paula',\n    'q': 'Quebec',\n    'r': 'Rachel',\n    's': 'Sara',\n    't': 'Tina',\n    'u': 'unique',\n    'v': 'Victoria',\n    'w': 'window',\n    'x': 'x-ray',\n    'y': 'yesman',\n    'z': 'zero'\n  };\n  var letter = context.letter;\n  return \"Your letter is \\\"\".concat(letter.toUpperCase(), \"\\\" for \\\"\").concat(alphabet[letter], \"\\\". \");\n}\n\nfunction questionNow(context) {\n  var category = context.questions[0].category; //the question at front of array\n\n  return \"Name \".concat(category, \". \");\n}\n\nfunction giveHint(context) {\n  var answers = context.questions[0].answers; //answers to the question at front of array\n\n  var anAns = randomChoice(answers);\n\n  if (anAns.length >= 3) {\n    var hint = anAns.slice(0, 3).toUpperCase(); //first 3 letters\n\n    return \"Spelled with \".concat(hint[0], \", \").concat(hint[1], \", \").concat(hint[2], \".\");\n  } //in case word is too short>>hint only 2 letters\n  else {\n      var _hint = anAns.slice(0, 2).toUpperCase(); //first 2 letters\n\n\n      return \"Spelled with \".concat(_hint[0], \", \").concat(_hint[1], \", \").concat(_hint[2], \".\");\n    }\n} //Partial match of user input, as long as input mentions an answer\n\n\nfunction answerMatches(input, context) {\n  var reply = input.toLowerCase(); //convert to lowercase\n\n  var replySing = nounInflector.singularize(reply); //convert to singular form\n\n  var answers = context.questions[0].answers; //answers to the question at front of array\n  //True if reply--either original or singularised--mentions an answer \n  //(eg, 'the Netherlands' matches 'netherlands'; 'these strawberries' matches 'strawberry')\n\n  return exists(reply, answers) || exists(replySing, answers);\n}\n\nfunction say(text) {\n  return send(function (_context) {\n    return {\n      type: \"SPEAK\",\n      value: text\n    };\n  });\n}\n\nfunction sharedRecognitions() {\n  return [{\n    target: 'stop',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'stop';\n    }\n  }, {\n    target: 'restart',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'restart';\n    }\n  }, //for testing \n  {\n    target: 'winning',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'shortcut';\n    }\n  }, {\n    target: \".nomatch\"\n  }];\n}\n\nfunction promptAndAsk(promptEvent) {\n  return {\n    initial: 'prompt',\n    states: {\n      prompt: {\n        entry: promptEvent,\n        on: {\n          ENDSPEECH: 'ask'\n        }\n      },\n      ask: {\n        entry: send('LISTEN')\n      },\n      nomatch: {\n        entry: [say(\"Try again\")],\n        on: {\n          ENDSPEECH: \"prompt\"\n        }\n      }\n    }\n  };\n} // Similar to python: any(keyword in input for keyword in keywords)\n\n\nfunction exists(input, keywords) {\n  var existence = keywords.some(function (keyword) {\n    return input.includes(keyword);\n  });\n  return existence;\n} //Replace this with grammar parser?\n\n\nfunction sayKeyword(reply) {\n  var yes = [\"yes\", \"of course\", \"sure\", \"absolutely\", \"yeah\", \"yep\", \"okay\", \"ok\"];\n  var no = [\"no\", \"nope\", \"no thanks\", \"nah\"];\n  var pass = [\"skip\", \"pass\", \"next\"];\n  var hint = [\"hint\", \"clue\", \"help\"];\n  var whatletter = ['letter', 'repeat'];\n  var stop = ['stop', 'end the game', 'shut down'];\n  var restart = ['restart', 'start again', 'reboot'];\n  var shortcut = ['short cut', 'shortcut']; //for testing\n\n  reply = reply.toLowerCase();\n\n  if (exists(reply, yes)) {\n    return 'yes';\n  }\n\n  if (exists(reply, no)) {\n    return 'no';\n  }\n\n  if (exists(reply, pass)) {\n    return 'pass';\n  }\n\n  if (exists(reply, hint)) {\n    return 'hint';\n  }\n\n  if (exists(reply, whatletter)) {\n    return 'whatletter';\n  }\n\n  if (exists(reply, stop)) {\n    return 'stop';\n  }\n\n  if (exists(reply, restart)) {\n    return 'restart';\n  }\n\n  if (exists(reply, shortcut)) {\n    return 'shortcut';\n  } //for testing\n\n}\n\nexport var dmMachine = {\n  initial: 'init',\n  states: {\n    init: {\n      on: {\n        CLICK: 'start'\n      }\n    },\n    stop: {\n      entry: say(\"Ok bye!\"),\n      on: {\n        ENDSPEECH: {\n          actions: [resetTally, clearLetter, clearTTSAgenda, clearRecResult, confettiOff, gameOff],\n          target: \"init\"\n        }\n      }\n    },\n    //Start/restart new game: initiate new questions-object & reset tally counter\n    start: {\n      entry: say(\"Starting the game \"),\n      on: {\n        ENDSPEECH: {\n          target: \"chooseNewLetter\"\n        }\n      }\n    },\n    restart: {\n      entry: say(\"Ok, starting over\"),\n      on: {\n        ENDSPEECH: {\n          target: \"chooseNewLetter\"\n        }\n      }\n    },\n    chooseNewLetter: {\n      always: [{\n        actions: [newGameRound, clearTTSAgenda, clearRecResult],\n        target: \"checkLastLetter\"\n      }]\n    },\n    //After choosing letter, comparing to last letter game so that the new letter is not repeated\n    checkLastLetter: {\n      always: [//if chosen letter is the same as last ones >> choose again\n      {\n        cond: function cond(context) {\n          return !!context.lastLetter && context.letter === context.lastLetter;\n        },\n        target: 'chooseNewLetter'\n      }, //chosen letter is different from last 3 letters >> remember it & resume game\n      {\n        actions: [rememberLetter, gameOn],\n        target: 'sayletter'\n      }]\n    },\n    //Starting the game for real from this state\n    //Say the letter\n    sayletter: {\n      entry: send(function (context) {\n        return {\n          type: \"SPEAK\",\n          value: letterNow(context)\n        };\n      }),\n      on: {\n        ENDSPEECH: 'askQues'\n      }\n    },\n    //Ask 5 (or more if skipping) questions \n    askQues: _objectSpread({\n      on: {\n        RECOGNISED: [// ? Clear recResult after recognition or not...?\n        // If answer matches answers, tally+=1, shift question[0]\n        {\n          cond: function cond(context) {\n            return answerMatches(context.recResult, context);\n          },\n          actions: assign(function (context) {\n            context.questions.shift();\n            return {\n              tally: context.tally + 1\n            };\n          }),\n          target: \"checkscore\"\n        }, //If pass, move the question to the last (unshift & push)\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'pass';\n          },\n          target: \"skip\"\n        }, //Hint 3 or 2 letters\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'hint';\n          },\n          target: \"hint\"\n        }, //Repeat letter\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'whatletter';\n          },\n          target: \"sayletter\"\n        }].concat(_toConsumableArray(sharedRecognitions()))\n      }\n    }, promptAndAsk(send(function (context) {\n      return {\n        type: \"SPEAK\",\n        value: questionNow(context)\n      };\n    }))),\n    skip: {\n      initial: 'checkSkipped',\n      states: {\n        checkSkipped: {\n          always: [{\n            target: 'letSkip',\n            cond: function cond(context) {\n              return context.skipped < 5;\n            }\n          }, {\n            target: 'maxSkipped',\n            cond: function cond(context) {\n              return context.skipped >= 5;\n            }\n          }]\n        },\n        //move the question to the last (unshift & push); context.skipped++\n        letSkip: {\n          entry: assign(function (context) {\n            var skipped = context.questions.shift();\n            context.questions.push(skipped);\n            console.log(\"Skipped so far: \".concat(context.skipped + 1, \" \"));\n            console.log(context.questions);\n            return {\n              skipped: context.skipped + 1\n            };\n          }),\n          always: '#root.dm.checkscore'\n        },\n        maxSkipped: {\n          entry: say(\"Oops, you've skipped for too many times!\"),\n          on: {\n            ENDSPEECH: {\n              target: '#root.dm.checkscore'\n            }\n          }\n        }\n      }\n    },\n    hint: {\n      initial: 'checkHinted',\n      states: {\n        checkHinted: {\n          always: [{\n            target: 'giveHint',\n            cond: function cond(context) {\n              return context.hinted < 5;\n            }\n          }, {\n            target: 'maxHinted',\n            cond: function cond(context) {\n              return context.hinted >= 5;\n            }\n          }]\n        },\n        //Hint 3 or 2 letters or a random answer; context.hinted++\n        giveHint: {\n          entry: [send(function (context) {\n            return {\n              type: \"SPEAK\",\n              value: giveHint(context)\n            };\n          }), assign(function (context) {\n            console.log(\"Hinted so far: \".concat(context.hinted + 1, \" \"));\n            return {\n              hinted: context.hinted + 1\n            };\n          })],\n          always: '#root.dm.checkscore' //\n\n        },\n        maxHinted: {\n          entry: say(\"Oops, you've asked for too many hints!\"),\n          on: {\n            ENDSPEECH: {\n              target: '#root.dm.checkscore'\n            }\n          }\n        }\n      }\n    },\n    checkscore: {\n      always: [//Less than 5 correct\n      {\n        target: 'askQues',\n        cond: function cond(context) {\n          return context.tally < 5;\n        }\n      }, //5 correct\n      {\n        target: 'winning',\n        cond: function cond(context) {\n          return context.tally >= 5;\n        }\n      }]\n    },\n    //? reset/clear tally here or not...? \n    winning: {\n      entry: [say(\"Winner winner chicken dinner\"), confettiOn, clearTTSAgenda],\n      on: {\n        ENDSPEECH: {\n          target: 'playagain'\n        }\n      }\n    },\n    playagain: _objectSpread({\n      entry: [clearRecResult, confettiOff, resetTally, clearLetter, gameOff],\n      on: {\n        RECOGNISED: [//Play again? restart:stop\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'yes';\n          },\n          target: \"restart\"\n        }, {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'no';\n          },\n          target: \"stop\"\n        }].concat(_toConsumableArray(sharedRecognitions()))\n      }\n    }, promptAndAsk(say('Want to play again?')))\n  }\n};","map":{"version":3,"sources":["C:/CodingProjects/ABCgame/src/dmGame.ts"],"names":["assign","send","makeNewQuestions","randomChoice","quesJSON","require","natural","nounInflector","NounInflector","clearRecResult","context","recResult","clearTTSAgenda","ttsAgenda","resetTally","tally","clearLetter","letter","undefined","confettiOn","confettiSwitch","confettiOff","gameOn","playingNow","gameOff","newGameRound","qs","console","log","lastLetter","ques","questions","skipped","hinted","rememberLetter","letterNow","alphabet","toUpperCase","questionNow","category","giveHint","answers","anAns","length","hint","slice","answerMatches","input","reply","toLowerCase","replySing","singularize","exists","say","text","_context","type","value","sharedRecognitions","target","cond","sayKeyword","promptAndAsk","promptEvent","initial","states","prompt","entry","on","ENDSPEECH","ask","nomatch","keywords","existence","some","keyword","includes","yes","no","pass","whatletter","stop","restart","shortcut","dmMachine","init","CLICK","actions","start","chooseNewLetter","always","checkLastLetter","sayletter","askQues","RECOGNISED","shift","skip","checkSkipped","letSkip","push","maxSkipped","checkHinted","maxHinted","checkscore","winning","playagain"],"mappings":"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","sourcesContent":["import { MachineConfig, actions, Action, assign, send } from \"xstate\";\r\n\r\n//Instantiate a new obj for each new round of game\r\nimport { makeNewQuestions, randomChoice } from './game_codes/game'\r\nconst quesJSON = require('./game_codes/questions.json') //Source of game questions; require() only works on server\r\n// let qs=makeNewQuestions(quesJSON)\r\n// console.log(qs.letter)\r\n// console.log(qs.ques)\r\n\r\n//Using \"Natural\" NLP library\r\nconst natural = require('natural'),\r\nnounInflector = new natural.NounInflector();\r\n// let singular = nounInflector.singularize('those tomatoes');\r\n// console.log(singular); //>>those tomato\r\n\r\n\r\n\r\n//Add context.skips, context.hintsGiven & guard states??\r\n\r\n\r\nconst clearRecResult: Action<SDSContext, SDSEvent> = assign((context) => { return { recResult:''} })\r\nconst clearTTSAgenda: Action<SDSContext, SDSEvent> = assign((context) => { return { ttsAgenda:''} })\r\nconst resetTally: Action<SDSContext, SDSEvent> = assign((context) => { return { tally:0} })\r\nconst clearLetter: Action<SDSContext, SDSEvent> = assign((context) => { return { letter:undefined} })\r\n\r\nconst confettiOn: Action<SDSContext, SDSEvent> = assign((context) => { return { confettiSwitch:true} })\r\nconst confettiOff: Action<SDSContext, SDSEvent> = assign((context) => { return { confettiSwitch:false} })\r\n\r\nconst gameOn: Action<SDSContext, SDSEvent> = assign((context) => { return { playingNow:true} })\r\nconst gameOff: Action<SDSContext, SDSEvent> = assign((context) => { return { playingNow:false} })\r\n\r\n//Initiate a questions object & assign values to context.letter/questions/tally\r\nconst newGameRound: Action<SDSContext, SDSEvent> = assign((context) => { \r\n    let qs=makeNewQuestions( quesJSON );\r\n    console.log(`Last round:${context.lastLetter}`)\r\n    console.log(qs.ques)\r\n    return { letter: qs.letter, questions: qs.ques, tally:0, skipped:0, hinted:0, confettiSwitch:false} \r\n})\r\n//After chosen a letter and before going saying it, remember it for referece of next game round\r\nconst rememberLetter: Action<SDSContext, SDSEvent> = assign((context) => { \r\n    return { lastLetter: context.letter} \r\n})\r\n// const remember3Letters: Action<SDSContext, SDSEvent> = assign((context) => { \r\n//     let last3Letters= context.lastLetters? context.lastLetters : []\r\n//     last3Letters.push(context.letter)\r\n//     if(last3Letters.length>3){\r\n//         last3Letters.shift()\r\n//     }\r\n//     return { lastLetters: last3Letters} \r\n// })\r\n\r\n\r\n//Say the current random letter and a 'spelling/phonetic' alphabet\r\nfunction letterNow(context:SDSContext){\r\n    let alphabet:any = {\r\n        'a':'Adam', 'b':'Bella', 'c':'Cindy', 'd':'Daniel', 'e':'Eva', 'f':'Francesca', 'g':'Gabriel', 'h':'Harry',\r\n        'i':'Ida', 'j':'Julia', 'k':'Kevin', 'l':'Laura', 'm':'Michael', 'n':'Nicole', 'o':'Oscar', 'p':'Paula',\r\n        'q':'Quebec', 'r':'Rachel', 's':'Sara', 't':'Tina', 'u':'unique', 'v':'Victoria', 'w':'window', 'x':'x-ray',\r\n        'y':'yesman', 'z':'zero'\r\n        }\r\n    let letter:string = context.letter\r\n    return `Your letter is \"${letter.toUpperCase()}\" for \"${alphabet[letter]}\". `\r\n}\r\n\r\nfunction questionNow(context:SDSContext){\r\n    let category = context.questions[0].category //the question at front of array\r\n    return `Name ${category}. `\r\n}\r\n\r\nfunction giveHint(context:SDSContext){\r\n    let answers = context.questions[0].answers //answers to the question at front of array\r\n    let anAns = randomChoice(answers)\r\n    if (anAns.length >= 3) {\r\n        let hint = anAns.slice(0, 3).toUpperCase() //first 3 letters\r\n        return `Spelled with ${hint[0]}, ${hint[1]}, ${hint[2]}.`\r\n    }\r\n    //in case word is too short>>hint only 2 letters\r\n    else {\r\n        let hint = anAns.slice(0, 2).toUpperCase() //first 2 letters\r\n        return `Spelled with ${hint[0]}, ${hint[1]}, ${hint[2]}.`\r\n    }\r\n}\r\n\r\n//Partial match of user input, as long as input mentions an answer\r\nfunction answerMatches(input:string,context:SDSContext){\r\n    let reply = input.toLowerCase() //convert to lowercase\r\n    let replySing = nounInflector.singularize( reply ) //convert to singular form\r\n\r\n    let answers = context.questions[0].answers //answers to the question at front of array\r\n\r\n    //True if reply--either original or singularised--mentions an answer \r\n    //(eg, 'the Netherlands' matches 'netherlands'; 'these strawberries' matches 'strawberry')\r\n    return  (exists(reply, answers) || exists(replySing, answers)) \r\n}\r\n\r\n\r\nfunction say(text: string): Action<SDSContext, SDSEvent> {\r\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\r\n}\r\n\r\nfunction sharedRecognitions() {\r\n    return [\r\n        { target: 'stop', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'stop' },\r\n        { target: 'restart', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'restart' },\r\n        //for testing \r\n        { target: 'winning', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'shortcut' },\r\n        { target: \".nomatch\" }\r\n        ]\r\n}\r\n\r\nfunction promptAndAsk(promptEvent: Action<SDSContext, SDSEvent>): MachineConfig<SDSContext, any, SDSEvent> {\r\n    return ({\r\n        initial: 'prompt',\r\n        states: {\r\n            prompt: {\r\n                entry: promptEvent,\r\n                on: { ENDSPEECH: 'ask' }\r\n            },\r\n            ask: {\r\n                entry: send('LISTEN'),\r\n            },\r\n            nomatch: { entry: [say(\"Try again\")],  \r\n                       on: { ENDSPEECH: \"prompt\" } \r\n            },\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// Similar to python: any(keyword in input for keyword in keywords)\r\nfunction exists(input:string, keywords:string[]){\r\n    let existence = keywords.some(keyword => input.includes(keyword))\r\n    return existence\r\n}\r\n//Replace this with grammar parser?\r\nfunction sayKeyword(reply: string){\r\n    let yes=[\"yes\", \"of course\", \"sure\", \"absolutely\", \"yeah\", \"yep\", \"okay\", \"ok\"]\r\n    let no=[\"no\", \"nope\", \"no thanks\", \"nah\",]\r\n    let pass=[\"skip\", \"pass\", \"next\",]\r\n    let hint=[\"hint\", \"clue\", \"help\"]\r\n    let whatletter=['letter','repeat']\r\n    let stop=['stop','end the game','shut down']\r\n    let restart=['restart','start again', 'reboot']\r\n    let shortcut=['short cut', 'shortcut'] //for testing\r\n\r\n    reply=reply.toLowerCase()\r\n    if(exists(reply, yes)){ return 'yes' }\r\n    if(exists(reply, no)){ return 'no' }\r\n    if(exists(reply, pass)){ return 'pass' }\r\n    if(exists(reply, hint)){ return 'hint' }\r\n    if(exists(reply, whatletter)){ return 'whatletter' }\r\n    if(exists(reply, stop)){ return 'stop' }\r\n    if(exists(reply, restart)){ return 'restart' }\r\n    if(exists(reply, shortcut)){ return 'shortcut' } //for testing\r\n}\r\n\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'init',\r\n    states: {\r\n        init: {\r\n            on: {\r\n                CLICK: 'start'\r\n            }\r\n        },\r\n        stop: {\r\n            entry: say(\"Ok bye!\"),\r\n            on: { ENDSPEECH: {\r\n                actions: [resetTally,clearLetter,clearTTSAgenda,clearRecResult,confettiOff, gameOff],\r\n                target:\"init\",\r\n                } \r\n            }\r\n        },\r\n        //Start/restart new game: initiate new questions-object & reset tally counter\r\n        start: {\r\n            entry: say(\"Starting the game \"),\r\n            on: { ENDSPEECH: { target:\"chooseNewLetter\" } } \r\n        },\r\n        restart: {\r\n            entry: say(\"Ok, starting over\"),\r\n            on: { ENDSPEECH: {target:\"chooseNewLetter\" } } \r\n        },\r\n        chooseNewLetter :{\r\n            always:[\r\n                {actions: [newGameRound, clearTTSAgenda, clearRecResult],\r\n                 target: \"checkLastLetter\" }\r\n            ]\r\n        },\r\n\r\n        //After choosing letter, comparing to last letter game so that the new letter is not repeated\r\n        checkLastLetter: {\r\n            always: [\r\n                //if chosen letter is the same as last ones >> choose again\r\n                { cond: (context) => !!context.lastLetter && context.letter===context.lastLetter, \r\n                    target: 'chooseNewLetter', },\r\n\r\n                //chosen letter is different from last 3 letters >> remember it & resume game\r\n                { \r\n                  actions: [rememberLetter, gameOn, ],\r\n                  target: 'sayletter',  },\r\n            ]\r\n        },\r\n\r\n        //Starting the game for real from this state\r\n        //Say the letter\r\n        sayletter:{\r\n            entry: send((context)=>({ type: \"SPEAK\", value: letterNow(context) })),\r\n            on: {ENDSPEECH:'askQues' }\r\n        },\r\n\r\n        //Ask 5 (or more if skipping) questions \r\n        askQues: {\r\n            on: {\r\n                RECOGNISED: [\r\n                    \r\n                    // ? Clear recResult after recognition or not...?\r\n                    // If answer matches answers, tally+=1, shift question[0]\r\n                    {cond: (context:SDSContext) => answerMatches(context.recResult, context),\r\n                     actions: assign((context:SDSContext) => { \r\n                        context.questions.shift()\r\n                        return { tally: context.tally+1 } }),\r\n                     target:\"checkscore\"  },\r\n                    \r\n                    //If pass, move the question to the last (unshift & push)\r\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='pass', target:\"skip\"  },\r\n\r\n                    //Hint 3 or 2 letters\r\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='hint', target:\"hint\"},\r\n\r\n                    //Repeat letter\r\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='whatletter', target:\"sayletter\"},\r\n\r\n                    //Else    \r\n                    ...sharedRecognitions(),\r\n                    \r\n                ]},\r\n                ...promptAndAsk( send((context)=>({ type: \"SPEAK\", \r\n                                                    value: questionNow(context) })) )\r\n        },\r\n\r\n        skip: {\r\n            initial: 'checkSkipped',\r\n            states:{\r\n                checkSkipped:{\r\n                    always:[\r\n                        { target: 'letSkip', cond: (context) => context.skipped<5 },\r\n                        { target: 'maxSkipped', cond: (context) => context.skipped>=5 },\r\n                    ]\r\n                },\r\n                //move the question to the last (unshift & push); context.skipped++\r\n                letSkip:{\r\n                    entry:  assign((context:SDSContext) => { \r\n                        let skipped=context.questions.shift();\r\n                        context.questions.push(skipped);\r\n                        console.log(`Skipped so far: ${context.skipped+1} `)\r\n                        console.log(context.questions)\r\n                        return { skipped:context.skipped+1} }),\r\n                    always: '#root.dm.checkscore'\r\n                },\r\n                maxSkipped:{\r\n                    entry: say(`Oops, you've skipped for too many times!`),\r\n                    on:{ ENDSPEECH: {target:'#root.dm.checkscore'}}\r\n                }\r\n            }\r\n        },\r\n\r\n        hint: {\r\n            initial: 'checkHinted',\r\n            states:{\r\n                checkHinted:{\r\n                    always:[\r\n                        { target: 'giveHint', cond: (context) => context.hinted<5 },\r\n                        { target: 'maxHinted', cond: (context) => context.hinted>=5 },\r\n                    ]\r\n                },\r\n                //Hint 3 or 2 letters or a random answer; context.hinted++\r\n                giveHint:{\r\n                    entry: [\r\n                        send((context)=>({ type: \"SPEAK\", value: giveHint(context) })),\r\n                        assign((context:SDSContext) => {\r\n                            console.log(`Hinted so far: ${context.hinted+1} `);\r\n                            return { hinted:context.hinted+1} })\r\n                    ],\r\n                    always: '#root.dm.checkscore' //\r\n                },\r\n                maxHinted:{\r\n                    entry: say(`Oops, you've asked for too many hints!`),\r\n                    on:{ ENDSPEECH: {target:'#root.dm.checkscore'}}\r\n                }\r\n            }\r\n        },\r\n        \r\n        checkscore:{\r\n            always: [\r\n                //Less than 5 correct\r\n                { target: 'askQues', cond: (context) => context.tally<5 },\r\n\r\n                //5 correct\r\n                { target: 'winning', cond: (context) => context.tally>=5 },\r\n            ]\r\n        },\r\n\r\n                    //? reset/clear tally here or not...? \r\n        winning: {\r\n            entry: [ say(\"Winner winner chicken dinner\"), confettiOn, clearTTSAgenda ], \r\n            on: {ENDSPEECH:{target:'playagain'}}\r\n        },\r\n        playagain: {\r\n            entry: [ clearRecResult, confettiOff, resetTally, clearLetter, gameOff,],\r\n            on: {\r\n                RECOGNISED: [\r\n                     //Play again? restart:stop\r\n                     {cond: (context:SDSContext) => sayKeyword(context.recResult)==='yes', target:\"restart\"},\r\n                     {cond: (context:SDSContext) => sayKeyword(context.recResult)==='no', target:\"stop\"},\r\n\r\n                    //Else    \r\n                    ...sharedRecognitions() \r\n                ]},\r\n                ...promptAndAsk( say('Want to play again?') )\r\n        }, \r\n        \r\n    },\r\n\r\n})"]},"metadata":{},"sourceType":"module"}