{"ast":null,"code":"/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n'use strict';\n\nvar TransformationRule = require('./TransformationRule');\n\nvar RuleSet = require('./RuleSet');\n\nvar Sentence = require('./Sentence'); // Training continues as long as there are rules with a positive score\n// that have not been selected before\n\n\nvar minScore = 0; // After training rules with a score below scoreThreshold are pruned\n\nfunction BrillPOSTrainer(ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold;\n  } else {\n    this.ruleScoreThreshold = 1;\n  }\n} // Return the highest scoring rule from the rule set\n\n\nBrillPOSTrainer.prototype.selectHighRule = function () {\n  var highestRule = null; // Walk through the map and find the rule with highest score\n\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    } else {\n      if (rule.score() > highestRule.score() && !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule;\n      }\n    }\n  });\n\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true;\n  } // Return the rule with the highest score\n\n\n  return highestRule;\n};\n\nBrillPOSTrainer.prototype.mapRuleToSite = function (rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {};\n  }\n\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {};\n  }\n\n  this.mapRuleToSites[rule.key()][i][j] = true;\n};\n\nBrillPOSTrainer.prototype.mapSiteToRule = function (i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {};\n  }\n\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {};\n  }\n\n  this.mapSiteToRules[i][j][rule.key()] = rule;\n};\n\nBrillPOSTrainer.prototype.associateSiteWithRule = function (i, j, rule) {\n  this.mapRuleToSite(rule, i, j);\n  this.mapSiteToRule(i, j, rule);\n};\n\nBrillPOSTrainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Returns an array of all sites associated with rule\n\n\nBrillPOSTrainer.prototype.getSites = function (rule) {\n  var that = this;\n  var result = [];\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j]);\n    });\n  }); // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n\n  return result;\n}; // Returns an array of all rules associated with the site\n\n\nBrillPOSTrainer.prototype.getRules = function (i, j) {\n  var result = [];\n  var that = this;\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n        return that.mapSiteToRules[i][j][key];\n      });\n    }\n  }\n\n  return result;\n};\n\nBrillPOSTrainer.prototype.disconnectSiteFromRule = function (i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j];\n      }\n    }\n  } // mapSiteToRules\n\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()];\n      }\n    }\n  }\n}; // Adjusts the score of the rule at position i, j of the corpus\n\n\nBrillPOSTrainer.prototype.scoreRule = function (rule, i, j) {\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n  var token = this.corpus.sentences[i].taggedWords[j];\n  var rightTag = token.tag;\n  var oldTag = token.testTag;\n  var newTag = token.newTag;\n\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++; // If the score changes, it may be selected again as highest scoring rule\n\n      rule.hasBeenSelectedAsHighRuleBefore = false; // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    } else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++; // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  } else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++; // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    } else {\n      // New tag is false\n      rule.negative++; // If the score changes, it may be selected again as highest scoring rule\n\n      rule.hasBeenSelectedAsHighRuleBefore = false; // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  } // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n\n}; // Generate positive rules for this given site using templates\n\n\nBrillPOSTrainer.prototype.generatePositiveRules = function (i, j) {\n  var sentence = this.corpus.sentences[i];\n  var token = sentence.taggedWords[j]; // A positive rule should trigger on the currently assigned testTag\n\n  var oldTag = token.testTag; // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n\n  var newTag = token.tag; // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  var newRules = new RuleSet(); // Exit if testTag already is the right tag --> will not result in positive rules\n\n  if (oldTag === newTag) {\n    return newRules;\n  }\n\n  this.templates.forEach(function (template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value));\n        });\n      } else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2));\n            });\n          });\n        } else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName));\n        }\n      }\n    }\n  });\n  return newRules;\n}; // Finds all rules that are applicable at some site\n\n\nBrillPOSTrainer.prototype.scanForPositiveRules = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n  var that = this;\n  this.corpus.sentences.forEach(function (sentence, i) {\n    sentence.taggedWords.forEach(function (token, j) {\n      // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n      var newRules = that.generatePositiveRules(i, j);\n      newRules.getRules().forEach(function (rule) {\n        that.positiveRules.addRule(rule); // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      });\n    });\n  }); // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n}; // Find all sites where the rules can be applied, register these sites and\n// update the scores\n\n\nBrillPOSTrainer.prototype.scanForSites = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n  var that = this; // Scan the corpus\n\n  this.corpus.sentences.forEach(function (sentence, i) {\n    if (i % 100 === 0) {// logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n    }\n\n    var taggedSentence = new Sentence();\n    sentence.taggedWords.forEach(function (wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag);\n    });\n    sentence.taggedWords.forEach(function (token, j) {\n      that.positiveRules.getRules().forEach(function (rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule);\n          that.scoreRule(rule, i, j); // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      });\n    });\n  }); // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n}; // Returns a list of sites that may have been touched by a changing tag\n\n\nBrillPOSTrainer.prototype.neighbourhood = function (i, j) {\n  var sentenceLength = this.corpus.sentences[i].length;\n  var list = [];\n\n  if (this.index > 2) {\n    list.push([i, j - 3]);\n  }\n\n  if (this.index > 1) {\n    list.push([i, j - 2]);\n  }\n\n  if (this.index > 0) {\n    list.push([i, j - 1]);\n  }\n\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1]);\n  }\n\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2]);\n  }\n\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3]);\n  }\n\n  return list;\n}; // corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\n\n\nBrillPOSTrainer.prototype.train = function (corpus, templates, lexicon) {\n  var _this = this;\n\n  this.corpus = corpus;\n  this.templates = templates;\n  this.positiveRules = new RuleSet();\n  this.mapRuleToSites = {};\n  this.mapSiteToRules = {}; // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n\n  this.corpus.tag(lexicon);\n  this.scanForPositiveRules(); // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n\n  this.scanForSites();\n  var highRule = this.selectHighRule();\n  var iterationNumber = 0;\n  var that = this;\n\n  var _loop = function _loop() {\n    if (iterationNumber % 5 === 0) {// logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n    } // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n    // Apply the high rule to each change site on its site list\n\n\n    _this.getSites(highRule).forEach(function (site) {\n      // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n      // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1]);\n    });\n\n    var unseenRules = new RuleSet();\n\n    _this.getSites(highRule).forEach(function (site) {\n      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n        // Generate positive rules for testSite\n        var newRules = that.generatePositiveRules(testSite[0], testSite[1]); // Disconnect test site from its rules\n        // because highrule has been applied\n\n        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule);\n          }\n        }); // Connect new rules not already connected to the test site\n\n        newRules.getRules().forEach(function (rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule);\n            } else {\n              unseenRules.addRule(rule);\n            }\n          }\n        }); // Process unseen rules\n\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function (rule) {\n            that.positiveRules.addRule(rule);\n          });\n          that.corpus.sentences.forEach(function (sentence, i) {\n            var taggedSentence = sentence.map(function (token) {\n              return [token.token, token.testTag];\n            });\n            sentence.forEach(function (token, j) {\n              unseenRules.getRules().forEach(function (rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule);\n                  that.scoreRule(rule, i, j);\n                }\n              });\n            });\n          });\n        }\n      });\n    }); // Select next highest scoring rule\n\n\n    highRule = _this.selectHighRule();\n    iterationNumber++;\n  };\n\n  while (highRule !== null && highRule.score() > minScore) {\n    _loop();\n  } // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n  // Remove rules having a non-positive score\n\n\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule);\n    }\n  }); // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n\n  return this.positiveRules;\n};\n\nBrillPOSTrainer.prototype.printRulesWithScores = function () {\n  var result = '';\n\n  function compareRules(a, b) {\n    if (a.score() > b.score()) {\n      return -1;\n    } else {\n      if (a.score() < b.score()) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  var rules = this.positiveRules.getRules();\n  var sortedRules = rules.sort(compareRules);\n  sortedRules.forEach(function (rule) {\n    // if (rule.score() > 0) {\n    result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n'; // }\n  });\n  return result;\n};\n\nmodule.exports = BrillPOSTrainer;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js"],"names":["TransformationRule","require","RuleSet","Sentence","minScore","BrillPOSTrainer","ruleScoreThreshold","prototype","selectHighRule","highestRule","positiveRules","getRules","forEach","rule","hasBeenSelectedAsHighRuleBefore","score","mapRuleToSite","i","j","mapRuleToSites","key","mapSiteToRule","mapSiteToRules","associateSiteWithRule","siteIsAssociatedWithRule","getSites","that","result","Object","keys","push","map","disconnectSiteFromRule","scoreRule","token","corpus","sentences","taggedWords","rightTag","tag","oldTag","testTag","newTag","positive","neutral","negative","generatePositiveRules","sentence","newRules","templates","template","windowFitsSite","meta","nrParameters","parameter1Values","value","addRule","predicateName","value1","parameter2Values","value2","scanForPositiveRules","scanForSites","taggedSentence","wordObject","addTaggedWord","isApplicableAt","neighbourhood","sentenceLength","length","list","index","train","lexicon","highRule","iterationNumber","site","applyAt","unseenRules","testSite","hasRule","nrRules","removeRule","printRulesWithScores","compareRules","a","b","rules","sortedRules","sort","prettyPrint","module","exports"],"mappings":"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","sourcesContent":["/*\n  Brill POS Trainer class\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Algorithm is based on:\n// Exploring the Statistical Derivation of Transformational Rule Sequences\n// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus\n// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf\n\n'use strict'\n\nconst TransformationRule = require('./TransformationRule')\nconst RuleSet = require('./RuleSet')\nconst Sentence = require('./Sentence')\n\n// Training continues as long as there are rules with a positive score\n// that have not been selected before\nconst minScore = 0\n\n// After training rules with a score below scoreThreshold are pruned\nfunction BrillPOSTrainer (ruleScoreThreshold) {\n  if (ruleScoreThreshold) {\n    this.ruleScoreThreshold = ruleScoreThreshold\n  } else {\n    this.ruleScoreThreshold = 1\n  }\n}\n\n// Return the highest scoring rule from the rule set\nBrillPOSTrainer.prototype.selectHighRule = function () {\n  let highestRule = null\n\n  // Walk through the map and find the rule with highest score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (highestRule === null) {\n      if (!rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule\n      }\n    } else {\n      if ((rule.score() > highestRule.score()) &&\n        !rule.hasBeenSelectedAsHighRuleBefore) {\n        highestRule = rule\n      }\n    }\n  })\n\n  if (highestRule !== null) {\n    highestRule.hasBeenSelectedAsHighRuleBefore = true\n  }\n  // Return the rule with the highest score\n  return highestRule\n}\n\nBrillPOSTrainer.prototype.mapRuleToSite = function (rule, i, j) {\n  if (!this.mapRuleToSites[rule.key()]) {\n    this.mapRuleToSites[rule.key()] = {}\n  }\n  if (!this.mapRuleToSites[rule.key()][i]) {\n    this.mapRuleToSites[rule.key()][i] = {}\n  }\n  this.mapRuleToSites[rule.key()][i][j] = true\n}\n\nBrillPOSTrainer.prototype.mapSiteToRule = function (i, j, rule) {\n  if (!this.mapSiteToRules[i]) {\n    this.mapSiteToRules[i] = {}\n  }\n  if (!this.mapSiteToRules[i][j]) {\n    this.mapSiteToRules[i][j] = {}\n  }\n  this.mapSiteToRules[i][j][rule.key()] = rule\n}\n\nBrillPOSTrainer.prototype.associateSiteWithRule = function (i, j, rule) {\n  this.mapRuleToSite(rule, i, j)\n  this.mapSiteToRule(i, j, rule)\n}\n\nBrillPOSTrainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// Returns an array of all sites associated with rule\nBrillPOSTrainer.prototype.getSites = function (rule) {\n  const that = this\n  const result = []\n  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {\n    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {\n      // Unary plus the convert hash keys i and j to integer\n      result.push([+i, +j])\n    })\n  })\n  // logger.debug(\"BrillPOSTrainer.prototype.getSites: sites \" + JSON.stringify(result));\n  return (result)\n}\n\n// Returns an array of all rules associated with the site\nBrillPOSTrainer.prototype.getRules = function (i, j) {\n  let result = []\n  const that = this\n\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {\n        return that.mapSiteToRules[i][j][key]\n      })\n    }\n  }\n  return result\n}\n\nBrillPOSTrainer.prototype.disconnectSiteFromRule = function (i, j, rule) {\n  // mapRuleToSites\n  if (this.mapRuleToSites[rule.key()]) {\n    if (this.mapRuleToSites[rule.key()][i]) {\n      if (this.mapRuleToSites[rule.key()][i][j]) {\n        delete this.mapRuleToSites[rule.key()][i][j]\n      }\n    }\n  }\n\n  // mapSiteToRules\n  if (this.mapSiteToRules[i]) {\n    if (this.mapSiteToRules[i][j]) {\n      if (this.mapSiteToRules[i][j][rule.key()]) {\n        delete this.mapSiteToRules[i][j][rule.key()]\n      }\n    }\n  }\n}\n\n// Adjusts the score of the rule at position i, j of the corpus\nBrillPOSTrainer.prototype.scoreRule = function (rule, i, j) {\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: entry\");\n  const token = this.corpus.sentences[i].taggedWords[j]\n  const rightTag = token.tag\n  const oldTag = token.testTag\n  const newTag = token.newTag\n  if (rightTag !== oldTag) {\n    // Old tag is wrong\n    if (newTag === rightTag) {\n      // New tag is right\n      rule.positive++\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: positive: \" + rule.key() + \"\\t score: \" + rule.positive);\n    } else {\n      // New tag is wrong as well --> neutral\n      rule.neutral++\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    }\n  } else {\n    // Old tag is right\n    if (newTag === rightTag) {\n      // New tag is right --> neutral\n      rule.neutral++\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: neutral: \" + rule.key() + \"\\t score: \" + rule.neutral);\n    } else {\n      // New tag is false\n      rule.negative++\n      // If the score changes, it may be selected again as highest scoring rule\n      rule.hasBeenSelectedAsHighRuleBefore = false\n      // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: negative: \" + rule.key() + \"\\t score: \" + rule.negative);\n    }\n  }\n  // logger.debug(\"BrillPOSTrainer.prototype.scoreRule: exit\");\n}\n\n// Generate positive rules for this given site using templates\nBrillPOSTrainer.prototype.generatePositiveRules = function (i, j) {\n  const sentence = this.corpus.sentences[i]\n  const token = sentence.taggedWords[j]\n  // A positive rule should trigger on the currently assigned testTag\n  const oldTag = token.testTag\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: oldTag \" + oldTag);\n  // It should assign the right tag as given by the corpus\n  const newTag = token.tag\n  // logger.debug(\"BrillPOSTrainer.prototype.generatePositiveRules: newTag \" + newTag);\n\n  const newRules = new RuleSet()\n  // Exit if testTag already is the right tag --> will not result in positive rules\n  if (oldTag === newTag) {\n    return newRules\n  }\n\n  this.templates.forEach(function (template) {\n    if (template.windowFitsSite(sentence, j)) {\n      if (template.meta.nrParameters === 1) {\n        template.meta.parameter1Values(sentence, j).forEach(function (value) {\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value))\n        })\n      } else {\n        if (template.meta.nrParameters === 2) {\n          template.meta.parameter1Values(sentence, j).forEach(function (value1) {\n            template.meta.parameter2Values(sentence, j).forEach(function (value2) {\n              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2))\n            })\n          })\n        } else {\n          // 0 paramaters\n          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName))\n        }\n      }\n    }\n  })\n  return newRules\n}\n\n// Finds all rules that are applicable at some site\nBrillPOSTrainer.prototype.scanForPositiveRules = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: entry\");\n  const that = this\n  this.corpus.sentences.forEach(function (sentence, i) {\n    sentence.taggedWords.forEach(function (token, j) {\n      // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: sentence no \" + i);\n      const newRules = that.generatePositiveRules(i, j)\n      newRules.getRules().forEach(function (rule) {\n        that.positiveRules.addRule(rule)\n        // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: nrRules \" + that.positiveRules.nrRules());\n      })\n    })\n  })\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: \" + this.positiveRules.nrRules());\n}\n\n// Find all sites where the rules can be applied, register these sites and\n// update the scores\nBrillPOSTrainer.prototype.scanForSites = function () {\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: entry\");\n  const that = this\n\n  // Scan the corpus\n  this.corpus.sentences.forEach(function (sentence, i) {\n    if (i % 100 === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.scanForSites: sentence \" + i);\n    }\n\n    const taggedSentence = new Sentence()\n    sentence.taggedWords.forEach(function (wordObject) {\n      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag)\n    })\n\n    sentence.taggedWords.forEach(function (token, j) {\n      that.positiveRules.getRules().forEach(function (rule) {\n        if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n          that.associateSiteWithRule(i, j, rule)\n          that.scoreRule(rule, i, j)\n          // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (\" + i + \", \" + j + \", \" + rule.prettyPrint() + \")\");\n        }\n      })\n    })\n  })\n\n  // logger.debug(\"BrillPOSTrainer.prototype.scanForSites: exit\");\n}\n\n// Returns a list of sites that may have been touched by a changing tag\nBrillPOSTrainer.prototype.neighbourhood = function (i, j) {\n  const sentenceLength = this.corpus.sentences[i].length\n  const list = []\n\n  if (this.index > 2) {\n    list.push([i, j - 3])\n  }\n  if (this.index > 1) {\n    list.push([i, j - 2])\n  }\n  if (this.index > 0) {\n    list.push([i, j - 1])\n  }\n  if (this.index < sentenceLength - 1) {\n    list.push([i, j + 1])\n  }\n  if (this.index < sentenceLength - 2) {\n    list.push([i, j + 2])\n  }\n  if (this.index > sentenceLength - 3) {\n    list.push([i, j + 3])\n  }\n  return list\n}\n\n// corpus: an array of token arrays\n// templates: an array of rule templates\n// lexicon: lexicon that provides method tagWord(word)\nBrillPOSTrainer.prototype.train = function (corpus, templates, lexicon) {\n  this.corpus = corpus\n  this.templates = templates\n  this.positiveRules = new RuleSet()\n  this.mapRuleToSites = {}\n  this.mapSiteToRules = {}\n\n  // logger.debug(\"BrillPOSTrainer.prototype.train: entry\");\n  this.corpus.tag(lexicon)\n  this.scanForPositiveRules()\n  // logger.info(\"BrillPOSTrainer.prototype.train: initial number of rules: \" + this.positiveRules.nrRules());\n  this.scanForSites()\n\n  let highRule = this.selectHighRule()\n  let iterationNumber = 0\n  const that = this\n  while ((highRule !== null) && (highRule.score() > minScore)) {\n    if ((iterationNumber % 5) === 0) {\n      // logger.info(\"BrillPOSTrainer.prototype.train: training iteration: \" + iterationNumber);\n    }\n    // logger.debug(\"BrillPOSTrainer.prototype.train: highRule selected: \" + highRule.key());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n    // logger.debug(\"BrillPOSTrainer.prototype.train: score of highRule: \" + highRule.score());\n\n    // Apply the high rule to each change site on its site list\n    this.getSites(highRule).forEach(function (site) {\n      // logger.debug(\"BrillPOSTrainer.prototype.train: apply highRule to: \" + site);\n      // logger.debug(\"BrillPOSTrainer.prototype.train: sentence length: \" + that.corpus.sentences[site[0]].length);\n      highRule.applyAt(that.corpus.sentences[site[0]], site[1])\n    })\n\n    const unseenRules = new RuleSet()\n    this.getSites(highRule).forEach(function (site) {\n      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {\n        // Generate positive rules for testSite\n        const newRules = that.generatePositiveRules(testSite[0], testSite[1])\n\n        // Disconnect test site from its rules\n        // because highrule has been applied\n        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {\n          if (!newRules.hasRule(rule)) {\n            that.disconnectSiteFromRule(testSite[0], testSite[1], rule)\n          }\n        })\n\n        // Connect new rules not already connected to the test site\n        newRules.getRules().forEach(function (rule) {\n          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {\n            if (that.positiveRules.hasRule(rule)) {\n              that.associateSiteWithRule(testSite[0], testSite[1], rule)\n            } else {\n              unseenRules.addRule(rule)\n            }\n          }\n        })\n\n        // Process unseen rules\n        if (unseenRules.nrRules() > 0) {\n          unseenRules.getRules().forEach(function (rule) {\n            that.positiveRules.addRule(rule)\n          })\n          that.corpus.sentences.forEach(function (sentence, i) {\n            const taggedSentence = sentence.map(function (token) {\n              return [token.token, token.testTag]\n            })\n            sentence.forEach(function (token, j) {\n              unseenRules.getRules().forEach(function (rule) {\n                if (rule.isApplicableAt(sentence, taggedSentence, j)) {\n                  that.associateSiteWithRule(i, j, rule)\n                  that.scoreRule(rule, i, j)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n\n    // Select next highest scoring rule\n    highRule = this.selectHighRule()\n    iterationNumber++\n  }\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of iterations: \" + iterationNumber);\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules: \" + this.positiveRules.nrRules());\n\n  // Remove rules having a non-positive score\n  this.positiveRules.getRules().forEach(function (rule) {\n    if (rule.score() < that.ruleScoreThreshold) {\n      that.positiveRules.removeRule(rule)\n    }\n  })\n\n  // logger.info(\"BrillPOSTrainer.prototype.train: number of rules after pruning: \" + this.positiveRules.nrRules());\n  // logger.debug(\"BrillPOSTrainer.prototype.train: exit\");\n  return this.positiveRules\n}\n\nBrillPOSTrainer.prototype.printRulesWithScores = function () {\n  let result = ''\n\n  function compareRules (a, b) {\n    if (a.score() > b.score()) {\n      return -1\n    } else {\n      if (a.score() < b.score()) {\n        return 1\n      } else {\n        return 0\n      }\n    }\n  }\n\n  const rules = this.positiveRules.getRules()\n  const sortedRules = rules.sort(compareRules)\n\n  sortedRules.forEach(function (rule) {\n    // if (rule.score() > 0) {\n    result += rule.score() + '\\t' + rule.positive + '\\t' + rule.negative + '\\t' + rule.neutral + '\\t' + rule.prettyPrint() + '\\n'\n    // }\n  })\n  return result\n}\n\nmodule.exports = BrillPOSTrainer\n"]},"metadata":{},"sourceType":"script"}