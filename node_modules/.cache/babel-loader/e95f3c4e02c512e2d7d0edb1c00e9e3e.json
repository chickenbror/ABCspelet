{"ast":null,"code":"/* jscpd:ignore-start */\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n'use strict';\n\nfunction peg$subclass(child, parent) {\n  function ctor() {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = 'SyntaxError';\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function (expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function literal(expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n    class: function _class(expectation) {\n      var escapedParts = '';\n      var i;\n\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n      }\n\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';\n    },\n    any: function any(expectation) {\n      return 'any character';\n    },\n    end: function end(expectation) {\n      return 'end of input';\n    },\n    other: function other(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n      return '\\\\x0' + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return '\\\\x' + hex(ch);\n    });\n  }\n\n  function classEscape(s) {\n    return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n      return '\\\\x0' + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return '\\\\x' + hex(ch);\n    });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length);\n    var i;\n    var j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input';\n  }\n\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n  var peg$FAILED = {};\n  var peg$startRuleFunctions = {\n    transformation_rule: peg$parsetransformation_rule\n  };\n  var peg$startRuleFunction = peg$parsetransformation_rule;\n\n  var peg$c0 = function peg$c0(c1, c2, pred, pars) {\n    var result = null; // Construct rule\n\n    if (pars.length === 1) {\n      result = new TransformationRule(c1, c2, pred, pars[0]);\n    } else {\n      if (pars.length === 2) {\n        result = new TransformationRule(c1, c2, pred, pars[0], pars[1]);\n      } else {\n        result = new TransformationRule(c1, c2, pred);\n      }\n    }\n\n    return result;\n  };\n\n  var peg$c1 = /^[!-~\\xA1-\\xFF]/;\n  var peg$c2 = peg$classExpectation([['!', '~'], ['\\xA1', '\\xFF']], false, false);\n\n  var peg$c3 = function peg$c3(characters) {\n    var s = '';\n\n    for (var i = 0; i < characters.length; i++) {\n      s += characters[i];\n    }\n\n    return s;\n  };\n\n  var peg$c4 = '*';\n  var peg$c5 = peg$literalExpectation('*', false);\n\n  var peg$c6 = function peg$c6(wc) {\n    return wc;\n  };\n\n  var peg$c7 = '\\r\\n';\n  var peg$c8 = peg$literalExpectation('\\r\\n', false);\n  var peg$c9 = '\\n';\n  var peg$c10 = peg$literalExpectation('\\n', false);\n  var peg$c11 = '\\r';\n  var peg$c12 = peg$literalExpectation('\\r', false);\n  var peg$c13 = '//';\n  var peg$c14 = peg$literalExpectation('//', false);\n  var peg$c15 = peg$anyExpectation();\n  var peg$c16 = ' ';\n  var peg$c17 = peg$literalExpectation(' ', false);\n  var peg$c18 = '\\t';\n  var peg$c19 = peg$literalExpectation('\\t', false);\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{\n    line: 1,\n    column: 1\n  }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n  var peg$result;\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".');\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return {\n      type: 'literal',\n      text: text,\n      ignoreCase: ignoreCase\n    };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return {\n      type: 'class',\n      parts: parts,\n      inverted: inverted,\n      ignoreCase: ignoreCase\n    };\n  }\n\n  function peg$anyExpectation() {\n    return {\n      type: 'any'\n    };\n  }\n\n  function peg$endExpectation() {\n    return {\n      type: 'end'\n    };\n  }\n\n  function peg$otherExpectation(description) {\n    return {\n      type: 'other',\n      description: description\n    };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) {\n      return;\n    }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n  }\n\n  function peg$parsetransformation_rule() {\n    var s0, s1, s2, s3, s4, s5;\n    s0 = peg$currPos;\n    s1 = peg$parsecategory1();\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier();\n\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier();\n\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseidentifier();\n\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseidentifier();\n          }\n\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecategory1() {\n    var s0;\n    s0 = peg$parsewild_card();\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseidentifier();\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2;\n    s0 = peg$currPos;\n    s1 = [];\n\n    if (peg$c1.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c2);\n      }\n    }\n\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n\n        if (peg$c1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c2);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol();\n\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c3(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewild_card() {\n    var s0, s1, s2;\n    s0 = peg$currPos;\n\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c5);\n      }\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol();\n\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOL() {\n    var s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c7) {\n      s0 = peg$c7;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c8);\n      }\n    }\n\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c9;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c10);\n        }\n      }\n\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c11;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c12);\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0, s1, s2, s3, s4, s5;\n    s0 = peg$currPos;\n\n    if (input.substr(peg$currPos, 2) === peg$c13) {\n      s1 = peg$c13;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c14);\n      }\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseEOL();\n      peg$silentFails--;\n\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c15);\n          }\n        }\n\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseEOL();\n        peg$silentFails--;\n\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c15);\n            }\n          }\n\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseEOL();\n\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseEOI();\n        }\n\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseS() {\n    var s0, s1;\n    s0 = [];\n\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c19);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseEOL();\n\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c17);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c19);\n          }\n        }\n\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOL();\n\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseComment();\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseS_no_eol() {\n    var s0, s1;\n    s0 = [];\n\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c19);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c17);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c19);\n          }\n        }\n\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOI() {\n    var s0, s1;\n    s0 = peg$currPos;\n    peg$silentFails++;\n\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c15);\n      }\n    }\n\n    peg$silentFails--;\n\n    if (s1 === peg$FAILED) {\n      s0 = void 0;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  var TransformationRule = require('./TransformationRule');\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n/* jscpd:ignore-end */","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/TF_Parser.js"],"names":["peg$subclass","child","parent","ctor","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","i","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","describeExpectation","type","describeExpected","descriptions","j","sort","slice","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","transformation_rule","peg$parsetransformation_rule","peg$startRuleFunction","peg$c0","c1","c2","pred","pars","result","TransformationRule","peg$c1","peg$c2","peg$classExpectation","peg$c3","characters","peg$c4","peg$c5","peg$literalExpectation","peg$c6","wc","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$anyExpectation","peg$c16","peg$c17","peg$c18","peg$c19","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","substring","peg$computeLocation","peg$buildStructuredError","peg$otherExpectation","error","peg$buildSimpleError","ignoreCase","peg$endExpectation","peg$computePosDetails","pos","details","p","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","push","s0","s1","s2","s3","s4","s5","peg$parsecategory1","peg$parseidentifier","peg$parsewild_card","test","charAt","peg$parseS_no_eol","peg$parseEOL","substr","peg$parseComment","peg$parseEOI","peg$parseS","require","module","exports","SyntaxError","parse"],"mappings":"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","sourcesContent":["/* jscpd:ignore-start */\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n'use strict'\n\nfunction peg$subclass (child, parent) {\n  function ctor () { this.constructor = child }\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor()\n}\n\nfunction peg$SyntaxError (message, expected, found, location) {\n  this.message = message\n  this.expected = expected\n  this.found = found\n  this.location = location\n  this.name = 'SyntaxError'\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError)\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error)\n\npeg$SyntaxError.buildMessage = function (expected, found) {\n  const DESCRIBE_EXPECTATION_FNS = {\n    literal: function (expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"'\n    },\n\n    class: function (expectation) {\n      let escapedParts = ''\n      let i\n\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts += expectation.parts[i] instanceof Array\n          ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])\n          : classEscape(expectation.parts[i])\n      }\n\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'\n    },\n\n    any: function (expectation) {\n      return 'any character'\n    },\n\n    end: function (expectation) {\n      return 'end of input'\n    },\n\n    other: function (expectation) {\n      return expectation.description\n    }\n  }\n\n  function hex (ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase()\n  }\n\n  function literalEscape (s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch) })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch) })\n  }\n\n  function classEscape (s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g, '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch) })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch) })\n  }\n\n  function describeExpectation (expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)\n  }\n\n  function describeExpected (expected) {\n    const descriptions = new Array(expected.length)\n    let i; let j\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i])\n    }\n\n    descriptions.sort()\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i]\n          j++\n        }\n      }\n      descriptions.length = j\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0]\n\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1]\n\n      default:\n        return descriptions.slice(0, -1).join(', ') +\n          ', or ' +\n          descriptions[descriptions.length - 1]\n    }\n  }\n\n  function describeFound (found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input'\n  }\n\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.'\n}\n\nfunction peg$parse (input, options) {\n  options = options !== void 0 ? options : {}\n\n  const peg$FAILED = {}\n\n  const peg$startRuleFunctions = { transformation_rule: peg$parsetransformation_rule }\n  let peg$startRuleFunction = peg$parsetransformation_rule\n\n  const peg$c0 = function (c1, c2, pred, pars) {\n    let result = null\n\n    // Construct rule\n    if (pars.length === 1) {\n      result = new TransformationRule(c1, c2, pred, pars[0])\n    } else {\n      if (pars.length === 2) {\n        result = new TransformationRule(c1, c2, pred, pars[0], pars[1])\n      } else {\n        result = new TransformationRule(c1, c2, pred)\n      }\n    }\n    return (result)\n  }\n  const peg$c1 = /^[!-~\\xA1-\\xFF]/\n  const peg$c2 = peg$classExpectation([['!', '~'], ['\\xA1', '\\xFF']], false, false)\n  const peg$c3 = function (characters) {\n    let s = ''\n    for (let i = 0; i < characters.length; i++) {\n      s += characters[i]\n    }\n    return (s)\n  }\n  const peg$c4 = '*'\n  const peg$c5 = peg$literalExpectation('*', false)\n  const peg$c6 = function (wc) {\n    return (wc)\n  }\n  const peg$c7 = '\\r\\n'\n  const peg$c8 = peg$literalExpectation('\\r\\n', false)\n  const peg$c9 = '\\n'\n  const peg$c10 = peg$literalExpectation('\\n', false)\n  const peg$c11 = '\\r'\n  const peg$c12 = peg$literalExpectation('\\r', false)\n  const peg$c13 = '//'\n  const peg$c14 = peg$literalExpectation('//', false)\n  const peg$c15 = peg$anyExpectation()\n  const peg$c16 = ' '\n  const peg$c17 = peg$literalExpectation(' ', false)\n  const peg$c18 = '\\t'\n  const peg$c19 = peg$literalExpectation('\\t', false)\n\n  let peg$currPos = 0\n  let peg$savedPos = 0\n  const peg$posDetailsCache = [{ line: 1, column: 1 }]\n  let peg$maxFailPos = 0\n  let peg$maxFailExpected = []\n  let peg$silentFails = 0\n\n  let peg$result\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".')\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule]\n  }\n\n  function text () {\n    return input.substring(peg$savedPos, peg$currPos)\n  }\n\n  function location () {\n    return peg$computeLocation(peg$savedPos, peg$currPos)\n  }\n\n  function expected (description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    )\n  }\n\n  function error (message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location)\n  }\n\n  function peg$literalExpectation (text, ignoreCase) {\n    return { type: 'literal', text: text, ignoreCase: ignoreCase }\n  }\n\n  function peg$classExpectation (parts, inverted, ignoreCase) {\n    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase }\n  }\n\n  function peg$anyExpectation () {\n    return { type: 'any' }\n  }\n\n  function peg$endExpectation () {\n    return { type: 'end' }\n  }\n\n  function peg$otherExpectation (description) {\n    return { type: 'other', description: description }\n  }\n\n  function peg$computePosDetails (pos) {\n    let details = peg$posDetailsCache[pos]; let p\n\n    if (details) {\n      return details\n    } else {\n      p = pos - 1\n      while (!peg$posDetailsCache[p]) {\n        p--\n      }\n\n      details = peg$posDetailsCache[p]\n      details = {\n        line: details.line,\n        column: details.column\n      }\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++\n          details.column = 1\n        } else {\n          details.column++\n        }\n\n        p++\n      }\n\n      peg$posDetailsCache[pos] = details\n      return details\n    }\n  }\n\n  function peg$computeLocation (startPos, endPos) {\n    const startPosDetails = peg$computePosDetails(startPos)\n    const endPosDetails = peg$computePosDetails(endPos)\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    }\n  }\n\n  function peg$fail (expected) {\n    if (peg$currPos < peg$maxFailPos) { return }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos\n      peg$maxFailExpected = []\n    }\n\n    peg$maxFailExpected.push(expected)\n  }\n\n  function peg$buildSimpleError (message, location) {\n    return new peg$SyntaxError(message, null, null, location)\n  }\n\n  function peg$buildStructuredError (expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    )\n  }\n\n  function peg$parsetransformation_rule () {\n    let s0, s1, s2, s3, s4, s5\n\n    s0 = peg$currPos\n    s1 = peg$parsecategory1()\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier()\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier()\n        if (s3 !== peg$FAILED) {\n          s4 = []\n          s5 = peg$parseidentifier()\n          while (s5 !== peg$FAILED) {\n            s4.push(s5)\n            s5 = peg$parseidentifier()\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0\n            s1 = peg$c0(s1, s2, s3, s4)\n            s0 = s1\n          } else {\n            peg$currPos = s0\n            s0 = peg$FAILED\n          }\n        } else {\n          peg$currPos = s0\n          s0 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parsecategory1 () {\n    let s0\n\n    s0 = peg$parsewild_card()\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseidentifier()\n    }\n\n    return s0\n  }\n\n  function peg$parseidentifier () {\n    let s0, s1, s2\n\n    s0 = peg$currPos\n    s1 = []\n    if (peg$c1.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos)\n      peg$currPos++\n    } else {\n      s2 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c2) }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2)\n        if (peg$c1.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos)\n          peg$currPos++\n        } else {\n          s2 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c2) }\n        }\n      }\n    } else {\n      s1 = peg$FAILED\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol()\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0\n        s1 = peg$c3(s1)\n        s0 = s1\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parsewild_card () {\n    let s0, s1, s2\n\n    s0 = peg$currPos\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c4\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c5) }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseS_no_eol()\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0\n        s1 = peg$c6(s1)\n        s0 = s1\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parseEOL () {\n    let s0\n\n    if (input.substr(peg$currPos, 2) === peg$c7) {\n      s0 = peg$c7\n      peg$currPos += 2\n    } else {\n      s0 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c8) }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c9\n        peg$currPos++\n      } else {\n        s0 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c10) }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c11\n          peg$currPos++\n        } else {\n          s0 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c12) }\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseComment () {\n    let s0, s1, s2, s3, s4, s5\n\n    s0 = peg$currPos\n    if (input.substr(peg$currPos, 2) === peg$c13) {\n      s1 = peg$c13\n      peg$currPos += 2\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c14) }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = []\n      s3 = peg$currPos\n      s4 = peg$currPos\n      peg$silentFails++\n      s5 = peg$parseEOL()\n      peg$silentFails--\n      if (s5 === peg$FAILED) {\n        s4 = void 0\n      } else {\n        peg$currPos = s4\n        s4 = peg$FAILED\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos)\n          peg$currPos++\n        } else {\n          s5 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c15) }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5]\n          s3 = s4\n        } else {\n          peg$currPos = s3\n          s3 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s3\n        s3 = peg$FAILED\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3)\n        s3 = peg$currPos\n        s4 = peg$currPos\n        peg$silentFails++\n        s5 = peg$parseEOL()\n        peg$silentFails--\n        if (s5 === peg$FAILED) {\n          s4 = void 0\n        } else {\n          peg$currPos = s4\n          s4 = peg$FAILED\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos)\n            peg$currPos++\n          } else {\n            s5 = peg$FAILED\n            if (peg$silentFails === 0) { peg$fail(peg$c15) }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5]\n            s3 = s4\n          } else {\n            peg$currPos = s3\n            s3 = peg$FAILED\n          }\n        } else {\n          peg$currPos = s3\n          s3 = peg$FAILED\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseEOL()\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseEOI()\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3]\n          s0 = s1\n        } else {\n          peg$currPos = s0\n          s0 = peg$FAILED\n        }\n      } else {\n        peg$currPos = s0\n        s0 = peg$FAILED\n      }\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  function peg$parseS () {\n    let s0, s1\n\n    s0 = []\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c17) }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c19) }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseEOL()\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment()\n        }\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1)\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c17) }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18\n          peg$currPos++\n        } else {\n          s1 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c19) }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOL()\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseComment()\n          }\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseS_no_eol () {\n    let s0, s1\n\n    s0 = []\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s1 = peg$c16\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c17) }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 9) {\n        s1 = peg$c18\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c19) }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment()\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1)\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c16\n        peg$currPos++\n      } else {\n        s1 = peg$FAILED\n        if (peg$silentFails === 0) { peg$fail(peg$c17) }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9) {\n          s1 = peg$c18\n          peg$currPos++\n        } else {\n          s1 = peg$FAILED\n          if (peg$silentFails === 0) { peg$fail(peg$c19) }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment()\n        }\n      }\n    }\n\n    return s0\n  }\n\n  function peg$parseEOI () {\n    let s0, s1\n\n    s0 = peg$currPos\n    peg$silentFails++\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos)\n      peg$currPos++\n    } else {\n      s1 = peg$FAILED\n      if (peg$silentFails === 0) { peg$fail(peg$c15) }\n    }\n    peg$silentFails--\n    if (s1 === peg$FAILED) {\n      s0 = void 0\n    } else {\n      peg$currPos = s0\n      s0 = peg$FAILED\n    }\n\n    return s0\n  }\n\n  var TransformationRule = require('./TransformationRule')\n\n  peg$result = peg$startRuleFunction()\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation())\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    )\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n}\n/* jscpd:ignore-end */\n"]},"metadata":{},"sourceType":"script"}