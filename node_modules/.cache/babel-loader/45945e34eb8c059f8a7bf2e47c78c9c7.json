{"ast":null,"code":"function isStringArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? typeof text[0] === \"string\" : true);\n}\n\nfunction isTextDescriptorArray(text) {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\n\nfunction withNewLines(descriptor, width, startingX, ctx) {\n  // Break up all the parts into whitespace and words\n  var elements = descriptor.text.split(\"\").reduce(function (elements, _char) {\n    var runningElement = elements[elements.length - 1] || \"\";\n    var lastChar = runningElement.slice(-1);\n\n    if (_char === \" \" && lastChar !== \" \") {\n      return [].concat(elements, [_char]);\n    }\n\n    if (_char !== \" \" && lastChar === \" \") {\n      return [].concat(elements, [_char]);\n    }\n\n    return [].concat(elements.slice(0, -1), [\"\" + runningElement + _char]);\n  }, []);\n\n  var _elements$reduce = elements.reduce(function (result, element) {\n    ctx.font = descriptor.font;\n\n    var _ctx$measureText = ctx.measureText(element),\n        elementWidth = _ctx$measureText.width;\n\n    var completeTextWidth = result.lastLineWidth + elementWidth;\n    var itFits = completeTextWidth <= width; // If it fits, remove the last line from current results\n    // append the current element into it\n    // and insert it back in\n\n    if (itFits) {\n      var appendedLine = [].concat(result.lines.slice(-1), [element]).join(\"\");\n      return {\n        lastLineWidth: completeTextWidth,\n        lines: [].concat(result.lines.slice(0, -1), [appendedLine])\n      };\n    } // Now it doesn't fit.\n    // If the element itself didn't fit on a line\n    // Then we should force a break\n\n\n    if (elementWidth > width && result.lastLineWidth === 0) {\n      return {\n        lastLineWidth: elementWidth,\n        lines: [].concat(result.lines.slice(0, -1), [element])\n      };\n    } // Trim any whitespace at the end of the line\n    // which is being broken.\n\n\n    var previousLine = result.lines.slice(-1).join(\"\");\n    var precedingLines = [].concat(result.lines.slice(0, -1), [previousLine.trimEnd()]); // If the element that doesn't fit is a whitespace\n    // we should just insert a newline\n\n    if (element.trim().length === 0) {\n      return {\n        lastLineWidth: 0,\n        lines: [].concat(precedingLines, [\"\"])\n      };\n    } // Otherwise we should just start a new line with the element\n\n\n    return {\n      lastLineWidth: elementWidth,\n      lines: [].concat(precedingLines, [element])\n    };\n  }, {\n    lastLineWidth: startingX,\n    lines: []\n  }),\n      lastLineWidth = _elements$reduce.lastLineWidth,\n      lines = _elements$reduce.lines;\n\n  return {\n    lastLineWidth: lastLineWidth,\n    text: lines.join(\"\\n\")\n  };\n}\n\nfunction breakLines(descriptors, width) {\n  var supportsOffscreenCanvas = (\"OffscreenCanvas\" in window);\n  var canvasEl = document.createElement(\"canvas\");\n  var canvas = supportsOffscreenCanvas ? canvasEl.transferControlToOffscreen() : canvasEl;\n  canvas.width = width;\n  var ctx = canvas.getContext(\"2d\");\n\n  if (ctx) {\n    return descriptors.reduce(function (result, descriptor) {\n      var _withNewLines = withNewLines(descriptor, width, result.lastLineWidth, ctx),\n          lastLineWidth = _withNewLines.lastLineWidth,\n          text = _withNewLines.text;\n\n      return {\n        lastLineWidth: lastLineWidth,\n        lines: [].concat(result.lines, [text])\n      };\n    }, {\n      lastLineWidth: 0,\n      lines: []\n    }).lines;\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(function (_ref) {\n    var text = _ref.text;\n    return text;\n  });\n}\n\nfunction toTextDescriptors(text, defaultFont) {\n  if (isTextDescriptorArray(text)) {\n    return text.map(function (_ref2) {\n      var text = _ref2.text,\n          font = _ref2.font;\n      return {\n        text: stripNewlines(text),\n        font: font || defaultFont\n      };\n    });\n  }\n\n  if (isStringArray(text)) {\n    return text.map(function (member) {\n      return {\n        text: stripNewlines(member),\n        font: defaultFont\n      };\n    });\n  }\n\n  return [{\n    text: stripNewlines(text),\n    font: defaultFont\n  }];\n}\n\nvar newlineRegex = /(\\r\\n|\\n|\\r)/gm;\n\nfunction stripNewlines(text) {\n  return text.replace(newlineRegex, \" \");\n}\n/**\r\n * Breaks a string into lines given a width and style for the text.\r\n *\r\n * @param string - The text to be broken into lines\r\n * @param width - The width in pixels for the text to fit into\r\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\r\n * @returns The given string with newlines inserted\r\n */\n\n\nfunction breakLinesEntry(text, width, font) {\n  var descriptors = toTextDescriptors(text, font);\n\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  return breakLines(descriptors, width)[0];\n}\n\nexport default breakLinesEntry;","map":{"version":3,"sources":["../src/break-lines.ts"],"names":["Array","text","isStringArray","elements","runningElement","lastChar","char","lastLineWidth","lines","ctx","descriptor","width","elementWidth","completeTextWidth","result","itFits","appendedLine","previousLine","precedingLines","element","supportsOffscreenCanvas","canvasEl","document","canvas","withNewLines","console","isTextDescriptorArray","font","stripNewlines","defaultFont","newlineRegex","descriptors","toTextDescriptors","breakLines"],"mappings":"AAEA,SAAA,aAAA,CAAA,IAAA,EAAA;AAGE,SACEA,KAAK,CAALA,OAAAA,CAAAA,IAAAA,MACCC,IAAI,CAAJA,MAAAA,GAAAA,CAAAA,GAAkB,OAAOA,IAAI,CAAX,CAAW,CAAX,KAAlBA,QAAAA,GAFH,IACED,CADF;AAID;;AAED,SAAA,qBAAA,CAAA,IAAA,EAAA;AAGE,SAAOA,KAAK,CAALA,OAAAA,CAAAA,IAAAA,MAAwBC,IAAI,CAAJA,MAAAA,GAAAA,CAAAA,GAAkB,CAACC,aAAa,CAAhCD,IAAgC,CAAhCA,GAA/B,IAAOD,CAAP;AACD;;AAED,SAAA,YAAA,CAAA,UAAA,EAAA,KAAA,EAAA,SAAA,EAAA,GAAA,EAAA;AAME;AACA,MAAMG,QAAQ,GAAG,UAAU,CAAV,IAAA,CAAA,KAAA,CAAA,EAAA,EAAA,MAAA,CAEP,UAAA,QAAA,EAAA,KAAA,EAAA;AACN,QAAMC,cAAc,GAAGD,QAAQ,CAACA,QAAQ,CAARA,MAAAA,GAATA,CAAQ,CAARA,IAAvB,EAAA;AACA,QAAME,QAAQ,GAAGD,cAAc,CAAdA,KAAAA,CAAqB,CAAtC,CAAiBA,CAAjB;;AAEA,QAAIE,KAAI,KAAJA,GAAAA,IAAgBD,QAAQ,KAA5B,GAAA,EAAsC;AACpC,aAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA,KAAA,CAAA,CAAA;AACD;;AAED,QAAIC,KAAI,KAAJA,GAAAA,IAAgBD,QAAQ,KAA5B,GAAA,EAAsC;AACpC,aAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA,KAAA,CAAA,CAAA;AACD;;AAED,WAAA,GAAA,MAAA,CAAWF,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,EAAkB,CAA7B,CAAWA,CAAX,EAAA,CAAA,KAAA,cAAA,GAAA,KAAA,CAAA,CAAA;AAda,GAAA,EAAjB,EAAiB,CAAjB;;yBAiBiC,QAAQ,CAAR,MAAA,CAC/B,UAAA,MAAA,EAAA,OAAA,EAAA;AACEM,IAAAA,GAAG,CAAHA,IAAAA,GAAWC,UAAU,CAArBD,IAAAA;;2BACgCA,GAAG,CAAHA,WAAAA,CAAAA,OAAAA,C;QAAjBG,YAAAA,GAAAA,gBAAAA,CAAPD,K;;AACR,QAAME,iBAAiB,GAAGC,MAAM,CAANA,aAAAA,GAA1B,YAAA;AAEA,QAAMC,MAAM,GAAGF,iBAAiB,IAAhC,KAAA,CALF,CAKE;AAGA;AACA;;AACA,QAAA,MAAA,EAAY;AACV,UAAMG,YAAY,GAAG,GAAA,MAAA,CAAIF,MAAM,CAANA,KAAAA,CAAAA,KAAAA,CAAmB,CAAvB,CAAIA,CAAJ,EAAA,CAAA,OAAA,CAAA,EAAA,IAAA,CAArB,EAAqB,CAArB;AAEA,aAAO;AACLP,QAAAA,aAAa,EADR,iBAAA;AAELC,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAMM,MAAM,CAANA,KAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAsB,CAA5B,CAAMA,CAAN,EAAA,CAAA,YAAA,CAAA;AAFA,OAAP;AAID,KAjBH,CAiBG;AAID;AACA;;;AACA,QAAIF,YAAY,GAAZA,KAAAA,IAAwBE,MAAM,CAANA,aAAAA,KAA5B,CAAA,EAAwD;AACtD,aAAO;AACLP,QAAAA,aAAa,EADR,YAAA;AAELC,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAMM,MAAM,CAANA,KAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAsB,CAA5B,CAAMA,CAAN,EAAA,CAAA,OAAA,CAAA;AAFA,OAAP;AAID,KA5BH,CA4BG;AAGD;;;AACA,QAAMG,YAAY,GAAGH,MAAM,CAANA,KAAAA,CAAAA,KAAAA,CAAmB,CAAnBA,CAAAA,EAAAA,IAAAA,CAArB,EAAqBA,CAArB;AACA,QAAMI,cAAc,GAAA,GAAA,MAAA,CACfJ,MAAM,CAANA,KAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAsB,CADP,CACfA,CADe,EAAA,CAElBG,YAAY,CAFd,OAEEA,EAFkB,CAAA,CAApB,CAjCF,CAiCE;AAMA;;AACA,QAAIE,OAAO,CAAPA,IAAAA,GAAAA,MAAAA,KAAJ,CAAA,EAAiC;AAC/B,aAAO;AACLZ,QAAAA,aAAa,EADR,CAAA;AAELC,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAA,cAAA,EAAA,CAAA,EAAA,CAAA;AAFA,OAAP;AAID,KA7CH,CA6CG;;;AAGD,WAAO;AACLD,MAAAA,aAAa,EADR,YAAA;AAELC,MAAAA,KAAK,EAAA,GAAA,MAAA,CAAA,cAAA,EAAA,CAAA,OAAA,CAAA;AAFA,KAAP;AAjD6B,GAAA,EAsD/B;AAAED,IAAAA,aAAa,EAAf,SAAA;AAA4BC,IAAAA,KAAK,EAAE;AAAnC,GAtD+B,C;MAAzBD,aAAAA,GAAAA,gBAAAA,CAAAA,a;MAAeC,KAAAA,GAAAA,gBAAAA,CAAAA,K;;AAyDvB,SAAO;AAAED,IAAAA,aAAa,EAAf,aAAA;AAAiBN,IAAAA,IAAI,EAAEO,KAAK,CAALA,IAAAA,CAAAA,IAAAA;AAAvB,GAAP;AACD;;AAED,SAAA,UAAA,CAAA,WAAA,EAAA,KAAA,EAAA;AAIE,MAAMY,uBAAuB,IAAG,qBAAhC,MAA6B,CAA7B;AAEA,MAAMC,QAAQ,GAAGC,QAAQ,CAARA,aAAAA,CAAjB,QAAiBA,CAAjB;AAEA,MAAMC,MAAM,GAAGH,uBAAuB,GAClCC,QAAQ,CAD0B,0BAClCA,EADkC,GAAtC,QAAA;AAIAE,EAAAA,MAAM,CAANA,KAAAA,GAAAA,KAAAA;AACA,MAAMd,GAAG,GAAGc,MAAM,CAANA,UAAAA,CAAZ,IAAYA,CAAZ;;AAIA,MAAA,GAAA,EAAS;AACP,WAAO,WAAW,CAAX,MAAA,CACL,UAAA,MAAA,EAAA,UAAA,EAAA;0BACkCC,YAAY,CAAA,UAAA,EAAA,KAAA,EAG1CV,MAAM,CAHoC,aAAA,EAAA,GAAA,C;UAApCP,aAAAA,GAAAA,aAAAA,CAAAA,a;UAAeN,IAAAA,GAAAA,aAAAA,CAAAA,I;;AAOvB,aAAO;AACLM,QAAAA,aAAa,EADR,aAAA;AAELC,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAMM,MAAM,CAAZ,KAAA,EAAA,CAAA,IAAA,CAAA;AAFA,OAAP;AATG,KAAA,EAcL;AAAEP,MAAAA,aAAa,EAAf,CAAA;AAAoBC,MAAAA,KAAK,EAAE;AAA3B,KAdK,EAAP,KAAA;AAgBD;;AAEDiB,EAAAA,OAAO,CAAPA,IAAAA,CAAAA,4DAAAA;AACA,SAAO,WAAW,CAAX,GAAA,CAAgB,UAAA,IAAA,EAAA;AAAA,QAAGxB,IAAH,GAAA,IAAA,CAAA,IAAA;AAAA,WAAA,IAAA;AAAvB,GAAO,CAAP;AACD;;AAED,SAAA,iBAAA,CAAA,IAAA,EAAA,WAAA,EAAA;AAIE,MAAIyB,qBAAqB,CAAzB,IAAyB,CAAzB,EAAiC;AAC/B,WAAO,IAAI,CAAJ,GAAA,CAAS,UAAA,KAAA,EAAA;AAAA,UAAGzB,IAAH,GAAA,KAAA,CAAA,IAAA;AAAA,UAAS0B,IAAT,GAAA,KAAA,CAAA,IAAA;AAAA,aAAqB;AACnC1B,QAAAA,IAAI,EAAE2B,aAAa,CADgB,IAChB,CADgB;AAEnCD,QAAAA,IAAI,EAAEA,IAAI,IAAIE;AAFqB,OAArB;AAAhB,KAAO,CAAP;AAID;;AAED,MAAI3B,aAAa,CAAjB,IAAiB,CAAjB,EAAyB;AACvB,WAAO,IAAI,CAAJ,GAAA,CAAS,UAAA,MAAA,EAAM;AAAA,aAAK;AACzBD,QAAAA,IAAI,EAAE2B,aAAa,CADM,MACN,CADM;AAEzBD,QAAAA,IAAI,EAAEE;AAFmB,OAAL;AAAtB,KAAO,CAAP;AAID;;AAED,SAAO,CAAC;AAAE5B,IAAAA,IAAI,EAAE2B,aAAa,CAArB,IAAqB,CAArB;AAA6BD,IAAAA,IAAI,EAAEE;AAAnC,GAAD,CAAP;AACD;;AAED,IAAMC,YAAY,GAAlB,gBAAA;;AAEA,SAAA,aAAA,CAAA,IAAA,EAAA;AACE,SAAO7B,IAAI,CAAJA,OAAAA,CAAAA,YAAAA,EAAP,GAAOA,CAAP;AACD;AASD;;;;;;;;;;AAQA,SAAA,eAAA,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA;AAKE,MAAM8B,WAAW,GAAGC,iBAAiB,CAAA,IAAA,EAArC,IAAqC,CAArC;;AAEA,MAAI9B,aAAa,CAAjB,IAAiB,CAAjB,EAAyB;AACvB,WAAO+B,UAAU,CAAA,WAAA,EAAjB,KAAiB,CAAjB;AACD;;AAED,MAAIP,qBAAqB,CAAzB,IAAyB,CAAzB,EAAiC;AAC/B,WAAOO,UAAU,CAAA,WAAA,EAAjB,KAAiB,CAAjB;AACD;;AAED,SAAOA,UAAU,CAAA,WAAA,EAAVA,KAAU,CAAVA,CAAP,CAAOA,CAAP;AACD","sourcesContent":["type TextDescriptor = { text: string; font?: string };\n\nfunction isStringArray(\n  text: string | string[] | TextDescriptor[]\n): text is string[] {\n  return (\n    Array.isArray(text) &&\n    (text.length > 0 ? typeof text[0] === \"string\" : true)\n  );\n}\n\nfunction isTextDescriptorArray(\n  text: string | string[] | TextDescriptor[]\n): text is TextDescriptor[] {\n  return Array.isArray(text) && (text.length > 0 ? !isStringArray(text) : true);\n}\n\nfunction withNewLines(\n  descriptor: { text: string; font: string },\n  width: Number,\n  startingX: number,\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n): { lastLineWidth: number; text: string } {\n  // Break up all the parts into whitespace and words\n  const elements = descriptor.text\n    .split(\"\")\n    .reduce((elements: string[], char: string) => {\n      const runningElement = elements[elements.length - 1] || \"\";\n      const lastChar = runningElement.slice(-1);\n\n      if (char === \" \" && lastChar !== \" \") {\n        return [...elements, char];\n      }\n\n      if (char !== \" \" && lastChar === \" \") {\n        return [...elements, char];\n      }\n\n      return [...elements.slice(0, -1), `${runningElement}${char}`];\n    }, []);\n\n  const { lastLineWidth, lines } = elements.reduce(\n    (result, element: string) => {\n      ctx.font = descriptor.font;\n      const { width: elementWidth } = ctx.measureText(element);\n      const completeTextWidth = result.lastLineWidth + elementWidth;\n\n      const itFits = completeTextWidth <= width;\n\n      // If it fits, remove the last line from current results\n      // append the current element into it\n      // and insert it back in\n      if (itFits) {\n        const appendedLine = [...result.lines.slice(-1), element].join(\"\");\n\n        return {\n          lastLineWidth: completeTextWidth,\n          lines: [...result.lines.slice(0, -1), appendedLine]\n        };\n      }\n\n      // Now it doesn't fit.\n\n      // If the element itself didn't fit on a line\n      // Then we should force a break\n      if (elementWidth > width && result.lastLineWidth === 0) {\n        return {\n          lastLineWidth: elementWidth,\n          lines: [...result.lines.slice(0, -1), element]\n        };\n      }\n\n      // Trim any whitespace at the end of the line\n      // which is being broken.\n      const previousLine = result.lines.slice(-1).join(\"\");\n      const precedingLines = [\n        ...result.lines.slice(0, -1),\n        previousLine.trimEnd()\n      ];\n\n      // If the element that doesn't fit is a whitespace\n      // we should just insert a newline\n      if (element.trim().length === 0) {\n        return {\n          lastLineWidth: 0,\n          lines: [...precedingLines, \"\"]\n        };\n      }\n\n      // Otherwise we should just start a new line with the element\n      return {\n        lastLineWidth: elementWidth,\n        lines: [...precedingLines, element]\n      };\n    },\n    { lastLineWidth: startingX, lines: [] as string[] }\n  );\n\n  return { lastLineWidth, text: lines.join(\"\\n\") };\n}\n\nfunction breakLines(\n  descriptors: { text: string; font: string }[],\n  width: number\n): string[] {\n  const supportsOffscreenCanvas = \"OffscreenCanvas\" in window;\n\n  const canvasEl = document.createElement(\"canvas\");\n\n  const canvas = supportsOffscreenCanvas\n    ? canvasEl.transferControlToOffscreen()\n    : canvasEl;\n\n  canvas.width = width;\n  const ctx = canvas.getContext(\"2d\") as\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D;\n\n  if (ctx) {\n    return descriptors.reduce(\n      (result, descriptor) => {\n        const { lastLineWidth, text } = withNewLines(\n          descriptor,\n          width,\n          result.lastLineWidth,\n          ctx\n        );\n\n        return {\n          lastLineWidth,\n          lines: [...result.lines, text]\n        };\n      },\n      { lastLineWidth: 0, lines: [] as string[] }\n    ).lines;\n  }\n\n  console.warn(\"No canvas context was found, so the string was left as is!\");\n  return descriptors.map(({ text }) => text);\n}\n\nfunction toTextDescriptors(\n  text: string | string[] | TextDescriptor[],\n  defaultFont: string\n): { text: string; font: string }[] {\n  if (isTextDescriptorArray(text)) {\n    return text.map(({ text, font }) => ({\n      text: stripNewlines(text),\n      font: font || defaultFont\n    }));\n  }\n\n  if (isStringArray(text)) {\n    return text.map(member => ({\n      text: stripNewlines(member),\n      font: defaultFont\n    }));\n  }\n\n  return [{ text: stripNewlines(text), font: defaultFont }];\n}\n\nconst newlineRegex = /(\\r\\n|\\n|\\r)/gm;\n\nfunction stripNewlines(text: string) {\n  return text.replace(newlineRegex, \" \");\n}\n\nfunction breakLinesEntry(text: string, width: number, font: string): string;\nfunction breakLinesEntry(text: string[], width: number, font: string): string[];\nfunction breakLinesEntry(\n  text: TextDescriptor[],\n  width: number,\n  font: string\n): string[];\n/**\n * Breaks a string into lines given a width and style for the text.\n *\n * @param string - The text to be broken into lines\n * @param width - The width in pixels for the text to fit into\n * @param font - The style of the text expressed as a value of the CSS font property, e.g. '12pt bold serif'\n * @returns The given string with newlines inserted\n */\nfunction breakLinesEntry(\n  text: string | string[] | TextDescriptor[],\n  width: number,\n  font: string\n): string | string[] {\n  const descriptors = toTextDescriptors(text, font);\n\n  if (isStringArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  if (isTextDescriptorArray(text)) {\n    return breakLines(descriptors, width);\n  }\n\n  return breakLines(descriptors, width)[0];\n}\n\nexport default breakLinesEntry;\n"]},"metadata":{},"sourceType":"module"}