{"ast":null,"code":"import { createElement, Fragment, useReducer, useRef, useCallback, useEffect, useMemo, useDebugValue, useContext, createContext, Children, isValidElement, cloneElement } from 'react';\nimport breakLines from 'break-styled-lines';\n\nfunction isPlayedWindup(windup) {\n  return windup.length === 2;\n}\n\nfunction memberIsWindup(member) {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  } // If it has less or more than three members it's not a windup\n\n\n  if (member.length !== 3) {\n    return false;\n  } // If its first or second members are not arrays it's not a windup\n\n\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  } // Past here we just have to hope ElementType isn't a windup.\n\n\n  return true;\n}\n\nfunction windupFromString(str, metadata) {\n  return [[], str.split(\"\"), metadata];\n}\n\nfunction newWindup(arg, metadata) {\n  return [[], arg, metadata];\n}\n\nfunction isUnplayed(windup) {\n  var played = windup[0],\n      remaining = windup[1];\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce(function (unplayed, member) {\n    if (memberIsWindup(member)) if (memberIsWindup(windup) && unplayed) {\n      return isUnplayed(member);\n    }\n    return unplayed;\n  }, true);\n}\n\nfunction isFinished(_ref) {\n  var remaining = _ref[1];\n  return remaining.length === 0;\n}\n\nfunction fastForward(windup) {\n  var forwardedWindup = next(windup);\n\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n\n  return fastForward(forwardedWindup);\n}\n\nfunction rewind(windup) {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  var played = windup[0],\n      remaining = windup[1],\n      metadata = windup[2];\n\n  var mapRewind = function mapRewind(member) {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n\n    return member;\n  };\n\n  return [[], [].concat(played.map(mapRewind), remaining.map(mapRewind)), metadata];\n}\n\nfunction lastPlayedMember(_ref2) {\n  var played = _ref2[0],\n      remaining = _ref2[1];\n  var playedFromRemaining = remaining.reduce(function (playedEl, member) {\n    if (memberIsWindup(member)) {\n      if (!isUnplayed(member)) {\n        return lastPlayedElement(member);\n      }\n    }\n\n    return playedEl;\n  }, undefined);\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  var last = played[played.length - 1];\n  return last;\n}\n\nfunction lastPlayedElement(windup) {\n  var lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nfunction playedElements(_ref3) {\n  var played = _ref3[0],\n      remaining = _ref3[1];\n  var playedTransformed = played.map(function (member) {\n    if (memberIsWindup(member)) {\n      var metadata = member[2];\n      return [playedElements(member), metadata];\n    }\n\n    return member;\n  });\n  var firstRemaning = remaining[0];\n\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    var metadata = firstRemaning[2];\n    return [].concat(playedTransformed, [[playedElements(firstRemaning), metadata]]);\n  }\n\n  return playedTransformed;\n}\n\nfunction nextElement(_ref4) {\n  var remaining = _ref4[1];\n  var nextVal = remaining[0];\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nfunction next(windup) {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  var played = windup[0],\n      remaining = windup[1],\n      metadata = windup[2];\n  var firstRemaining = remaining[0],\n      restRemaining = remaining.slice(1);\n\n  if (memberIsWindup(firstRemaining)) {\n    var nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[].concat(played, [nextFirstRemaining]), restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining].concat(restRemaining), metadata];\n  }\n\n  return [[].concat(played, [firstRemaining]), restRemaining, metadata];\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction defaultGetPace(lastChar, nextChar) {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n\n    case \".\":\n    case \",\":\n      return 150;\n\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n\n      return 20;\n\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n\n    default:\n      return 20;\n  }\n}\n\nvar Pace = function Pace(_ref) {\n  var children = _ref.children;\n  return createElement(Fragment, null, children);\n};\n\nfunction isPaceElement(element) {\n  return element.type === Pace;\n}\n\nfunction isMsProp(props) {\n  if (\"ms\" in props) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction paceFromWindup(windup, parentPace) {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  var remaining = windup[1],\n      metadata = windup[2];\n  var firstRemaining = remaining[0];\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nvar OnChar = function OnChar(_ref) {\n  var children = _ref.children;\n  return createElement(Fragment, null, children);\n};\n\nfunction isOnCharElement(element) {\n  return element.type === OnChar;\n} // Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\n\n\nfunction onCharsFromWindup(windup) {\n  var remaining = windup[1],\n      metadata = windup[2];\n  var lastPlayed = lastPlayedMember(windup);\n  var firstRemaining = remaining[0];\n  var onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push.apply(onChars, onCharsFromWindup(lastPlayed));\n  }\n\n  if (firstRemaining && memberIsWindup(firstRemaining) && !isUnplayed(firstRemaining)) {\n    onChars.push.apply(onChars, onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nfunction initWindupState(windup) {\n  return {\n    windup: windup,\n    didFinishOnce: false\n  };\n}\n\nfunction windupReducer(state, action) {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n\n    case \"next\":\n      return _extends({}, state, {\n        windup: next(state.windup)\n      });\n\n    case \"rewind\":\n      return {\n        windup: rewind(state.windup),\n        didFinishOnce: false\n      };\n\n    case \"fast-forward\":\n      return _extends({}, state, {\n        windup: fastForward(state.windup)\n      });\n\n    case \"finish\":\n      return _extends({}, state, {\n        didFinishOnce: true\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useWindup(windupInit, options) {\n  var _React$useReducer = useReducer(windupReducer, windupInit, initWindupState),\n      _React$useReducer$ = _React$useReducer[0],\n      windup = _React$useReducer$.windup,\n      didFinishOnce = _React$useReducer$.didFinishOnce,\n      dispatch = _React$useReducer[1];\n\n  var timeoutRef = useRef(null);\n  var windupIsFinished = isFinished(windup);\n  var skip = useCallback(function () {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n  var rewind = useCallback(function () {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({\n      type: \"rewind\"\n    });\n  }, []); // If windup arg changes, we should reset\n\n  useEffect(function () {\n    dispatch({\n      type: \"replace\",\n      windup: windupInit\n    });\n  }, [windupInit]); // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n\n  useEffect(function () {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n\n    if (options.skipped === false) {\n      dispatch({\n        type: \"rewind\"\n      });\n    }\n  }, [options.skipped]); // When the windup changes, onChar should fire\n\n  useEffect(function () {\n    var onChars = onCharsFromWindup(windup);\n    var lastEl = lastPlayedElement(windup);\n\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(function (onChar) {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]); // If windup finishes, the onFinished should fire\n\n  useEffect(function () {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      var timeout = setTimeout(function () {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n\n        dispatch({\n          type: \"finish\"\n        });\n      }, 0);\n      return function () {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]); // the windup effect itself\n\n  useEffect(function () {\n    if (!windupIsFinished) {\n      var getPace = paceFromWindup(windup) || defaultGetPace;\n      var lastEl = lastPlayedElement(windup);\n      var nextEl = nextElement(windup);\n      timeoutRef.current = setTimeout(function () {\n        dispatch({\n          type: \"next\"\n        });\n      }, lastEl ? getPace(lastEl, nextEl) : 0);\n      return function () {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n  return {\n    windup: windup,\n    skip: skip,\n    rewind: rewind,\n    isFinished: windupIsFinished\n  };\n}\n\nfunction renderStringWindup(windup) {\n  var played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  var inner = played.reduce(function (acc, playedEl) {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n  return inner;\n}\n\nvar VOID_TAGS = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n\nfunction renderChildrenWindup(windup) {\n  var metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  var played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n  var Outer = metadata.element || Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return createElement(Outer, Object.assign({\n      key: metadata.key\n    }, metadata.props));\n  }\n\n  var inner = played.reduce(function (acc, playedEl) {\n    if (typeof playedEl === \"string\") {\n      var accButLast = acc.slice(0, acc.length - 1);\n      var last = acc[acc.length - 1];\n      return last && typeof last === \"string\" ? [].concat(accButLast, [last + playedEl]) : [].concat(acc, [playedEl]);\n    }\n\n    return [].concat(acc, [renderChildrenWindup(playedEl)]);\n  }, []);\n\n  if (typeof metadata.element === \"string\" && VOID_TAGS.includes(metadata.element)) {\n    return createElement(Outer, Object.assign({\n      key: metadata.key\n    }, metadata.props));\n  }\n\n  return createElement(Outer, Object.assign({\n    key: metadata.key\n  }, metadata.props), inner);\n}\n\nfunction useWindupString(text, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var windupInit = useMemo(function () {\n    return windupFromString(text, options); // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  var _useWindup = useWindup(windupInit, options),\n      windup = _useWindup.windup,\n      skip = _useWindup.skip,\n      rewind = _useWindup.rewind,\n      isFinished = _useWindup.isFinished;\n\n  var rendered = renderStringWindup(windup);\n  useDebugValue(rendered);\n  return [rendered, {\n    skip: skip,\n    rewind: rewind,\n    isFinished: isFinished\n  }];\n}\n\nvar Pause = function Pause() {\n  return null;\n};\n\nfunction isPauseElement(element) {\n  return element.type === Pause;\n}\n\nvar WindupContext = /*#__PURE__*/createContext({\n  skip: function skip() {\n    console.warn(\"Tried to use the useSkip hook outside of a WindupChildren component!!\");\n  },\n  rewind: function rewind() {\n    console.warn(\"Tried to use the useRewind hook outside of a WindupChildren component!\");\n  },\n  isFinished: false\n});\n\nfunction useSkip() {\n  var _React$useContext = useContext(WindupContext),\n      skip = _React$useContext.skip;\n\n  return skip;\n}\n\nfunction useRewind() {\n  var _React$useContext2 = useContext(WindupContext),\n      rewind = _React$useContext2.rewind;\n\n  return rewind;\n}\n\nfunction useIsFinished() {\n  var _React$useContext3 = useContext(WindupContext),\n      isFinished = _React$useContext3.isFinished;\n\n  return isFinished;\n}\n\nfunction reduceWindupArgs(prevArgs, children) {\n  if (typeof children === \"string\") {\n    return [].concat(prevArgs, children.split(\"\"));\n  }\n\n  if (typeof children === \"number\") {\n    return [].concat(prevArgs, children.toString().split(\"\"));\n  }\n\n  if (!isValidElement(children)) {\n    return prevArgs;\n  }\n\n  var _children$props = children.props,\n      childrenChildren = _children$props.children,\n      restProps = _objectWithoutPropertiesLoose(_children$props, [\"children\"]);\n\n  var paceMetaData = isPaceElement(children) ? {\n    pace: function pace(_char) {\n      if (isMsProp(children.props)) {\n        return children.props.ms;\n      }\n\n      return children.props.getPace(_char);\n    }\n  } : {};\n  var onCharMetaData = isOnCharElement(children) ? {\n    onChar: children.props.fn\n  } : {};\n  var keyProp = children.key ? {\n    key: children.key\n  } : {};\n\n  if (isPauseElement(children)) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: Fragment\n    }, keyProp, {\n      props: {\n        children: undefined\n      },\n      pace: function pace() {\n        return children.props.ms;\n      }\n    }))]);\n  }\n\n  if (childrenChildren === undefined) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: children.type,\n      props: _extends({}, restProps, {\n        children: undefined\n      })\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [].concat(prevArgs, [windupFromString(childrenChildren, _extends({\n      element: children.type,\n      props: restProps\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [].concat(prevArgs, [windupFromString(\" \", _extends({\n      element: children.type,\n      props: _extends({\n        children: childrenChildren\n      }, restProps)\n    }, keyProp, paceMetaData, onCharMetaData))]);\n  }\n\n  var newArgs = Children.toArray(childrenChildren).reduce(reduceWindupArgs, []);\n  var argsWithMetadata = newArgs.map(function (member) {\n    if (memberIsWindup(member)) {\n      var played = member[0],\n          remaining = member[1],\n          metadata = member[2];\n      return [played, remaining, _extends({}, paceMetaData, onCharMetaData, metadata)];\n    }\n\n    return member;\n  });\n  return [].concat(prevArgs, [newWindup(argsWithMetadata, _extends({\n    element: children.type,\n    props: restProps\n  }, keyProp, paceMetaData, onCharMetaData))]);\n}\n\nfunction buildKeyString(children) {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  var keys = Children.map(children, function (child) {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (isValidElement(child)) {\n      return \"#\" + (child.key || \"\") + \"<\" + buildKeyString(child.props.children) + \">\";\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo(factory, children) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var memoChildren = useMemo(factory, [buildKeyString(children)]);\n  return memoChildren;\n}\n\nvar WindupChildren = function WindupChildren(_ref) {\n  var children = _ref.children,\n      onFinished = _ref.onFinished,\n      skipped = _ref.skipped;\n  var windupInit = useChildrenMemo(function () {\n    return newWindup(Children.toArray(children).reduce(reduceWindupArgs, []), {\n      element: undefined\n    });\n  }, children);\n\n  var _useWindup = useWindup(windupInit, {\n    onFinished: onFinished,\n    skipped: skipped\n  }),\n      windup = _useWindup.windup,\n      skip = _useWindup.skip,\n      rewind = _useWindup.rewind,\n      isFinished = _useWindup.isFinished;\n\n  return createElement(WindupContext.Provider, {\n    value: {\n      skip: skip,\n      rewind: rewind,\n      isFinished: isFinished\n    }\n  }, renderChildrenWindup(windup));\n};\n\nfunction wrapChildren(children, Wrapper) {\n  if (typeof children === \"string\") {\n    return children.split(\"\").map(function (_char, i) {\n      return _char === \"\\n\" ? _char : createElement(Wrapper, {\n        key: _char + \"-\" + i\n      }, _char);\n    });\n  }\n\n  if (typeof children === \"number\") {\n    return children.toString().split(\"\").map(function (_char2) {\n      return createElement(Wrapper, null, _char2);\n    });\n  }\n\n  if (!isValidElement(children)) {\n    return createElement(Fragment, null);\n  }\n\n  if (children.props.children) {\n    var Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return createElement(Outer, Object.assign({\n        key: children.key\n      }, children.props));\n    }\n\n    return createElement(Outer, Object.assign({\n      key: children.key\n    }, children.props), Children.map(children.props.children, function (ch) {\n      return wrapChildren(ch, Wrapper);\n    }));\n  }\n\n  return children;\n}\n\nvar CharWrapper = function CharWrapper(_ref) {\n  var children = _ref.children,\n      element = _ref.element;\n  return createElement(Fragment, null, Children.map(children, function (ch) {\n    return wrapChildren(ch, element);\n  }));\n};\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle) {\n  return function (descriptors, children) {\n    if (typeof children === \"string\") {\n      return [].concat(descriptors, [{\n        text: children,\n        font: defaultFontStyle\n      }]);\n    }\n\n    if (typeof children === \"number\") {\n      return [].concat(descriptors, [{\n        text: children.toString(),\n        font: defaultFontStyle\n      }]);\n    }\n\n    if (!isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (isStyledTextElement(children) && typeof children.props.children === \"string\") {\n      return [].concat(descriptors, [{\n        text: children.props.children,\n        font: children.props.fontStyle\n      }]);\n    }\n\n    if (isStyledTextElement(children)) {\n      return [].concat(descriptors, Children.toArray(children.props.children).reduce(makeGetDescriptorsOfChildren(children.props.fontStyle), []));\n    }\n\n    return [].concat(descriptors, Children.toArray(children.props.children).reduce(makeGetDescriptorsOfChildren(defaultFontStyle), []));\n  };\n}\n\nfunction reinsertStringsIntoChildren(_ref, children) {\n  var accChildren = _ref[0],\n      accStrings = _ref[1];\n\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    var firstString = accStrings[0],\n        restStrings = accStrings.slice(1);\n    return [[].concat(accChildren, [firstString]), restStrings];\n  }\n\n  if (!isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  var _React$Children$toArr = Children.toArray(children.props.children).reduce(reinsertStringsIntoChildren, [[], accStrings]),\n      subChildrenAcc = _React$Children$toArr[0],\n      subStringsAcc = _React$Children$toArr[1];\n\n  return [[].concat(accChildren, [cloneElement(children, {\n    children: subChildrenAcc\n  })]), subStringsAcc];\n}\n\nfunction isStyledTextElement(element) {\n  return element.type === StyledText;\n}\n\nfunction StyledText(_ref2) {\n  var children = _ref2.children;\n  return createElement(Fragment, null, children);\n}\n\nvar Linebreaker = function Linebreaker(_ref3) {\n  var children = _ref3.children,\n      fontStyle = _ref3.fontStyle,\n      width = _ref3.width; // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  var childrenArray = Children.toArray(children);\n  var descriptors = childrenArray.reduce(makeGetDescriptorsOfChildren(fontStyle), []);\n  var transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  var _childrenArray$reduce = childrenArray.reduce(reinsertStringsIntoChildren, [[], transformedStrings]),\n      transformedChildren = _childrenArray$reduce[0];\n\n  return createElement(\"div\", {\n    style: {\n      whiteSpace: \"pre\"\n    }\n  }, transformedChildren);\n};\n\nvar Effect = function Effect(_ref) {\n  var fn = _ref.fn;\n  useEffect(function () {\n    fn(); // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return null;\n};\n\nfunction textFromChildren(children) {\n  var text = Children.map(children, function (ch) {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n\nexport { CharWrapper, Effect, Linebreaker, OnChar, Pace, Pause, StyledText, WindupChildren, defaultGetPace, textFromChildren, useIsFinished, useRewind, useSkip, useWindupString };","map":{"version":3,"sources":["../src/Windup.ts","../src/react/Pace.tsx","../src/react/OnChar.tsx","../src/react/useWindup.ts","../src/react/renderWindup.tsx","../src/react/useWindupString.ts","../src/react/Pause.tsx","../src/react/WindupChildren.tsx","../src/react/CharWrapper.tsx","../src/react/Linebreaker.tsx","../src/react/Effect.tsx","../src/react/textFromChildren.ts"],"names":["isPlayedWindup","windup","memberIsWindup","member","Array","windupFromString","str","metadata","newWindup","arg","isUnplayed","played","remaining","isFinished","fastForward","forwardedWindup","next","rewind","mapRewind","lastPlayedMember","playedFromRemaining","lastPlayedElement","last","lastPlayed","playedElements","playedTransformed","firstRemaning","nextElement","nextVal","firstRemaining","restRemaining","nextFirstRemaining","defaultGetPace","lastChar","nextChar","Pace","children","React","isPaceElement","element","isMsProp","props","paceFromWindup","parentPace","OnChar","isOnCharElement","onCharsFromWindup","onChars","didFinishOnce","action","initWindupState","state","useWindup","windupInit","options","dispatch","timeoutRef","windupIsFinished","skip","clearTimeout","type","lastEl","onChar","timeout","setTimeout","getPace","nextEl","renderStringWindup","inner","acc","VOID_TAGS","renderChildrenWindup","Outer","Object","key","accButLast","useWindupString","text","rendered","Pause","isPauseElement","WindupContext","console","useSkip","useRewind","useIsFinished","childrenChildren","restProps","paceMetaData","pace","onCharMetaData","fn","keyProp","undefined","newArgs","argsWithMetadata","keys","child","buildKeyString","memoChildren","WindupChildren","onFinished","skipped","useChildrenMemo","value","char","i","wrapChildren","CharWrapper","font","defaultFontStyle","isStyledTextElement","fontStyle","makeGetDescriptorsOfChildren","accChildren","accStrings","firstString","restStrings","subChildrenAcc","subStringsAcc","StyledText","Linebreaker","width","childrenArray","descriptors","transformedStrings","breakLines","transformedChildren","style","whiteSpace","Effect","textFromChildren","ch"],"mappings":"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","sourcesContent":["export type WindupMember<ElementType, MetadataType> =\n  | ElementType\n  | Windup<ElementType, MetadataType>;\nexport type Windup<ElementType, MetadataType> = [\n  Array<WindupMember<ElementType, MetadataType>>,\n  Array<WindupMember<ElementType, MetadataType>>,\n  MetadataType\n];\n\nexport function isPlayedWindup<ElementType, MetadataType>(\n  windup:\n    | PlayedWindup<ElementType, MetadataType>\n    | Windup<ElementType, MetadataType>\n): windup is PlayedWindup<ElementType, MetadataType> {\n  return windup.length === 2;\n}\n\nexport function memberIsWindup<ElementType, MetadataType>(\n  member: WindupMember<ElementType, MetadataType>\n): member is Windup<ElementType, MetadataType> {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  }\n\n  // If it has less or more than three members it's not a windup\n  if (member.length !== 3) {\n    return false;\n  }\n\n  // If its first or second members are not arrays it's not a windup\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  }\n\n  // Past here we just have to hope ElementType isn't a windup.\n  return true;\n}\n\nexport function windupFromString<MetadataType>(\n  str: string,\n  metadata: MetadataType\n): Windup<string, MetadataType> {\n  return [[], str.split(\"\"), metadata];\n}\n\nexport function newWindup<ElementType, MetadataType>(\n  arg: Array<WindupMember<ElementType, MetadataType>>,\n  metadata: MetadataType\n): Windup<ElementType, MetadataType> {\n  return [[], arg, metadata];\n}\n\nexport function isUnplayed<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): boolean {\n  const [played, remaining] = windup;\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce((unplayed: boolean, member) => {\n    if (memberIsWindup(member))\n      if (memberIsWindup(windup) && unplayed) {\n        return isUnplayed<ElementType, MetadataType>(member);\n      }\n    return unplayed;\n  }, true);\n}\n\nexport function isFinished<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): boolean {\n  return remaining.length === 0;\n}\n\nexport function fastForward<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  const forwardedWindup = next(windup);\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n  return fastForward(forwardedWindup);\n}\n\nexport function rewind<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n\n  type MemberType = WindupMember<ElementType, MetadataType>;\n\n  const mapRewind = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n    return member;\n  };\n\n  return [\n    [],\n    [...played.map(mapRewind), ...remaining.map(mapRewind)],\n    metadata\n  ];\n}\n\nexport function windupAsString<MetadataType>(\n  windup: Windup<string, MetadataType>\n): string {\n  const [played, remaining] = windup;\n\n  type MemberType = WindupMember<string, MetadataType>;\n  const stringify = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return windupAsString(member);\n    }\n    return member;\n  };\n  return [\n    played.map(stringify).join(\"\"),\n    remaining.map(stringify).join(\"\")\n  ].join(\"\");\n}\n\nexport function lastPlayedMember<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>):\n  | WindupMember<ElementType, MetadataType>\n  | undefined {\n  const playedFromRemaining = remaining.reduce(\n    (playedEl: WindupMember<ElementType, MetadataType> | undefined, member) => {\n      if (memberIsWindup(member)) {\n        if (!isUnplayed(member)) {\n          return lastPlayedElement(member);\n        }\n      }\n      return playedEl;\n    },\n    undefined\n  );\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  const last = played[played.length - 1];\n  return last;\n}\n\nexport function lastPlayedElement<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): ElementType | undefined {\n  const lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nexport type PlayedWindup<ElementType, MetadataType> = [\n  Array<ElementType>,\n  MetadataType\n];\n\nexport function playedElements<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>): Array<\n  ElementType | PlayedWindup<ElementType, MetadataType>\n> {\n  const playedTransformed = played.map(member => {\n    if (memberIsWindup(member)) {\n      const [, , metadata] = member;\n      return [playedElements(member), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >;\n    }\n    return member;\n  });\n\n  const [firstRemaning] = remaining;\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    const [, , metadata] = firstRemaning;\n\n    return [\n      ...playedTransformed,\n      [playedElements(firstRemaning), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >\n    ];\n  }\n\n  return playedTransformed;\n}\n\nexport function nextElement<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): ElementType | undefined {\n  const [nextVal] = remaining;\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nexport function next<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n  const [firstRemaining, ...restRemaining] = remaining;\n\n  if (memberIsWindup(firstRemaining)) {\n    const nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[...played, nextFirstRemaining], restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining, ...restRemaining], metadata];\n  }\n\n  return [[...played, firstRemaining], restRemaining, metadata];\n}\n","import * as React from \"react\";\nimport { isFinished, memberIsWindup, Windup } from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype MsProp = {\n  ms: number;\n};\n\ntype GetPaceProp = {\n  getPace: (char: string) => number;\n};\n\ntype PaceProps = MsProp | GetPaceProp;\n\nexport function defaultGetPace(\n  lastChar: string,\n  nextChar: string | undefined\n): number {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n    case \".\":\n    case \",\":\n      return 150;\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n      return 20;\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n    default:\n      return 20;\n  }\n}\n\nconst Pace: React.FC<PaceProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isPaceElement(\n  element: React.ReactElement\n): element is React.ReactElement<PaceProps> {\n  return element.type === Pace;\n}\n\nexport function isMsProp(props: PaceProps): props is MsProp {\n  if (\"ms\" in props) {\n    return true;\n  }\n  return false;\n}\n\nexport function paceFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(\n  windup: W,\n  parentPace?: (char: string, nextChar: string | undefined) => number\n): ((char: string, nextChar: string | undefined) => number) | undefined {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  const [, remaining, metadata] = windup;\n\n  const [firstRemaining] = remaining;\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nexport default Pace;\n","import * as React from \"react\";\nimport {\n  memberIsWindup,\n  Windup,\n  lastPlayedMember,\n  isUnplayed\n} from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype OnCharProps = {\n  fn: (char: string) => void;\n};\n\nconst OnChar: React.FC<OnCharProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isOnCharElement(\n  element: React.ReactElement\n): element is React.ReactElement<OnCharProps> {\n  return element.type === OnChar;\n}\n\n// Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\nexport function onCharsFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(windup: W): ((char: string) => void)[] {\n  const [, remaining, metadata] = windup;\n  const lastPlayed = lastPlayedMember(windup);\n  const [firstRemaining] = remaining;\n\n  let onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push(...onCharsFromWindup(lastPlayed));\n  }\n\n  if (\n    firstRemaining &&\n    memberIsWindup(firstRemaining) &&\n    !isUnplayed(firstRemaining)\n  ) {\n    onChars.push(...onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nexport default OnChar;\n","import * as React from \"react\";\nimport { defaultGetPace, paceFromWindup } from \"./Pace\";\nimport {\n  isFinished,\n  lastPlayedElement,\n  next,\n  fastForward,\n  rewind,\n  Windup,\n  nextElement\n} from \"../Windup\";\nimport { onCharsFromWindup } from \"./OnChar\";\n\ntype WindupReducerState<M> = {\n  windup: Windup<string, M>;\n  didFinishOnce: boolean;\n};\n\ntype WindupReducerAction<M> =\n  | {\n      type: \"replace\";\n      windup: Windup<string, M>;\n    }\n  | {\n      type: \"next\";\n    }\n  | {\n      type: \"rewind\";\n    }\n  | {\n      type: \"fast-forward\";\n    }\n  | {\n      type: \"finish\";\n    };\n\nfunction initWindupState<M>(windup: Windup<string, M>): WindupReducerState<M> {\n  return { windup, didFinishOnce: false };\n}\n\ntype ReducerType<M> = (\n  prevState: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n) => WindupReducerState<M>;\n\nfunction windupReducer<M>(\n  state: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n): WindupReducerState<M> {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n    case \"next\":\n      return { ...state, windup: next(state.windup) };\n    case \"rewind\":\n      return { windup: rewind(state.windup), didFinishOnce: false };\n    case \"fast-forward\":\n      return { ...state, windup: fastForward(state.windup) };\n    case \"finish\":\n      return { ...state, didFinishOnce: true };\n    default:\n      return state;\n  }\n}\n\nexport interface HookMetadata {\n  onChar?: (char: string) => void;\n  pace?: (char: string, nextChar: string | undefined) => number;\n}\n\nexport default function useWindup<M extends HookMetadata>(\n  windupInit: Windup<string, M>,\n  options: {\n    onFinished?: () => void;\n    skipped?: boolean;\n  }\n): {\n  windup: Windup<string, M>;\n  skip: () => void;\n  rewind: () => void;\n  isFinished: boolean;\n} {\n  const [{ windup, didFinishOnce }, dispatch] = React.useReducer<\n    ReducerType<M>,\n    Windup<string, M>\n  >(windupReducer, windupInit, initWindupState);\n\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n  const windupIsFinished = isFinished(windup);\n\n  const skip = React.useCallback(() => {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n\n  const rewind = React.useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({ type: \"rewind\" });\n  }, []);\n\n  // If windup arg changes, we should reset\n  React.useEffect(() => {\n    dispatch({ type: \"replace\", windup: windupInit });\n  }, [windupInit]);\n\n  // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n  React.useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n    if (options.skipped === false) {\n      dispatch({ type: \"rewind\" });\n    }\n  }, [options.skipped]);\n\n  // When the windup changes, onChar should fire\n  React.useEffect(() => {\n    const onChars = onCharsFromWindup(windup);\n    const lastEl = lastPlayedElement(windup);\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(onChar => {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]);\n\n  // If windup finishes, the onFinished should fire\n  React.useEffect(() => {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      const timeout = setTimeout(() => {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n        dispatch({ type: \"finish\" });\n      }, 0);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]);\n\n  // the windup effect itself\n  React.useEffect(() => {\n    if (!windupIsFinished) {\n      const getPace = paceFromWindup(windup) || defaultGetPace;\n      const lastEl = lastPlayedElement(windup);\n      const nextEl = nextElement(windup);\n      timeoutRef.current = setTimeout(\n        () => {\n          dispatch({ type: \"next\" });\n        },\n        lastEl ? getPace(lastEl, nextEl) : 0\n      );\n      return () => {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n\n  return {\n    windup,\n    skip,\n    rewind,\n    isFinished: windupIsFinished\n  };\n}\n","import * as React from \"react\";\nimport { ChildrenMetadata, ChildrenWindup } from \"./WindupChildren\";\nimport { PlayedWindup, playedElements, isPlayedWindup } from \"../Windup\";\nimport { StringMetadata, StringWindup } from \"./useWindupString\";\n\nexport type PlayedChildrenWindup = PlayedWindup<string, ChildrenMetadata>;\nexport type PlayedStringWindup = PlayedWindup<string, StringMetadata>;\n\nexport function renderStringWindup(\n  windup: StringWindup | PlayedStringWindup\n): string {\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const inner = played.reduce((acc: string, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n\n  return inner;\n}\n\nconst VOID_TAGS = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n];\n\nexport function renderChildrenWindup(\n  windup: ChildrenWindup | PlayedChildrenWindup\n): React.ReactNode {\n  const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const Outer = metadata.element || React.Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  const inner = played.reduce((acc: React.ReactNode[], playedEl) => {\n    if (typeof playedEl === \"string\") {\n      const accButLast = acc.slice(0, acc.length - 1);\n      const last = acc[acc.length - 1];\n\n      return last && typeof last === \"string\"\n        ? [...accButLast, last + playedEl]\n        : [...acc, playedEl];\n    }\n\n    return [...acc, renderChildrenWindup(playedEl)];\n  }, []);\n\n  if (\n    typeof metadata.element === \"string\" &&\n    VOID_TAGS.includes(metadata.element)\n  ) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  return (\n    <Outer key={metadata.key} {...metadata.props}>\n      {inner}\n    </Outer>\n  );\n}\n","import * as React from \"react\";\nimport { windupFromString, Windup } from \"../Windup\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderStringWindup } from \"./renderWindup\";\n\nexport type WindupOptions = {\n  onChar?: (char: string) => void;\n  onFinished?: () => void;\n  pace?: (char: string) => number;\n  skipped?: boolean;\n};\n\nexport type StringMetadata = HookMetadata;\n\nexport type StringWindup = Windup<string, StringMetadata>;\n\nexport default function useWindupString(\n  text: string,\n  options: WindupOptions = {}\n): [\n  string,\n  {\n    skip: () => void;\n    rewind: () => void;\n    isFinished: boolean;\n  }\n] {\n  const windupInit = React.useMemo(() => {\n    return windupFromString<StringMetadata>(text, options);\n    // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  const { windup, skip, rewind, isFinished } = useWindup(windupInit, options);\n\n  const rendered = renderStringWindup(windup);\n  React.useDebugValue(rendered);\n\n  return [rendered, { skip, rewind, isFinished }];\n}\n","import * as React from \"react\";\n\ntype PauseProps = {\n  ms: number;\n};\n\nconst Pause: React.FC<PauseProps> = () => {\n  return null;\n};\n\nexport function isPauseElement(\n  element: React.ReactElement\n): element is React.ReactElement<PauseProps> {\n  return element.type === Pause;\n}\n\nexport default Pause;\n","import * as React from \"react\";\nimport {\n  newWindup,\n  Windup,\n  WindupMember,\n  windupFromString,\n  memberIsWindup\n} from \"../Windup\";\nimport { isPaceElement, isMsProp } from \"./Pace\";\nimport { isOnCharElement } from \"./OnChar\";\nimport { isPauseElement } from \"./Pause\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderChildrenWindup } from \"./renderWindup\";\n\nconst WindupContext = React.createContext({\n  skip: () => {\n    console.warn(\n      \"Tried to use the useSkip hook outside of a WindupChildren component!!\"\n    );\n  },\n  rewind: () => {\n    console.warn(\n      \"Tried to use the useRewind hook outside of a WindupChildren component!\"\n    );\n  },\n  isFinished: false\n});\n\nexport function useSkip() {\n  const { skip } = React.useContext(WindupContext);\n  return skip;\n}\n\nexport function useRewind() {\n  const { rewind } = React.useContext(WindupContext);\n  return rewind;\n}\n\nexport function useIsFinished() {\n  const { isFinished } = React.useContext(WindupContext);\n  return isFinished;\n}\n\nexport interface ChildrenMetadata extends HookMetadata {\n  element: React.ElementType | string | undefined;\n  props?: any;\n  ref?: any;\n  key?: string | number | null;\n}\n\nexport type ChildrenWindup = Windup<string, ChildrenMetadata>;\ntype ChildrenWindupMember = WindupMember<string, ChildrenMetadata>;\n\nfunction reduceWindupArgs(\n  prevArgs: ChildrenWindupMember[],\n  children: React.ReactNode\n) {\n  if (typeof children === \"string\") {\n    return [...prevArgs, ...children.split(\"\")];\n  }\n\n  if (typeof children === \"number\") {\n    return [...prevArgs, ...children.toString().split(\"\")];\n  }\n\n  if (!React.isValidElement(children)) {\n    return prevArgs;\n  }\n\n  const { children: childrenChildren, ...restProps } = children.props;\n\n  const paceMetaData = isPaceElement(children)\n    ? {\n        pace: (char: string) => {\n          if (isMsProp(children.props)) {\n            return children.props.ms;\n          }\n          return children.props.getPace(char);\n        }\n      }\n    : {};\n\n  const onCharMetaData = isOnCharElement(children)\n    ? {\n        onChar: children.props.fn\n      }\n    : {};\n\n  const keyProp = children.key ? { key: children.key } : {};\n\n  if (isPauseElement(children)) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: React.Fragment,\n        ...keyProp,\n        props: { children: undefined },\n        pace: () => children.props.ms\n      })\n    ];\n  }\n\n  if (childrenChildren === undefined) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { ...restProps, children: undefined },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(childrenChildren, {\n        element: children.type,\n        props: restProps,\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { children: childrenChildren, ...restProps },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  const newArgs: ChildrenWindupMember[] = React.Children.toArray(\n    childrenChildren\n  ).reduce(reduceWindupArgs, []);\n\n  const argsWithMetadata = newArgs.map(member => {\n    if (memberIsWindup(member)) {\n      const [played, remaining, metadata] = member;\n      return [\n        played,\n        remaining,\n        {\n          ...paceMetaData,\n          ...onCharMetaData,\n          ...metadata\n        }\n      ] as ChildrenWindupMember;\n    }\n    return member;\n  });\n\n  return [\n    ...prevArgs,\n    newWindup<string, ChildrenMetadata>(argsWithMetadata, {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })\n  ];\n}\n\ntype WindupChildrenProps = {\n  onFinished?: () => void;\n  skipped?: boolean;\n};\n\nfunction buildKeyString(children: React.ReactNode): string {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  const keys = React.Children.map(children, child => {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (React.isValidElement(child)) {\n      return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo<T>(factory: () => T, children: React.ReactNode) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoChildren = React.useMemo(factory, [buildKeyString(children)]);\n\n  return memoChildren;\n}\n\nconst WindupChildren: React.FC<WindupChildrenProps> = ({\n  children,\n  onFinished,\n  skipped\n}) => {\n  const windupInit = useChildrenMemo(() => {\n    return newWindup<string, ChildrenMetadata>(\n      React.Children.toArray(children).reduce(reduceWindupArgs, []),\n      { element: undefined }\n    );\n  }, children);\n\n  const { windup, skip, rewind, isFinished } = useWindup(windupInit, {\n    onFinished,\n    skipped\n  });\n\n  return (\n    <WindupContext.Provider\n      value={{\n        skip,\n        rewind,\n        isFinished\n      }}\n    >\n      {renderChildrenWindup(windup)}\n    </WindupContext.Provider>\n  );\n};\n\nexport default WindupChildren;\n","import * as React from \"react\";\n\ntype CharWrapperProps = {\n  element: React.ElementType;\n};\n\nfunction wrapChildren(children: React.ReactNode, Wrapper: React.ElementType) {\n  if (typeof children === \"string\") {\n    return children\n      .split(\"\")\n      .map((char, i) =>\n        char === \"\\n\" ? char : <Wrapper key={`${char}-${i}`}>{char}</Wrapper>\n      );\n  }\n\n  if (typeof children === \"number\") {\n    return children\n      .toString()\n      .split(\"\")\n      .map(char => <Wrapper>{char}</Wrapper>);\n  }\n\n  if (!React.isValidElement(children)) {\n    return <React.Fragment />;\n  }\n\n  if (children.props.children) {\n    const Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return <Outer key={children.key} {...children.props} />;\n    }\n\n    return (\n      <Outer key={children.key} {...children.props}>\n        {React.Children.map(children.props.children, ch => {\n          return wrapChildren(ch, Wrapper);\n        })}\n      </Outer>\n    );\n  }\n\n  return children;\n}\n\nconst CharWrapper: React.FC<CharWrapperProps> = ({ children, element }) => {\n  return (\n    <>\n      {React.Children.map(children, ch => {\n        return wrapChildren(ch, element);\n      })}\n    </>\n  );\n};\n\nexport default CharWrapper;\n","import * as React from \"react\";\nimport breakLines from \"break-styled-lines\";\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle: string) {\n  return (\n    descriptors: { text: string; font: string }[],\n    children: React.ReactNode\n  ): { text: string; font: string }[] => {\n    if (typeof children === \"string\") {\n      return [...descriptors, { text: children, font: defaultFontStyle }];\n    }\n\n    if (typeof children === \"number\") {\n      return [\n        ...descriptors,\n        { text: children.toString(), font: defaultFontStyle }\n      ];\n    }\n\n    if (!React.isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (\n      isStyledTextElement(children) &&\n      typeof children.props.children === \"string\"\n    ) {\n      return [\n        ...descriptors,\n        { text: children.props.children, font: children.props.fontStyle }\n      ];\n    }\n\n    if (isStyledTextElement(children)) {\n      return [\n        ...descriptors,\n        ...React.Children.toArray(children.props.children).reduce(\n          makeGetDescriptorsOfChildren(children.props.fontStyle),\n          []\n        )\n      ];\n    }\n\n    return [\n      ...descriptors,\n      ...React.Children.toArray(children.props.children).reduce(\n        makeGetDescriptorsOfChildren(defaultFontStyle),\n        []\n      )\n    ];\n  };\n}\n\nfunction reinsertStringsIntoChildren(\n  [accChildren, accStrings]: [React.ReactNode[], string[]],\n  children: React.ReactNode\n): [React.ReactNode[], string[]] {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    const [firstString, ...restStrings] = accStrings;\n    return [[...accChildren, firstString], restStrings];\n  }\n\n  if (!React.isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  const [subChildrenAcc, subStringsAcc] = React.Children.toArray(\n    children.props.children\n  ).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n\n  return [\n    [\n      ...accChildren,\n      React.cloneElement(children, {\n        children: subChildrenAcc\n      })\n    ],\n    subStringsAcc\n  ];\n}\n\ntype StyledTextProps = { children: React.ReactNode; fontStyle: string };\n\nfunction isStyledTextElement(\n  element: React.ReactElement\n): element is React.ReactElement<StyledTextProps> {\n  return element.type === StyledText;\n}\n\nexport function StyledText({ children }: StyledTextProps) {\n  return <>{children}</>;\n}\n\ntype LinebreakerProps = {\n  fontStyle: string;\n  width: number;\n};\n\nconst Linebreaker: React.FC<LinebreakerProps> = ({\n  children,\n  fontStyle,\n  width\n}) => {\n  // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  const childrenArray = React.Children.toArray(children);\n  const descriptors = childrenArray.reduce(\n    makeGetDescriptorsOfChildren(fontStyle),\n    []\n  );\n\n  const transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  const [\n    transformedChildren\n  ] = childrenArray.reduce(reinsertStringsIntoChildren, [\n    [],\n    transformedStrings\n  ]);\n\n  return <div style={{ whiteSpace: \"pre\" }}>{transformedChildren}</div>;\n};\n\nexport default Linebreaker;\n","import * as React from \"react\";\n\ntype EffectProps = {\n  fn: () => void;\n};\n\nconst Effect: React.FC<EffectProps> = ({ fn }) => {\n  React.useEffect(() => {\n    fn();\n    // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return null;\n};\n\nexport default Effect;\n","import * as React from \"react\";\n\nexport default function textFromChildren(children: React.ReactNode): string {\n  const text = React.Children.map(children, ch => {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!React.isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n"]},"metadata":{},"sourceType":"module"}