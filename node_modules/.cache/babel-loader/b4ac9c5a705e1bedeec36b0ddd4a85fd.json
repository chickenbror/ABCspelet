{"ast":null,"code":"/*\n  Rule templates that provide metadata for generating transformation rules\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar ruleTemplates = {\n  // Predicates as used in the English rules in data/English/tr_from_posjs.txt\n  'NEXT-TAG': {\n    // maps to the predicate function\n    function: nextTagIs,\n    // Minimum required space before or after current position to be a relevant predicate\n    window: [0, 1],\n    // The number of parameters the predicate takes\n    nrParameters: 1,\n    // Function that returns relevant values for parameter 1\n    parameter1Values: nextTagParameterValues\n  },\n  'NEXT-WORD-IS-CAP': {\n    function: nextWordIsCap,\n    window: [0, 1],\n    nrParameters: 0\n  },\n  'PREV-1-OR-2-OR-3-TAG': {\n    function: prev1Or2Or3Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  'PREV-1-OR-2-TAG': {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  'NEXT-WORD-IS-TAG': {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  'PREV-TAG': {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n\n  /*\n  \"CURRENT-WORD-IS-TAG\": {\n   \"function\": current_word_is_tag,\n   \"window\": [0],\n   \"nrParameter\": 1,\n   \"parameter1Values\": currentTagParameterValues\n   },\n  */\n  'PREV-WORD-IS-CAP': {\n    function: prevWordIsCap,\n    window: [-1, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-CAP': {\n    function: currentWordIsCap,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-NUMBER': {\n    function: currentWordIsNumber,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-URL': {\n    function: currentWordIsURL,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-ENDS-WITH': {\n    function: currentWordEndsWith,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordEndsWithParameterValues\n  },\n  'PREV-WORD-IS': {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  // Predicates as used in the Dutch rules in data/Dutch/brill_CONTEXTRULES.jg\n  PREVTAG: {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  NEXT1OR2TAG: {\n    function: next1Or2TagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2TagIsParameterValues\n  },\n  NEXTTAG: {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  PREV1OR2TAG: {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  WDAND2TAGAFT: {\n    function: currentWordAnd2TagAfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  NEXT1OR2OR3TAG: {\n    function: next1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the right\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2Or3TagParameterValues\n  },\n  CURWD: {\n    function: currentWordIs,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordParameterValues\n  },\n  SURROUNDTAG: {\n    function: surroundedByTags,\n    window: [-1, 1],\n    nrParameters: 2,\n    parameter1Values: prevTagParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2OR3TAG: {\n    function: prev1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the left\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  WDNEXTTAG: {\n    function: currentWordAndNextTagAre,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2WD: {\n    function: prev1Or2WordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2WordParameterValues\n  },\n  NEXTWD: {\n    function: nextWordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextWordParameterValues\n  },\n  PREVWD: {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  NEXT2TAG: {\n    function: next2TagIs,\n    window: [0, 2],\n    nrParameters: 1,\n    parameter1Values: next2TagParameterValues\n  },\n  WDAND2TAGBFR: {\n    function: currentWordAnd2TagBeforeAre,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagBeforeParameterValues\n  },\n  WDAND2AFT: {\n    function: currentWordAnd2AfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  WDPREVTAG: {\n    function: currentWordAndPrevTagAre,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  RBIGRAM: {\n    function: rightBigramIs,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextWordParameterValues\n  },\n  LBIGRAM: {\n    function: leftBigramIs,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: prevWordParameterValues,\n    parameter2Values: currentWordParameterValues\n  },\n  NEXTBIGRAM: {\n    function: nextBigramIs,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: nextWordParameterValues,\n    parameter2Values: twoWordAfterParameterValues\n  },\n  PREVBIGRAM: {\n    function: prevBigramIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoWordBeforeParameterValues,\n    parameter2Values: prevWordParameterValues\n  },\n  PREV2TAG: {\n    function: prev2TagIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoTagBeforeParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  NEXT1OR2WD: {\n    function: next1Or2WordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2WordParameterValues\n  },\n  DEFAULT: {\n    function: defaultPredicate,\n    window: [0, 0],\n    nrParameters: 0\n  }\n}; // ==================================\n// Predicates that start with words\n// ==================================\n\nfunction nextWordIsCap(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    var nextWord = sentence.taggedWords[i + 1].token;\n    return nextWord[0] === nextWord[0].toUpperCase();\n  }\n\n  return false;\n}\n\nfunction nextWordIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return sentence.taggedWords[i + 1].token === parameter;\n  }\n}\n\nfunction nextWordParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].token];\n  } else {\n    return [];\n  }\n}\n\nfunction prevWordIsCap(sentence, i, parameter) {\n  var prevWord = null;\n\n  if (i > 0) {\n    prevWord = sentence.taggedWords[i - 1].token;\n    return prevWord[0] === prevWord[0].toUpperCase();\n  }\n\n  return false;\n}\n\nfunction currentWordIsCap(sentence, i, parameter) {\n  var currentWord = sentence.taggedWords[i].token;\n  return currentWord[0] === currentWord[0].toUpperCase();\n}\n\nfunction currentWordParameterValues(sentence, i) {\n  return [sentence[i].token];\n}\n\nfunction currentWordIs(sentence, i, parameter) {\n  return sentence.taggedWords[i].token === parameter;\n}\n\nfunction isNumeric(num) {\n  return !isNaN(num);\n}\n\nfunction currentWordIsNumber(sentence, i, parameter) {\n  var isNumber = isNumeric(sentence.taggedWords[i].token); // Attempt to parse it as a float\n\n  if (!isNumber) {\n    isNumber = parseFloat(sentence.taggedWords[i].token);\n  }\n\n  return parameter === 'YES' ? isNumber : !isNumber;\n} // Checks if the current word is a url\n// Adapted from the original Javascript Brill tagger\n\n\nfunction currentWordIsURL(sentence, i, parameter) {\n  var isURL = false;\n\n  if (sentence.taggedWords[i].token.indexOf('.') > -1) {\n    // url if there are two contiguous alpha characters\n    if (/[a-zA-Z]{2}/.test(sentence.taggedWords[i].token)) {\n      isURL = true;\n    }\n  }\n\n  return parameter === 'YES' ? isURL : !isURL;\n}\n\nfunction currentWordAnd2TagAfterAre(sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 2) {\n    if (sentence.taggedWords[i + 2][1] === parameter2) {\n      return sentence.taggedWords[i].token === parameter1;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction twoTagAfterParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag];\n  } else {\n    return [];\n  }\n}\n\nfunction currentWordAndNextTagAre(sentence, i, parameter1, parameter2) {\n  var nextTag = false; // check current word\n\n  var currentWord = sentence.taggedWords[i].token === parameter1; // check next tag\n\n  if (i < sentence.taggedWords.length - 1) {\n    nextTag = sentence.taggedWords[i + 1].tag === parameter2;\n  }\n\n  return currentWord && nextTag;\n}\n\nfunction currentWordAndPrevTagAre(sentence, i, parameter1, parameter2) {\n  var prevTag = false; // check current word\n\n  var currentWord = sentence.taggedWords[i].token === parameter2; // check prev tag\n\n  if (i > 0) {\n    prevTag = sentence.taggedWords[i - 1].tag === parameter1;\n  }\n\n  return currentWord && prevTag;\n}\n\nfunction currentWordAnd2TagBeforeAre(sentence, i, parameter1, parameter2) {\n  var twoTagsBefore = false; // check current word\n\n  var currentWord = sentence.taggedWords[i].token === parameter2;\n\n  if (i > 1) {\n    // check two tags before\n    twoTagsBefore = sentence.taggedWords[i - 2].tag === parameter1;\n  }\n\n  return currentWord && twoTagsBefore;\n}\n\nfunction twoTagBeforeParameterValues(sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].tag];\n  } else {\n    return [];\n  }\n}\n\nfunction currentWordAnd2AfterAre(sentence, i, parameter1, parameter2) {\n  var twoWordsAfter = false; // check current word\n\n  var currentWord = sentence.taggedWords[i].token === parameter1;\n\n  if (i < sentence.taggedWords.length - 2) {\n    twoWordsAfter = sentence.taggedWords[i + 2].token === parameter2;\n  }\n\n  return currentWord && twoWordsAfter;\n}\n\nfunction prevWordIs(sentence, i, parameter) {\n  if (i > 0) {\n    return sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase();\n  } else {\n    return false;\n  }\n} // Returns the right value for parameter 1 of prevWordIs\n\n\nfunction prevWordParameterValues(sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].token];\n  } else {\n    return [];\n  }\n}\n\nfunction prev1Or2WordIs(sentence, i, parameter) {\n  var prev1 = false;\n  var prev2 = false;\n\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase();\n  }\n\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].token.toLowerCase() === parameter.toLowerCase();\n  }\n\n  return prev1 || prev2;\n}\n\nfunction prev1Or2WordParameterValues(sentence, i) {\n  var values = [];\n\n  if (i > 0) {\n    values.push(sentence[i - 1].token);\n  }\n\n  if (i > 1) {\n    values.push(sentence[i - 2].token);\n  }\n\n  return values;\n} // Indicates whether or not this string ends with the specified string.\n// Adapted from the original Javascript Brill tagger\n\n\nfunction currentWordEndsWith(sentence, i, parameter) {\n  var word = sentence.taggedWords[i].token;\n\n  if (!parameter || parameter.length > word.length) {\n    return false;\n  }\n\n  return word.indexOf(parameter) === word.length - parameter.length;\n} // sentence is an array of token records\n\n\nfunction currentWordEndsWithParameterValues(sentence, i) {\n  var values = ['ing'];\n  return values;\n}\n\nfunction rightBigramIs(sentence, i, parameter1, parameter2) {\n  var word1 = sentence.taggedWords[i].token === parameter1;\n  var word2 = false;\n\n  if (i < sentence.taggedWords.length - 1) {\n    word2 = sentence.taggedWords[i + 1].token === parameter2;\n  }\n\n  return word1 && word2;\n}\n\nfunction leftBigramIs(sentence, i, parameter1, parameter2) {\n  var word1 = false;\n  var word2 = sentence.taggedWords[i].token === parameter2;\n\n  if (i > 0) {\n    word1 = sentence.taggedWords[i - 1].token === parameter1;\n  }\n\n  return word1 && word2;\n}\n\nfunction nextBigramIs(sentence, i, parameter1, parameter2) {\n  var word1 = false;\n  var word2 = false;\n\n  if (i < sentence.taggedWords.length - 1) {\n    word1 = sentence.taggedWords[i + 1].token === parameter1;\n  }\n\n  if (i < sentence.taggedWords.length - 2) {\n    word2 = sentence.taggedWords[i + 2].token === parameter2;\n  }\n\n  return word1 && word2;\n}\n\nfunction twoWordAfterParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].token];\n  } else {\n    return [];\n  }\n}\n\nfunction prevBigramIs(sentence, i, parameter1, parameter2) {\n  var word1 = false;\n  var word2 = false;\n\n  if (i > 1) {\n    word1 = sentence.taggedWords[i - 2].token === parameter1;\n  }\n\n  if (i > 0) {\n    word2 = sentence.taggedWords[i - 1].token === parameter2;\n  }\n\n  return word1 && word2;\n}\n\nfunction twoWordBeforeParameterValues(sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].token];\n  } else {\n    return [];\n  }\n}\n\nfunction next1Or2WordIs(sentence, i, parameter1, parameter2) {\n  var next1 = false;\n  var next2 = false;\n\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = sentence.taggedWords[i + 1].token === parameter1;\n  }\n\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = sentence.taggedWords[i + 2].token === parameter2;\n  }\n\n  return next1 || next2;\n}\n\nfunction next1Or2WordParameterValues(sentence, i) {\n  var values = [];\n\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].token);\n  }\n\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].token);\n  }\n\n  return values;\n} // ==================================\n// Predicates about tags\n// ==================================\n\n\nfunction nextTagIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return sentence.taggedWords[i + 1].tag === parameter;\n  } else {\n    return false;\n  }\n}\n\nfunction nextTagParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].tag];\n  } else {\n    return [];\n  }\n}\n\nfunction next2TagIs(sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 2) {\n    return sentence.taggedWords[i + 2].tag === parameter;\n  } else {\n    return false;\n  }\n}\n\nfunction next2TagParameterValues(sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag];\n  } else {\n    return [];\n  }\n}\n\nfunction next1Or2TagIs(sentence, i, parameter) {\n  var next1 = false;\n  var next2 = false;\n\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = sentence.taggedWords[i + 1].tag === parameter;\n  }\n\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = sentence.taggedWords[i + 2].tag === parameter;\n  }\n\n  return next1 || next2;\n}\n\nfunction next1Or2TagIsParameterValues(sentence, i) {\n  var values = [];\n\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].tag);\n  }\n\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].tag);\n  }\n\n  return values;\n}\n\nfunction next1Or2Or3Tag(sentence, i, parameter) {\n  var next3 = false;\n\n  if (i < sentence.taggedWords.length - 3) {\n    next3 = sentence.taggedWords[i + 3].tag === parameter;\n  }\n\n  return next1Or2TagIs(sentence, i, parameter) || next3;\n}\n\nfunction next1Or2Or3TagParameterValues(sentence, i) {\n  var values = next1Or2TagIsParameterValues(sentence, i);\n\n  if (i < sentence.taggedWords.length - 3) {\n    values.push(sentence.taggedWords[i + 3].tag);\n  }\n\n  return values;\n}\n\nfunction surroundedByTags(sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 1) {\n    // check next tag\n    if (sentence.taggedWords[i + 1].tag === parameter2) {\n      // check previous tag\n      if (i > 0) {\n        return sentence.taggedWords[i - 1].tag === parameter1;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction prev1Or2Or3Tag(sentence, i, parameter) {\n  var prev3 = null;\n\n  if (i > 2) {\n    prev3 = sentence.taggedWords[i - 3].tag;\n  }\n\n  return prev1Or2Tag(sentence, i, parameter) || prev3 === parameter;\n}\n\nfunction prev1Or2Or3TagParameterValues(sentence, i) {\n  var values = prev1Or2TagParameterValues(sentence, i);\n\n  if (i > 2) {\n    values.push(sentence.taggedWords[i - 3].tag);\n  }\n\n  return values;\n}\n\nfunction prev1Or2Tag(sentence, i, parameter) {\n  var prev1 = null;\n\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].tag;\n  }\n\n  var prev2 = null;\n\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag;\n  }\n\n  return prev1 === parameter || prev2 === parameter;\n}\n\nfunction prev1Or2TagParameterValues(sentence, i) {\n  var values = [];\n\n  if (i > 0) {\n    values.push(sentence.taggedWords[i - 1].tag);\n  }\n\n  if (i > 1) {\n    values.push(sentence.taggedWords[i - 2].tag);\n  }\n\n  return values;\n}\n\nfunction prevTagIs(sentence, i, parameter) {\n  var prev = false;\n\n  if (i > 0) {\n    prev = sentence.taggedWords[i - 1].tag === parameter;\n  }\n\n  return prev;\n}\n\nfunction prevTagParameterValues(sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].tag];\n  } else {\n    return [];\n  }\n} // Looks like a useless predicate because transformation already take the\n// current tag into account\n\n/*\nfunction currentWordIsTag (sentence, i, parameter) {\n  return (sentence.taggedWords[i].tag === parameter)\n}\n*/\n\n\nfunction prev2TagIs(sentence, i, parameter) {\n  var prev2 = false;\n\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag === parameter;\n  }\n\n  return prev2;\n}\n\nfunction defaultPredicate(sentence, i, parameter) {\n  return false;\n}\n\nmodule.exports = ruleTemplates;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/RuleTemplates.js"],"names":["ruleTemplates","function","nextTagIs","window","nrParameters","parameter1Values","nextTagParameterValues","nextWordIsCap","prev1Or2Or3Tag","prev1Or2Or3TagParameterValues","prev1Or2Tag","prev1Or2TagParameterValues","prevTagIs","prevTagParameterValues","prevWordIsCap","currentWordIsCap","currentWordIsNumber","currentWordIsURL","currentWordEndsWith","currentWordEndsWithParameterValues","prevWordIs","prevWordParameterValues","PREVTAG","NEXT1OR2TAG","next1Or2TagIs","next1Or2TagIsParameterValues","NEXTTAG","PREV1OR2TAG","WDAND2TAGAFT","currentWordAnd2TagAfterAre","currentWordParameterValues","parameter2Values","twoTagAfterParameterValues","NEXT1OR2OR3TAG","next1Or2Or3Tag","next1Or2Or3TagParameterValues","CURWD","currentWordIs","SURROUNDTAG","surroundedByTags","PREV1OR2OR3TAG","WDNEXTTAG","currentWordAndNextTagAre","PREV1OR2WD","prev1Or2WordIs","prev1Or2WordParameterValues","NEXTWD","nextWordIs","nextWordParameterValues","PREVWD","NEXT2TAG","next2TagIs","next2TagParameterValues","WDAND2TAGBFR","currentWordAnd2TagBeforeAre","twoTagBeforeParameterValues","WDAND2AFT","currentWordAnd2AfterAre","WDPREVTAG","currentWordAndPrevTagAre","RBIGRAM","rightBigramIs","LBIGRAM","leftBigramIs","NEXTBIGRAM","nextBigramIs","twoWordAfterParameterValues","PREVBIGRAM","prevBigramIs","twoWordBeforeParameterValues","PREV2TAG","prev2TagIs","NEXT1OR2WD","next1Or2WordIs","next1Or2WordParameterValues","DEFAULT","defaultPredicate","sentence","i","parameter","taggedWords","length","nextWord","token","toUpperCase","prevWord","currentWord","isNumeric","num","isNaN","isNumber","parseFloat","isURL","indexOf","test","parameter1","parameter2","tag","nextTag","prevTag","twoTagsBefore","twoWordsAfter","toLowerCase","prev1","prev2","values","push","word","word1","word2","next1","next2","next3","prev3","prev","module","exports"],"mappings":"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","sourcesContent":["/*\n  Rule templates that provide metadata for generating transformation rules\n  Copyright (C) 2017 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst ruleTemplates = {\n  // Predicates as used in the English rules in data/English/tr_from_posjs.txt\n  'NEXT-TAG': {\n    // maps to the predicate function\n    function: nextTagIs,\n    // Minimum required space before or after current position to be a relevant predicate\n    window: [0, 1],\n    // The number of parameters the predicate takes\n    nrParameters: 1,\n    // Function that returns relevant values for parameter 1\n    parameter1Values: nextTagParameterValues\n  },\n  'NEXT-WORD-IS-CAP': {\n    function: nextWordIsCap,\n    window: [0, 1],\n    nrParameters: 0\n  },\n  'PREV-1-OR-2-OR-3-TAG': {\n    function: prev1Or2Or3Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  'PREV-1-OR-2-TAG': {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  'NEXT-WORD-IS-TAG': {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  'PREV-TAG': {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  /*\n \"CURRENT-WORD-IS-TAG\": {\n   \"function\": current_word_is_tag,\n   \"window\": [0],\n   \"nrParameter\": 1,\n   \"parameter1Values\": currentTagParameterValues\n   },\n  */\n  'PREV-WORD-IS-CAP': {\n    function: prevWordIsCap,\n    window: [-1, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-CAP': {\n    function: currentWordIsCap,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-NUMBER': {\n    function: currentWordIsNumber,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-IS-URL': {\n    function: currentWordIsURL,\n    window: [0, 0],\n    nrParameters: 0\n  },\n  'CURRENT-WORD-ENDS-WITH': {\n    function: currentWordEndsWith,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordEndsWithParameterValues\n  },\n  'PREV-WORD-IS': {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n\n  // Predicates as used in the Dutch rules in data/Dutch/brill_CONTEXTRULES.jg\n  PREVTAG: {\n    function: prevTagIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevTagParameterValues\n  },\n  NEXT1OR2TAG: {\n    function: next1Or2TagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2TagIsParameterValues\n  },\n  NEXTTAG: {\n    function: nextTagIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextTagParameterValues\n  },\n  PREV1OR2TAG: {\n    function: prev1Or2Tag,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2TagParameterValues\n  },\n  WDAND2TAGAFT: {\n    function: currentWordAnd2TagAfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  NEXT1OR2OR3TAG: {\n    function: next1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the right\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2Or3TagParameterValues\n  },\n  CURWD: {\n    function: currentWordIs,\n    window: [0, 0],\n    nrParameters: 1,\n    parameter1Values: currentWordParameterValues\n  },\n  SURROUNDTAG: {\n    function: surroundedByTags,\n    window: [-1, 1],\n    nrParameters: 2,\n    parameter1Values: prevTagParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2OR3TAG: {\n    function: prev1Or2Or3Tag,\n    // Minimum required window to apply this template is one tag to the left\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2Or3TagParameterValues\n  },\n  WDNEXTTAG: {\n    function: currentWordAndNextTagAre,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextTagParameterValues\n  },\n  PREV1OR2WD: {\n    function: prev1Or2WordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prev1Or2WordParameterValues\n  },\n  NEXTWD: {\n    function: nextWordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: nextWordParameterValues\n  },\n  PREVWD: {\n    function: prevWordIs,\n    window: [-1, 0],\n    nrParameters: 1,\n    parameter1Values: prevWordParameterValues\n  },\n  NEXT2TAG: {\n    function: next2TagIs,\n    window: [0, 2],\n    nrParameters: 1,\n    parameter1Values: next2TagParameterValues\n  },\n  WDAND2TAGBFR: {\n    function: currentWordAnd2TagBeforeAre,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagBeforeParameterValues\n  },\n  WDAND2AFT: {\n    function: currentWordAnd2AfterAre,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: twoTagAfterParameterValues\n  },\n  WDPREVTAG: {\n    function: currentWordAndPrevTagAre,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  RBIGRAM: {\n    function: rightBigramIs,\n    window: [0, 1],\n    nrParameters: 2,\n    parameter1Values: currentWordParameterValues,\n    parameter2Values: nextWordParameterValues\n  },\n  LBIGRAM: {\n    function: leftBigramIs,\n    window: [-1, 0],\n    nrParameters: 2,\n    parameter1Values: prevWordParameterValues,\n    parameter2Values: currentWordParameterValues\n  },\n  NEXTBIGRAM: {\n    function: nextBigramIs,\n    window: [0, 2],\n    nrParameters: 2,\n    parameter1Values: nextWordParameterValues,\n    parameter2Values: twoWordAfterParameterValues\n  },\n  PREVBIGRAM: {\n    function: prevBigramIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoWordBeforeParameterValues,\n    parameter2Values: prevWordParameterValues\n  },\n  PREV2TAG: {\n    function: prev2TagIs,\n    window: [-2, 0],\n    nrParameters: 2,\n    parameter1Values: twoTagBeforeParameterValues,\n    parameter2Values: prevTagParameterValues\n  },\n  NEXT1OR2WD: {\n    function: next1Or2WordIs,\n    window: [0, 1],\n    nrParameters: 1,\n    parameter1Values: next1Or2WordParameterValues\n  },\n  DEFAULT: {\n    function: defaultPredicate,\n    window: [0, 0],\n    nrParameters: 0\n  }\n}\n\n// ==================================\n// Predicates that start with words\n// ==================================\nfunction nextWordIsCap (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    const nextWord = sentence.taggedWords[i + 1].token\n    return (nextWord[0] === nextWord[0].toUpperCase())\n  }\n  return (false)\n}\n\nfunction nextWordIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return (sentence.taggedWords[i + 1].token === parameter)\n  }\n}\n\nfunction nextWordParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].token]\n  } else {\n    return []\n  }\n}\n\nfunction prevWordIsCap (sentence, i, parameter) {\n  let prevWord = null\n  if (i > 0) {\n    prevWord = sentence.taggedWords[i - 1].token\n    return (prevWord[0] === prevWord[0].toUpperCase())\n  }\n  return (false)\n}\n\nfunction currentWordIsCap (sentence, i, parameter) {\n  const currentWord = sentence.taggedWords[i].token\n  return (currentWord[0] === currentWord[0].toUpperCase())\n}\n\nfunction currentWordParameterValues (sentence, i) {\n  return [sentence[i].token]\n}\n\nfunction currentWordIs (sentence, i, parameter) {\n  return (sentence.taggedWords[i].token === parameter)\n}\n\nfunction isNumeric (num) {\n  return (!isNaN(num))\n}\n\nfunction currentWordIsNumber (sentence, i, parameter) {\n  let isNumber = isNumeric(sentence.taggedWords[i].token)\n  // Attempt to parse it as a float\n  if (!isNumber) {\n    isNumber = parseFloat(sentence.taggedWords[i].token)\n  }\n  return ((parameter === 'YES') ? isNumber : !isNumber)\n}\n\n// Checks if the current word is a url\n// Adapted from the original Javascript Brill tagger\nfunction currentWordIsURL (sentence, i, parameter) {\n  let isURL = false\n  if (sentence.taggedWords[i].token.indexOf('.') > -1) {\n    // url if there are two contiguous alpha characters\n    if (/[a-zA-Z]{2}/.test(sentence.taggedWords[i].token)) {\n      isURL = true\n    }\n  }\n  return ((parameter === 'YES') ? isURL : !isURL)\n}\n\nfunction currentWordAnd2TagAfterAre (sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 2) {\n    if (sentence.taggedWords[i + 2][1] === parameter2) {\n      return (sentence.taggedWords[i].token === parameter1)\n    } else {\n      return (false)\n    }\n  } else {\n    return (false)\n  }\n}\n\nfunction twoTagAfterParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction currentWordAndNextTagAre (sentence, i, parameter1, parameter2) {\n  let nextTag = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter1)\n  // check next tag\n  if (i < sentence.taggedWords.length - 1) {\n    nextTag = (sentence.taggedWords[i + 1].tag === parameter2)\n  }\n  return (currentWord && nextTag)\n}\n\nfunction currentWordAndPrevTagAre (sentence, i, parameter1, parameter2) {\n  let prevTag = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter2)\n  // check prev tag\n  if (i > 0) {\n    prevTag = (sentence.taggedWords[i - 1].tag === parameter1)\n  }\n  return (currentWord && prevTag)\n}\n\nfunction currentWordAnd2TagBeforeAre (sentence, i, parameter1, parameter2) {\n  let twoTagsBefore = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter2)\n  if (i > 1) {\n    // check two tags before\n    twoTagsBefore = (sentence.taggedWords[i - 2].tag === parameter1)\n  }\n  return (currentWord && twoTagsBefore)\n}\n\nfunction twoTagBeforeParameterValues (sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction currentWordAnd2AfterAre (sentence, i, parameter1, parameter2) {\n  let twoWordsAfter = false\n  // check current word\n  const currentWord = (sentence.taggedWords[i].token === parameter1)\n  if (i < sentence.taggedWords.length - 2) {\n    twoWordsAfter = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (currentWord && twoWordsAfter)\n}\n\nfunction prevWordIs (sentence, i, parameter) {\n  if (i > 0) {\n    return (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())\n  } else {\n    return (false)\n  }\n}\n\n// Returns the right value for parameter 1 of prevWordIs\nfunction prevWordParameterValues (sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].token]\n  } else {\n    return []\n  }\n}\n\nfunction prev1Or2WordIs (sentence, i, parameter) {\n  let prev1 = false\n  let prev2 = false\n  if (i > 0) {\n    prev1 = (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())\n  }\n  if (i > 1) {\n    prev2 = (sentence.taggedWords[i - 2].token.toLowerCase() === parameter.toLowerCase())\n  }\n  return (prev1 || prev2)\n}\n\nfunction prev1Or2WordParameterValues (sentence, i) {\n  const values = []\n  if (i > 0) {\n    values.push(sentence[i - 1].token)\n  }\n  if (i > 1) {\n    values.push(sentence[i - 2].token)\n  }\n  return values\n}\n\n// Indicates whether or not this string ends with the specified string.\n// Adapted from the original Javascript Brill tagger\nfunction currentWordEndsWith (sentence, i, parameter) {\n  const word = sentence.taggedWords[i].token\n  if (!parameter || (parameter.length > word.length)) {\n    return false\n  }\n  return (word.indexOf(parameter) === (word.length - parameter.length))\n}\n\n// sentence is an array of token records\nfunction currentWordEndsWithParameterValues (sentence, i) {\n  const values = ['ing']\n\n  return values\n}\n\nfunction rightBigramIs (sentence, i, parameter1, parameter2) {\n  const word1 = (sentence.taggedWords[i].token === parameter1)\n  let word2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    word2 = (sentence.taggedWords[i + 1].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction leftBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  const word2 = (sentence.taggedWords[i].token === parameter2)\n  if (i > 0) {\n    word1 = (sentence.taggedWords[i - 1].token === parameter1)\n  }\n  return (word1 && word2)\n}\n\nfunction nextBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  let word2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    word1 = (sentence.taggedWords[i + 1].token === parameter1)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    word2 = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction twoWordAfterParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].token]\n  } else {\n    return []\n  }\n}\n\nfunction prevBigramIs (sentence, i, parameter1, parameter2) {\n  let word1 = false\n  let word2 = false\n  if (i > 1) {\n    word1 = (sentence.taggedWords[i - 2].token === parameter1)\n  }\n  if (i > 0) {\n    word2 = (sentence.taggedWords[i - 1].token === parameter2)\n  }\n  return (word1 && word2)\n}\n\nfunction twoWordBeforeParameterValues (sentence, i) {\n  if (i > 1) {\n    return [sentence.taggedWords[i - 2].token]\n  } else {\n    return []\n  }\n}\n\nfunction next1Or2WordIs (sentence, i, parameter1, parameter2) {\n  let next1 = false\n  let next2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = (sentence.taggedWords[i + 1].token === parameter1)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = (sentence.taggedWords[i + 2].token === parameter2)\n  }\n  return (next1 || next2)\n}\n\nfunction next1Or2WordParameterValues (sentence, i) {\n  const values = []\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].token)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].token)\n  }\n  return values\n}\n\n// ==================================\n// Predicates about tags\n// ==================================\nfunction nextTagIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 1) {\n    return (sentence.taggedWords[i + 1].tag === parameter)\n  } else {\n    return (false)\n  }\n}\n\nfunction nextTagParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 1) {\n    return [sentence.taggedWords[i + 1].tag]\n  } else {\n    return []\n  }\n}\n\nfunction next2TagIs (sentence, i, parameter) {\n  if (i < sentence.taggedWords.length - 2) {\n    return (sentence.taggedWords[i + 2].tag === parameter)\n  } else {\n    return (false)\n  }\n}\n\nfunction next2TagParameterValues (sentence, i) {\n  if (i < sentence.taggedWords.length - 2) {\n    return [sentence.taggedWords[i + 2].tag]\n  } else {\n    return []\n  }\n}\n\nfunction next1Or2TagIs (sentence, i, parameter) {\n  let next1 = false\n  let next2 = false\n  if (i < sentence.taggedWords.length - 1) {\n    next1 = (sentence.taggedWords[i + 1].tag === parameter)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    next2 = (sentence.taggedWords[i + 2].tag === parameter)\n  }\n  return (next1 || next2)\n}\n\nfunction next1Or2TagIsParameterValues (sentence, i) {\n  const values = []\n  if (i < sentence.taggedWords.length - 1) {\n    values.push(sentence.taggedWords[i + 1].tag)\n  }\n  if (i < sentence.taggedWords.length - 2) {\n    values.push(sentence.taggedWords[i + 2].tag)\n  }\n  return values\n}\n\nfunction next1Or2Or3Tag (sentence, i, parameter) {\n  let next3 = false\n  if (i < sentence.taggedWords.length - 3) {\n    next3 = (sentence.taggedWords[i + 3].tag === parameter)\n  }\n  return (next1Or2TagIs(sentence, i, parameter) || next3)\n}\n\nfunction next1Or2Or3TagParameterValues (sentence, i) {\n  const values = next1Or2TagIsParameterValues(sentence, i)\n  if (i < sentence.taggedWords.length - 3) {\n    values.push(sentence.taggedWords[i + 3].tag)\n  }\n  return values\n}\n\nfunction surroundedByTags (sentence, i, parameter1, parameter2) {\n  if (i < sentence.taggedWords.length - 1) {\n    // check next tag\n    if (sentence.taggedWords[i + 1].tag === parameter2) {\n      // check previous tag\n      if (i > 0) {\n        return (sentence.taggedWords[i - 1].tag === parameter1)\n      } else {\n        return (false)\n      }\n    } else {\n      return (false)\n    }\n  } else {\n    return (false)\n  }\n}\n\nfunction prev1Or2Or3Tag (sentence, i, parameter) {\n  let prev3 = null\n  if (i > 2) {\n    prev3 = sentence.taggedWords[i - 3].tag\n  }\n  return (prev1Or2Tag(sentence, i, parameter) || (prev3 === parameter))\n}\n\nfunction prev1Or2Or3TagParameterValues (sentence, i) {\n  const values = prev1Or2TagParameterValues(sentence, i)\n  if (i > 2) {\n    values.push(sentence.taggedWords[i - 3].tag)\n  }\n  return values\n}\n\nfunction prev1Or2Tag (sentence, i, parameter) {\n  let prev1 = null\n  if (i > 0) {\n    prev1 = sentence.taggedWords[i - 1].tag\n  }\n  let prev2 = null\n  if (i > 1) {\n    prev2 = sentence.taggedWords[i - 2].tag\n  }\n  return ((prev1 === parameter) || (prev2 === parameter))\n}\n\nfunction prev1Or2TagParameterValues (sentence, i) {\n  const values = []\n  if (i > 0) {\n    values.push(sentence.taggedWords[i - 1].tag)\n  }\n  if (i > 1) {\n    values.push(sentence.taggedWords[i - 2].tag)\n  }\n  return values\n}\n\nfunction prevTagIs (sentence, i, parameter) {\n  let prev = false\n  if (i > 0) {\n    prev = (sentence.taggedWords[i - 1].tag === parameter)\n  }\n  return (prev)\n}\n\nfunction prevTagParameterValues (sentence, i) {\n  if (i > 0) {\n    return [sentence.taggedWords[i - 1].tag]\n  } else {\n    return []\n  }\n}\n\n// Looks like a useless predicate because transformation already take the\n// current tag into account\n/*\nfunction currentWordIsTag (sentence, i, parameter) {\n  return (sentence.taggedWords[i].tag === parameter)\n}\n*/\n\nfunction prev2TagIs (sentence, i, parameter) {\n  let prev2 = false\n  if (i > 1) {\n    prev2 = (sentence.taggedWords[i - 2].tag === parameter)\n  }\n  return (prev2)\n}\n\nfunction defaultPredicate (sentence, i, parameter) {\n  return (false)\n}\n\nmodule.exports = ruleTemplates\n"]},"metadata":{},"sourceType":"script"}