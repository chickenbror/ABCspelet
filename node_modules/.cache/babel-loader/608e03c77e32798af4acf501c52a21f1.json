{"ast":null,"code":"/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar englishLexicon = require('../data/English/lexicon_from_posjs.json');\n\nvar dutchLexicon = require('../data/Dutch/brill_Lexicon.json');\n\nvar DEBUG = false; // Constructor creates a Lexicon for language\n\nfunction Lexicon(language, defaultCategory, defaultCategoryCapitalised) {\n  switch (language) {\n    case 'EN':\n      this.lexicon = englishLexicon;\n      break;\n\n    case 'DU':\n      this.lexicon = dutchLexicon;\n      break;\n\n    default:\n      this.lexicon = dutchLexicon;\n      break;\n  }\n\n  if (defaultCategory) {\n    this.defaultCategory = defaultCategory;\n\n    if (defaultCategoryCapitalised) {\n      this.defaultCategoryCapitalised = defaultCategoryCapitalised;\n    }\n  }\n} // Parses a lexicon in text format: word cat1 cat2 ... catn\n\n\nLexicon.prototype.parseLexicon = function (data) {\n  // Split into an array of non-empty lines\n  var arrayOfLines = data.match(/[^\\r\\n]+/g);\n  this.lexicon = {}; // Object.create(null);\n\n  var that = this;\n  arrayOfLines.forEach(function (line) {\n    // Split line by whitespace\n    var elements = line.trim().split(/\\s+/);\n\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1);\n    }\n  });\n};\n\nLexicon.prototype.tagWordWithDefaults = function (word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised;\n  } else {\n    // If not found assign default_category\n    return this.defaultCategory;\n  }\n}; // Returns a list of categories for word\n\n\nLexicon.prototype.tagWord = function (word) {\n  var categories = this.lexicon[word];\n  DEBUG && console.log(categories);\n\n  if (!categories || typeof categories === 'function') {\n    categories = this.lexicon[word.toLowerCase()];\n  }\n\n  if (!categories || typeof categories === 'function') {\n    categories = [this.tagWordWithDefaults(word)];\n  }\n\n  return categories;\n}; // Adds a word to the lexicon. NB simply replaces the entry\n\n\nLexicon.prototype.addWord = function (word, categories) {\n  this.lexicon[word] = categories;\n};\n\nLexicon.prototype.prettyPrint = function () {\n  var result = '';\n  var that = this;\n  Object.keys(this.lexicon).forEach(function (token) {\n    result += token + '\\t';\n    that.lexicon[token].forEach(function (cat) {\n      result += cat + '\\t';\n    });\n    result += '\\n';\n  });\n  return result;\n};\n\nLexicon.prototype.nrEntries = function () {\n  return Object.keys(this.lexicon).length;\n};\n\nLexicon.prototype.size = function () {\n  return this.nrEntries();\n};\n\nLexicon.prototype.setDefaultCategories = function (category, categoryCapitalised) {\n  this.defaultCategory = category;\n\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised;\n  }\n};\n\nmodule.exports = Lexicon;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/brill_pos_tagger/lib/Lexicon.js"],"names":["englishLexicon","require","dutchLexicon","DEBUG","Lexicon","language","defaultCategory","defaultCategoryCapitalised","lexicon","prototype","parseLexicon","data","arrayOfLines","match","that","forEach","line","elements","trim","split","length","slice","tagWordWithDefaults","word","test","tagWord","categories","console","log","toLowerCase","addWord","prettyPrint","result","Object","keys","token","cat","nrEntries","size","setDefaultCategories","category","categoryCapitalised","module","exports"],"mappings":"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","sourcesContent":["/*\n  Lexicon class\n  Copyright (C) 2019 Hugo W.L. ter Doest\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst englishLexicon = require('../data/English/lexicon_from_posjs.json')\nconst dutchLexicon = require('../data/Dutch/brill_Lexicon.json')\n\nconst DEBUG = false\n\n// Constructor creates a Lexicon for language\nfunction Lexicon (language, defaultCategory, defaultCategoryCapitalised) {\n  switch (language) {\n    case 'EN':\n      this.lexicon = englishLexicon\n      break\n    case 'DU':\n      this.lexicon = dutchLexicon\n      break\n    default:\n      this.lexicon = dutchLexicon\n      break\n  }\n  if (defaultCategory) {\n    this.defaultCategory = defaultCategory\n    if (defaultCategoryCapitalised) {\n      this.defaultCategoryCapitalised = defaultCategoryCapitalised\n    }\n  }\n}\n\n// Parses a lexicon in text format: word cat1 cat2 ... catn\nLexicon.prototype.parseLexicon = function (data) {\n  // Split into an array of non-empty lines\n  const arrayOfLines = data.match(/[^\\r\\n]+/g)\n  this.lexicon = {} // Object.create(null);\n  const that = this\n  arrayOfLines.forEach(function (line) {\n    // Split line by whitespace\n    const elements = line.trim().split(/\\s+/)\n    if (elements.length > 0) {\n      that.lexicon[elements[0]] = elements.slice(1)\n    }\n  })\n}\n\nLexicon.prototype.tagWordWithDefaults = function (word) {\n  if (/[A-Z]/.test(word[0]) && this.defaultCategoryCapitalised) {\n    // Capitalised\n    return this.defaultCategoryCapitalised\n  } else {\n    // If not found assign default_category\n    return this.defaultCategory\n  }\n}\n\n// Returns a list of categories for word\nLexicon.prototype.tagWord = function (word) {\n  let categories = this.lexicon[word]\n  DEBUG && console.log(categories)\n  if (!categories || (typeof categories === 'function')) {\n    categories = this.lexicon[word.toLowerCase()]\n  }\n  if (!categories || (typeof categories === 'function')) {\n    categories = [this.tagWordWithDefaults(word)]\n  }\n  return (categories)\n}\n\n// Adds a word to the lexicon. NB simply replaces the entry\nLexicon.prototype.addWord = function (word, categories) {\n  this.lexicon[word] = categories\n}\n\nLexicon.prototype.prettyPrint = function () {\n  let result = ''\n  const that = this\n  Object.keys(this.lexicon).forEach(function (token) {\n    result += token + '\\t'\n    that.lexicon[token].forEach(function (cat) {\n      result += cat + '\\t'\n    })\n    result += '\\n'\n  })\n  return result\n}\n\nLexicon.prototype.nrEntries = function () {\n  return Object.keys(this.lexicon).length\n}\n\nLexicon.prototype.size = function () {\n  return this.nrEntries()\n}\n\nLexicon.prototype.setDefaultCategories = function (category, categoryCapitalised) {\n  this.defaultCategory = category\n  if (categoryCapitalised) {\n    this.defaultCategoryCapitalised = categoryCapitalised\n  }\n}\n\nmodule.exports = Lexicon\n"]},"metadata":{},"sourceType":"script"}