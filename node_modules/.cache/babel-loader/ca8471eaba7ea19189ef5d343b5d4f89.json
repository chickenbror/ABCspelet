{"ast":null,"code":"/*\nCopyright (c) 2018, Hugo W.L. ter Doest\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\n * Spec for the Dutch Porter Stemmer can be found at:\n * http://snowball.tartarus.org/algorithms/dutch/stemmer.html\n */\n'use strict';\n\nvar _classCallCheck = require(\"C:/CodingProjects/ABCspelet/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/CodingProjects/ABCspelet/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/CodingProjects/ABCspelet/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/CodingProjects/ABCspelet/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Stemmer = require('./stemmer_nl');\n\nvar DEBUG = false;\nvar vowels = 'aeiouèy';\n\nfunction isVowel(x) {\n  return vowels.indexOf(x) > -1;\n} // * Return longest matching suffixes for a token or '' if no suffix match\n\n\nfunction endsinArr(str, suffixes) {\n  var i;\n  var longest = '';\n\n  for (i = 0; i < suffixes.length; i++) {\n    if (endsin(str, suffixes[i]) && suffixes[i].length > longest.length) {\n      longest = suffixes[i];\n    }\n  }\n\n  if (DEBUG && longest !== '') {\n    console.log('Matched suffix: ' + longest);\n  }\n\n  return longest;\n} // Returns true if token has suffix\n\n\nfunction endsin(str, suffix) {\n  if (str.length < suffix.length) return false;\n  return str.slice(-suffix.length) === suffix;\n} // Removes a suffix of len characters and returns the string\n\n\nfunction removeSuffix(str, len) {\n  return str.substr(0, str.length - len);\n} // Define undoubling the ending as removing the last letter if the word ends kk, dd or tt.\n\n\nfunction undoubleEnding(str) {\n  if (str.substr(-2) === 'kk' || str.substr(-2) === 'tt' || str.substr(-2) === 'dd') {\n    return str.substr(0, str.length - 1);\n  } else {\n    return str;\n  }\n}\n\nvar PorterStemmer = /*#__PURE__*/function (_Stemmer) {\n  _inherits(PorterStemmer, _Stemmer);\n\n  var _super = _createSuper(PorterStemmer);\n\n  function PorterStemmer() {\n    _classCallCheck(this, PorterStemmer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PorterStemmer, [{\n    key: \"replaceAccentedCharacters\",\n    value: function replaceAccentedCharacters(word) {\n      var accentedCharactersMapping = {\n        ä: 'a',\n        ë: 'e',\n        ï: 'i',\n        ö: 'o',\n        ü: 'u',\n        á: 'a',\n        é: 'e',\n        í: 'i',\n        ó: 'o',\n        ú: 'u'\n      };\n      var result = word;\n\n      for (var x in accentedCharactersMapping) {\n        result = result.replace(new RegExp(x, 'g'), accentedCharactersMapping[x]);\n      }\n\n      if (DEBUG) {\n        console.log('replaceAccentedCharacters: ' + result);\n      }\n\n      return result;\n    } // Put initial y, y after a vowel, and i between vowels into upper case.\n\n  }, {\n    key: \"handleYI\",\n    value: function handleYI(word) {\n      // Initial y\n      var result = word.replace(/^y/, 'Y');\n\n      if (DEBUG) {\n        console.log('handleYI: initial y: ' + result);\n      } // y after vowel\n\n\n      result = result.replace(/([aeioué])y/g, '$1Y');\n\n      if (DEBUG) {\n        console.log('handleYI: y after vowel: ' + result);\n      } // i between vowels\n\n\n      result = result.replace(/([aeioué])i([aeioué])/g, '$1I$2');\n\n      if (DEBUG) {\n        console.log('handleYI: i between vowels:' + result);\n      }\n\n      return result;\n    } // Determines R1 and R2; adapted from the French Porter Stemmer\n\n  }, {\n    key: \"markRegions\",\n    value: function markRegions(token) {\n      var r1, r2, len;\n      r1 = r2 = len = token.length; // R1 is the region after the first non-vowel following a vowel,\n\n      for (var i = 0; i < len - 1 && r1 === len; i++) {\n        if (isVowel(token[i]) && !isVowel(token[i + 1])) {\n          r1 = i + 2;\n        }\n      } // Or is the null region at the end of the word if there is no such non-vowel.\n      // R1 is adjusted such that the region before it contains at least 3 characters\n\n\n      if (r1 !== len) {\n        // R1 is not null\n        if (r1 < 3) {\n          // Region before does not contain at least 3 characters\n          if (len > 3) {\n            r1 = 3; // Now R1 contains at least 3 characters\n          } else {\n            // It is not possible to make the region before long enough\n            r1 = len;\n          }\n        }\n      } // R2 is the region after the first non-vowel following a vowel in R1\n\n\n      for (var _i = r1; _i < len - 1 && r2 === len; _i++) {\n        if (isVowel(token[_i]) && !isVowel(token[_i + 1])) {\n          r2 = _i + 2;\n        }\n      } // Or is the null region at the end of the word if there is no such non-vowel.\n\n\n      if (DEBUG) {\n        console.log('Regions r1 = ' + r1 + ' r2 = ' + r2);\n      }\n\n      this.r1 = r1;\n      this.r2 = r2;\n    }\n  }, {\n    key: \"prelude\",\n    value: function prelude(word) {\n      var result = this.replaceAccentedCharacters(word);\n      result = this.handleYI(result);\n      this.markRegions(result);\n\n      if (DEBUG) {\n        console.log('Prelude: ' + result);\n      }\n\n      return result;\n    } // (1b) en   ene => delete if in R1 and preceded by a valid en-ending, and then undouble the ending\n    // Define a valid en-ending as a non-vowel, and not gem.\n    // Define undoubling the ending as removing the last letter if the word ends kk, dd or tt.\n\n  }, {\n    key: \"step1b\",\n    value: function step1b(word, suffixes) {\n      var result = word;\n      var match = endsinArr(result, suffixes);\n\n      if (match !== '') {\n        var pos = result.length - match.length;\n\n        if (pos >= this.r1) {\n          // check the character before the matched en/ene AND check for gem\n          if (!isVowel(result[pos - 1]) && result.substr(pos - 3, 3) !== 'gem') {\n            // delete\n            result = removeSuffix(result, match.length); // Undouble the ending\n\n            result = undoubleEnding(result);\n          }\n        }\n      }\n\n      if (DEBUG) {\n        console.log('step 1b: ' + result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"step1\",\n    value: function step1(word) {\n      var result = word; // (1a) heden => replace with heid if in R1\n\n      if (endsin(result, 'heden') && result.length - 5 >= this.r1) {\n        result = removeSuffix(result, 5);\n        result += 'heid';\n      }\n\n      if (DEBUG) {\n        console.log('step 1a: ' + result);\n      }\n\n      result = this.step1b(result, ['en', 'ene']); // (1c) s   se => delete if in R1 and preceded by a valid s-ending\n      // Define a valid s-ending as a non-vowel other than j.\n\n      var match = endsinArr(result, ['se', 's']);\n\n      if (match !== '') {\n        var pos = result.length - match.length;\n\n        if (pos >= this.r1) {\n          // check the character before the matched s/se\n          // HtD: if there is a s before the s/se the suffix should stay\n          // if (!isVowel(result[pos - 1]) && result[pos - 1] != \"j\") {\n          if (!isVowel(result[pos - 1]) && !result.match(/[js]se?$/)) {\n            result = removeSuffix(result, match.length);\n          }\n        }\n      }\n\n      if (DEBUG) {\n        console.log('step 1c: ' + result);\n      }\n\n      return result;\n    } // Delete suffix e if in R1 and preceded by a non-vowel, and then undouble the ending\n\n  }, {\n    key: \"step2\",\n    value: function step2(word) {\n      var result = word;\n\n      if (endsin(result, 'e') && this.r1 < result.length) {\n        if (result.length > 1 && !isVowel(result[result.length - 2])) {\n          // Delete\n          result = removeSuffix(result, 1);\n          this.suffixeRemoved = true; // Undouble the ending\n\n          result = undoubleEnding(result);\n        }\n      }\n\n      if (DEBUG) {\n        console.log('step2: ' + result);\n      }\n\n      return result;\n    } // Step 3a: heid => delete heid if in R2 and not preceded by c, and treat a preceding en as in step 1(b)\n\n  }, {\n    key: \"step3a\",\n    value: function step3a(word) {\n      var result = word;\n\n      if (endsin(result, 'heid') && result.length - 4 >= this.r2 && result[result.length - 5] !== 'c') {\n        // Delete\n        result = removeSuffix(result, 4); // Treat a preceding en as in step 1b\n\n        result = this.step1b(result, ['en']);\n      }\n\n      if (DEBUG) {\n        console.log('step 3a: ' + result);\n      }\n\n      return result;\n    } // d suffixes: Search for the longest among the following suffixes, and perform the action indicated.\n\n  }, {\n    key: \"step3b\",\n    value: function step3b(word) {\n      var result = word; // end   ing => delete if in R2; if preceded by ig, delete if in R2 and not preceded by e, otherwise undouble the ending\n\n      var suf = endsinArr(result, ['end', 'ing']);\n\n      if (suf) {\n        if (result.length - 3 >= this.r2) {\n          // Delete suffix\n          result = removeSuffix(result, 3); // this.regions(result);\n\n          if (endsin(result, 'ig') && result.length - 2 >= this.r2 && result[result.length - 3] !== 'e') {\n            // Delete suffix\n            result = removeSuffix(result, 2);\n          } else {\n            result = undoubleEnding(result);\n          }\n        }\n      } // ig => delete if in R2 and not preceded by e\n\n\n      if (endsin(result, 'ig') && this.r2 <= result.length - 2 && result[result.length - 3] !== 'e') {\n        result = removeSuffix(result, 2);\n      } // lijk => delete if in R2, and then repeat step 2\n\n\n      if (endsin(result, 'lijk') && this.r2 <= result.length - 4) {\n        result = removeSuffix(result, 4); // repeat step 2\n\n        result = this.step2(result);\n      } // baar => delete if in R2\n\n\n      if (endsin(result, 'baar') && this.r2 <= result.length - 4) {\n        result = removeSuffix(result, 4);\n      } // bar => delete if in R2 and if step 2 actually removed an e\n\n\n      if (endsin(result, 'bar') && this.r2 <= result.length - 3 && this.suffixeRemoved) {\n        result = removeSuffix(result, 3);\n      }\n\n      if (DEBUG) {\n        console.log('step 3b: ' + result);\n      }\n\n      return result;\n    } // undouble vowel => If the words ends CVD, where C is a non-vowel,\n    // D is a non-vowel other than I, and V is double a, e, o or u,\n    // remove one of the vowels from V (for example, maan -> man, brood -> brod)\n\n  }, {\n    key: \"step4\",\n    value: function step4(word) {\n      var result = word;\n\n      if (result.match(/[bcdfghjklmnpqrstvwxz](aa|ee|oo|uu)[bcdfghjklmnpqrstvwxz]$/)) {\n        result = result.substr(0, result.length - 2) + result[result.length - 1];\n      }\n\n      if (DEBUG) {\n        console.log('step4: ' + result);\n      }\n\n      return result;\n    } // Turn I and Y back into lower case.\n\n  }, {\n    key: \"postlude\",\n    value: function postlude(word) {\n      return word.toLowerCase();\n    }\n  }, {\n    key: \"stem\",\n    value: function stem(word) {\n      return this.postlude(this.step4(this.step3b(this.step3a(this.step2(this.step1(this.prelude(word)))))));\n    }\n  }]);\n\n  return PorterStemmer;\n}(Stemmer);\n\nmodule.exports = new PorterStemmer();","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/stemmers/porter_stemmer_nl.js"],"names":["Stemmer","require","DEBUG","vowels","isVowel","x","indexOf","endsinArr","str","suffixes","i","longest","length","endsin","console","log","suffix","slice","removeSuffix","len","substr","undoubleEnding","PorterStemmer","word","accentedCharactersMapping","ä","ë","ï","ö","ü","á","é","í","ó","ú","result","replace","RegExp","token","r1","r2","replaceAccentedCharacters","handleYI","markRegions","match","pos","step1b","suffixeRemoved","suf","step2","toLowerCase","postlude","step4","step3b","step3a","step1","prelude","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AAEA,IAAMC,KAAK,GAAG,KAAd;AACA,IAAMC,MAAM,GAAG,SAAf;;AAEA,SAASC,OAAT,CAAkBC,CAAlB,EAAqB;AACnB,SAAOF,MAAM,CAACG,OAAP,CAAeD,CAAf,IAAoB,CAAC,CAA5B;AACD,C,CAED;;;AACA,SAASE,SAAT,CAAoBC,GAApB,EAAyBC,QAAzB,EAAmC;AACjC,MAAIC,CAAJ;AACA,MAAIC,OAAO,GAAG,EAAd;;AACA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,QAAQ,CAACG,MAAzB,EAAiCF,CAAC,EAAlC,EAAsC;AACpC,QAAIG,MAAM,CAACL,GAAD,EAAMC,QAAQ,CAACC,CAAD,CAAd,CAAN,IAA4BD,QAAQ,CAACC,CAAD,CAAR,CAAYE,MAAZ,GAAqBD,OAAO,CAACC,MAA7D,EAAqE;AAAED,MAAAA,OAAO,GAAGF,QAAQ,CAACC,CAAD,CAAlB;AAAuB;AAC/F;;AAED,MAAIR,KAAK,IAAIS,OAAO,KAAK,EAAzB,EAA6B;AAC3BG,IAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBJ,OAAjC;AACD;;AACD,SAAOA,OAAP;AACD,C,CAED;;;AACA,SAASE,MAAT,CAAiBL,GAAjB,EAAsBQ,MAAtB,EAA8B;AAC5B,MAAIR,GAAG,CAACI,MAAJ,GAAaI,MAAM,CAACJ,MAAxB,EAAgC,OAAO,KAAP;AAChC,SAAQJ,GAAG,CAACS,KAAJ,CAAU,CAACD,MAAM,CAACJ,MAAlB,MAA8BI,MAAtC;AACD,C,CAED;;;AACA,SAASE,YAAT,CAAuBV,GAAvB,EAA4BW,GAA5B,EAAiC;AAC/B,SAAOX,GAAG,CAACY,MAAJ,CAAW,CAAX,EAAcZ,GAAG,CAACI,MAAJ,GAAaO,GAA3B,CAAP;AACD,C,CAED;;;AACA,SAASE,cAAT,CAAyBb,GAAzB,EAA8B;AAC5B,MAAIA,GAAG,CAACY,MAAJ,CAAW,CAAC,CAAZ,MAAmB,IAAnB,IAA2BZ,GAAG,CAACY,MAAJ,CAAW,CAAC,CAAZ,MAAmB,IAA9C,IAAsDZ,GAAG,CAACY,MAAJ,CAAW,CAAC,CAAZ,MAAmB,IAA7E,EAAmF;AACjF,WAAOZ,GAAG,CAACY,MAAJ,CAAW,CAAX,EAAcZ,GAAG,CAACI,MAAJ,GAAa,CAA3B,CAAP;AACD,GAFD,MAEO;AACL,WAAOJ,GAAP;AACD;AACF;;IAEKc,a;;;;;;;;;;;;;WACJ,mCAA2BC,IAA3B,EAAiC;AAC/B,UAAMC,yBAAyB,GAAG;AAChCC,QAAAA,CAAC,EAAE,GAD6B;AAEhCC,QAAAA,CAAC,EAAE,GAF6B;AAGhCC,QAAAA,CAAC,EAAE,GAH6B;AAIhCC,QAAAA,CAAC,EAAE,GAJ6B;AAKhCC,QAAAA,CAAC,EAAE,GAL6B;AAMhCC,QAAAA,CAAC,EAAE,GAN6B;AAOhCC,QAAAA,CAAC,EAAE,GAP6B;AAQhCC,QAAAA,CAAC,EAAE,GAR6B;AAShCC,QAAAA,CAAC,EAAE,GAT6B;AAUhCC,QAAAA,CAAC,EAAE;AAV6B,OAAlC;AAYA,UAAIC,MAAM,GAAGZ,IAAb;;AACA,WAAK,IAAMlB,CAAX,IAAgBmB,yBAAhB,EAA2C;AACzCW,QAAAA,MAAM,GAAGA,MAAM,CAACC,OAAP,CAAe,IAAIC,MAAJ,CAAWhC,CAAX,EAAc,GAAd,CAAf,EAAmCmB,yBAAyB,CAACnB,CAAD,CAA5D,CAAT;AACD;;AACD,UAAIH,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,gCAAgCoB,MAA5C;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,kBAAUZ,IAAV,EAAgB;AACd;AACA,UAAIY,MAAM,GAAGZ,IAAI,CAACa,OAAL,CAAa,IAAb,EAAmB,GAAnB,CAAb;;AACA,UAAIlC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,0BAA0BoB,MAAtC;AACD,OALa,CAMd;;;AACAA,MAAAA,MAAM,GAAGA,MAAM,CAACC,OAAP,CAAe,cAAf,EAA+B,KAA/B,CAAT;;AACA,UAAIlC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,8BAA8BoB,MAA1C;AACD,OAVa,CAWd;;;AACAA,MAAAA,MAAM,GAAGA,MAAM,CAACC,OAAP,CAAe,wBAAf,EAAyC,OAAzC,CAAT;;AACA,UAAIlC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,gCAAgCoB,MAA5C;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,qBAAaG,KAAb,EAAoB;AAClB,UAAIC,EAAJ,EAAQC,EAAR,EAAYrB,GAAZ;AAEAoB,MAAAA,EAAE,GAAGC,EAAE,GAAGrB,GAAG,GAAGmB,KAAK,CAAC1B,MAAtB,CAHkB,CAKlB;;AACA,WAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,GAAG,GAAG,CAAV,IAAeoB,EAAE,KAAKpB,GAAtC,EAA2CT,CAAC,EAA5C,EAAgD;AAC9C,YAAIN,OAAO,CAACkC,KAAK,CAAC5B,CAAD,CAAN,CAAP,IAAqB,CAACN,OAAO,CAACkC,KAAK,CAAC5B,CAAC,GAAG,CAAL,CAAN,CAAjC,EAAiD;AAC/C6B,UAAAA,EAAE,GAAG7B,CAAC,GAAG,CAAT;AACD;AACF,OAViB,CAWlB;AAEA;;;AACA,UAAI6B,EAAE,KAAKpB,GAAX,EAAgB;AACd;AACA,YAAIoB,EAAE,GAAG,CAAT,EAAY;AACV;AACA,cAAIpB,GAAG,GAAG,CAAV,EAAa;AACXoB,YAAAA,EAAE,GAAG,CAAL,CADW,CAEX;AACD,WAHD,MAGO;AACL;AACAA,YAAAA,EAAE,GAAGpB,GAAL;AACD;AACF;AACF,OA1BiB,CA4BlB;;;AACA,WAAK,IAAIT,EAAC,GAAG6B,EAAb,EAAiB7B,EAAC,GAAGS,GAAG,GAAG,CAAV,IAAeqB,EAAE,KAAKrB,GAAvC,EAA4CT,EAAC,EAA7C,EAAiD;AAC/C,YAAIN,OAAO,CAACkC,KAAK,CAAC5B,EAAD,CAAN,CAAP,IAAqB,CAACN,OAAO,CAACkC,KAAK,CAAC5B,EAAC,GAAG,CAAL,CAAN,CAAjC,EAAiD;AAC/C8B,UAAAA,EAAE,GAAG9B,EAAC,GAAG,CAAT;AACD;AACF,OAjCiB,CAkClB;;;AAEA,UAAIR,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBwB,EAAlB,GAAuB,QAAvB,GAAkCC,EAA9C;AACD;;AAED,WAAKD,EAAL,GAAUA,EAAV;AACA,WAAKC,EAAL,GAAUA,EAAV;AACD;;;WAED,iBAASjB,IAAT,EAAe;AACb,UAAIY,MAAM,GAAG,KAAKM,yBAAL,CAA+BlB,IAA/B,CAAb;AACAY,MAAAA,MAAM,GAAG,KAAKO,QAAL,CAAcP,MAAd,CAAT;AACA,WAAKQ,WAAL,CAAiBR,MAAjB;;AACA,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;AACA;AACA;;;;WACA,gBAAQZ,IAAR,EAAcd,QAAd,EAAwB;AACtB,UAAI0B,MAAM,GAAGZ,IAAb;AAEA,UAAMqB,KAAK,GAAGrC,SAAS,CAAC4B,MAAD,EAAS1B,QAAT,CAAvB;;AACA,UAAImC,KAAK,KAAK,EAAd,EAAkB;AAChB,YAAMC,GAAG,GAAGV,MAAM,CAACvB,MAAP,GAAgBgC,KAAK,CAAChC,MAAlC;;AACA,YAAIiC,GAAG,IAAI,KAAKN,EAAhB,EAAoB;AAClB;AACA,cAAI,CAACnC,OAAO,CAAC+B,MAAM,CAACU,GAAG,GAAG,CAAP,CAAP,CAAR,IAA6BV,MAAM,CAACf,MAAP,CAAcyB,GAAG,GAAG,CAApB,EAAuB,CAAvB,MAA8B,KAA/D,EAAsE;AACpE;AACAV,YAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAASS,KAAK,CAAChC,MAAf,CAArB,CAFoE,CAGpE;;AACAuB,YAAAA,MAAM,GAAGd,cAAc,CAACc,MAAD,CAAvB;AACD;AACF;AACF;;AACD,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AACD,aAAOA,MAAP;AACD;;;WAED,eAAOZ,IAAP,EAAa;AACX,UAAIY,MAAM,GAAGZ,IAAb,CADW,CAEX;;AACA,UAAIV,MAAM,CAACsB,MAAD,EAAS,OAAT,CAAN,IAA2BA,MAAM,CAACvB,MAAP,GAAgB,CAAhB,IAAqB,KAAK2B,EAAzD,EAA6D;AAC3DJ,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACAA,QAAAA,MAAM,IAAI,MAAV;AACD;;AACD,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AAEDA,MAAAA,MAAM,GAAG,KAAKW,MAAL,CAAYX,MAAZ,EAAoB,CAAC,IAAD,EAAO,KAAP,CAApB,CAAT,CAXW,CAaX;AACA;;AACA,UAAMS,KAAK,GAAGrC,SAAS,CAAC4B,MAAD,EAAS,CAAC,IAAD,EAAO,GAAP,CAAT,CAAvB;;AACA,UAAIS,KAAK,KAAK,EAAd,EAAkB;AAChB,YAAMC,GAAG,GAAGV,MAAM,CAACvB,MAAP,GAAgBgC,KAAK,CAAChC,MAAlC;;AACA,YAAIiC,GAAG,IAAI,KAAKN,EAAhB,EAAoB;AAClB;AACA;AACA;AACA,cAAI,CAACnC,OAAO,CAAC+B,MAAM,CAACU,GAAG,GAAG,CAAP,CAAP,CAAR,IAA6B,CAACV,MAAM,CAACS,KAAP,CAAa,UAAb,CAAlC,EAA4D;AAC1DT,YAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAASS,KAAK,CAAChC,MAAf,CAArB;AACD;AACF;AACF;;AACD,UAAIV,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,eAAOZ,IAAP,EAAa;AACX,UAAIY,MAAM,GAAGZ,IAAb;;AACA,UAAIV,MAAM,CAACsB,MAAD,EAAS,GAAT,CAAN,IAAuB,KAAKI,EAAL,GAAUJ,MAAM,CAACvB,MAA5C,EAAoD;AAClD,YAAIuB,MAAM,CAACvB,MAAP,GAAgB,CAAhB,IAAqB,CAACR,OAAO,CAAC+B,MAAM,CAACA,MAAM,CAACvB,MAAP,GAAgB,CAAjB,CAAP,CAAjC,EAA8D;AAC5D;AACAuB,UAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACA,eAAKY,cAAL,GAAsB,IAAtB,CAH4D,CAI5D;;AACAZ,UAAAA,MAAM,GAAGd,cAAc,CAACc,MAAD,CAAvB;AACD;AACF;;AAED,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,YAAYoB,MAAxB;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,gBAAQZ,IAAR,EAAc;AACZ,UAAIY,MAAM,GAAGZ,IAAb;;AACA,UAAIV,MAAM,CAACsB,MAAD,EAAS,MAAT,CAAN,IAA0BA,MAAM,CAACvB,MAAP,GAAgB,CAAhB,IAAqB,KAAK4B,EAApD,IAA0DL,MAAM,CAACA,MAAM,CAACvB,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAA5F,EAAiG;AAC/F;AACAuB,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB,CAF+F,CAG/F;;AACAA,QAAAA,MAAM,GAAG,KAAKW,MAAL,CAAYX,MAAZ,EAAoB,CAAC,IAAD,CAApB,CAAT;AACD;;AACD,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,gBAAQZ,IAAR,EAAc;AACZ,UAAIY,MAAM,GAAGZ,IAAb,CADY,CAGZ;;AACA,UAAMyB,GAAG,GAAGzC,SAAS,CAAC4B,MAAD,EAAS,CAAC,KAAD,EAAQ,KAAR,CAAT,CAArB;;AACA,UAAIa,GAAJ,EAAS;AACP,YAAKb,MAAM,CAACvB,MAAP,GAAgB,CAAjB,IAAuB,KAAK4B,EAAhC,EAAoC;AAClC;AACAL,UAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB,CAFkC,CAGlC;;AACA,cAAItB,MAAM,CAACsB,MAAD,EAAS,IAAT,CAAN,IAAyBA,MAAM,CAACvB,MAAP,GAAgB,CAAhB,IAAqB,KAAK4B,EAAnD,IAA0DL,MAAM,CAACA,MAAM,CAACvB,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAA5F,EAAiG;AAC/F;AACAuB,YAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACD,WAHD,MAGO;AACLA,YAAAA,MAAM,GAAGd,cAAc,CAACc,MAAD,CAAvB;AACD;AACF;AACF,OAjBW,CAmBZ;;;AACA,UAAItB,MAAM,CAACsB,MAAD,EAAS,IAAT,CAAN,IAAwB,KAAKK,EAAL,IAAWL,MAAM,CAACvB,MAAP,GAAgB,CAAnD,IAAwDuB,MAAM,CAACA,MAAM,CAACvB,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAA1F,EAA+F;AAC7FuB,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACD,OAtBW,CAwBZ;;;AACA,UAAItB,MAAM,CAACsB,MAAD,EAAS,MAAT,CAAN,IAA0B,KAAKK,EAAL,IAAWL,MAAM,CAACvB,MAAP,GAAgB,CAAzD,EAA4D;AAC1DuB,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB,CAD0D,CAE1D;;AACAA,QAAAA,MAAM,GAAG,KAAKc,KAAL,CAAWd,MAAX,CAAT;AACD,OA7BW,CA+BZ;;;AACA,UAAItB,MAAM,CAACsB,MAAD,EAAS,MAAT,CAAN,IAA0B,KAAKK,EAAL,IAAWL,MAAM,CAACvB,MAAP,GAAgB,CAAzD,EAA4D;AAC1DuB,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACD,OAlCW,CAoCZ;;;AACA,UAAItB,MAAM,CAACsB,MAAD,EAAS,KAAT,CAAN,IAAyB,KAAKK,EAAL,IAAWL,MAAM,CAACvB,MAAP,GAAgB,CAApD,IAAyD,KAAKmC,cAAlE,EAAkF;AAChFZ,QAAAA,MAAM,GAAGjB,YAAY,CAACiB,MAAD,EAAS,CAAT,CAArB;AACD;;AAED,UAAIjC,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAcoB,MAA1B;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;AACA;AACA;;;;WACA,eAAOZ,IAAP,EAAa;AACX,UAAIY,MAAM,GAAGZ,IAAb;;AAEA,UAAIY,MAAM,CAACS,KAAP,CAAa,4DAAb,CAAJ,EAAgF;AAC9ET,QAAAA,MAAM,GAAGA,MAAM,CAACf,MAAP,CAAc,CAAd,EAAiBe,MAAM,CAACvB,MAAP,GAAgB,CAAjC,IAAsCuB,MAAM,CAACA,MAAM,CAACvB,MAAP,GAAgB,CAAjB,CAArD;AACD;;AAED,UAAIV,KAAJ,EAAW;AACTY,QAAAA,OAAO,CAACC,GAAR,CAAY,YAAYoB,MAAxB;AACD;;AACD,aAAOA,MAAP;AACD,K,CAED;;;;WACA,kBAAUZ,IAAV,EAAgB;AACd,aAAOA,IAAI,CAAC2B,WAAL,EAAP;AACD;;;WAED,cAAM3B,IAAN,EAAY;AACV,aAAO,KAAK4B,QAAL,CAAc,KAAKC,KAAL,CAAW,KAAKC,MAAL,CAAY,KAAKC,MAAL,CAAY,KAAKL,KAAL,CAAW,KAAKM,KAAL,CAAW,KAAKC,OAAL,CAAajC,IAAb,CAAX,CAAX,CAAZ,CAAZ,CAAX,CAAd,CAAP;AACD;;;;EAtQyBvB,O;;AAyQ5ByD,MAAM,CAACC,OAAP,GAAiB,IAAIpC,aAAJ,EAAjB","sourcesContent":["/*\nCopyright (c) 2018, Hugo W.L. ter Doest\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\n * Spec for the Dutch Porter Stemmer can be found at:\n * http://snowball.tartarus.org/algorithms/dutch/stemmer.html\n */\n\n'use strict'\n\nconst Stemmer = require('./stemmer_nl')\n\nconst DEBUG = false\nconst vowels = 'aeiouèy'\n\nfunction isVowel (x) {\n  return vowels.indexOf(x) > -1\n}\n\n// * Return longest matching suffixes for a token or '' if no suffix match\nfunction endsinArr (str, suffixes) {\n  let i\n  let longest = ''\n  for (i = 0; i < suffixes.length; i++) {\n    if (endsin(str, suffixes[i]) && suffixes[i].length > longest.length) { longest = suffixes[i] }\n  }\n\n  if (DEBUG && longest !== '') {\n    console.log('Matched suffix: ' + longest)\n  }\n  return longest\n}\n\n// Returns true if token has suffix\nfunction endsin (str, suffix) {\n  if (str.length < suffix.length) return false\n  return (str.slice(-suffix.length) === suffix)\n}\n\n// Removes a suffix of len characters and returns the string\nfunction removeSuffix (str, len) {\n  return str.substr(0, str.length - len)\n}\n\n// Define undoubling the ending as removing the last letter if the word ends kk, dd or tt.\nfunction undoubleEnding (str) {\n  if (str.substr(-2) === 'kk' || str.substr(-2) === 'tt' || str.substr(-2) === 'dd') {\n    return str.substr(0, str.length - 1)\n  } else {\n    return str\n  }\n}\n\nclass PorterStemmer extends Stemmer {\n  replaceAccentedCharacters (word) {\n    const accentedCharactersMapping = {\n      ä: 'a',\n      ë: 'e',\n      ï: 'i',\n      ö: 'o',\n      ü: 'u',\n      á: 'a',\n      é: 'e',\n      í: 'i',\n      ó: 'o',\n      ú: 'u'\n    }\n    let result = word\n    for (const x in accentedCharactersMapping) {\n      result = result.replace(new RegExp(x, 'g'), accentedCharactersMapping[x])\n    }\n    if (DEBUG) {\n      console.log('replaceAccentedCharacters: ' + result)\n    }\n    return result\n  }\n\n  // Put initial y, y after a vowel, and i between vowels into upper case.\n  handleYI (word) {\n    // Initial y\n    let result = word.replace(/^y/, 'Y')\n    if (DEBUG) {\n      console.log('handleYI: initial y: ' + result)\n    }\n    // y after vowel\n    result = result.replace(/([aeioué])y/g, '$1Y')\n    if (DEBUG) {\n      console.log('handleYI: y after vowel: ' + result)\n    }\n    // i between vowels\n    result = result.replace(/([aeioué])i([aeioué])/g, '$1I$2')\n    if (DEBUG) {\n      console.log('handleYI: i between vowels:' + result)\n    }\n    return result\n  }\n\n  // Determines R1 and R2; adapted from the French Porter Stemmer\n  markRegions (token) {\n    let r1, r2, len\n\n    r1 = r2 = len = token.length\n\n    // R1 is the region after the first non-vowel following a vowel,\n    for (let i = 0; i < len - 1 && r1 === len; i++) {\n      if (isVowel(token[i]) && !isVowel(token[i + 1])) {\n        r1 = i + 2\n      }\n    }\n    // Or is the null region at the end of the word if there is no such non-vowel.\n\n    // R1 is adjusted such that the region before it contains at least 3 characters\n    if (r1 !== len) {\n      // R1 is not null\n      if (r1 < 3) {\n        // Region before does not contain at least 3 characters\n        if (len > 3) {\n          r1 = 3\n          // Now R1 contains at least 3 characters\n        } else {\n          // It is not possible to make the region before long enough\n          r1 = len\n        }\n      }\n    }\n\n    // R2 is the region after the first non-vowel following a vowel in R1\n    for (let i = r1; i < len - 1 && r2 === len; i++) {\n      if (isVowel(token[i]) && !isVowel(token[i + 1])) {\n        r2 = i + 2\n      }\n    }\n    // Or is the null region at the end of the word if there is no such non-vowel.\n\n    if (DEBUG) {\n      console.log('Regions r1 = ' + r1 + ' r2 = ' + r2)\n    }\n\n    this.r1 = r1\n    this.r2 = r2\n  }\n\n  prelude (word) {\n    let result = this.replaceAccentedCharacters(word)\n    result = this.handleYI(result)\n    this.markRegions(result)\n    if (DEBUG) {\n      console.log('Prelude: ' + result)\n    }\n    return result\n  }\n\n  // (1b) en   ene => delete if in R1 and preceded by a valid en-ending, and then undouble the ending\n  // Define a valid en-ending as a non-vowel, and not gem.\n  // Define undoubling the ending as removing the last letter if the word ends kk, dd or tt.\n  step1b (word, suffixes) {\n    let result = word\n\n    const match = endsinArr(result, suffixes)\n    if (match !== '') {\n      const pos = result.length - match.length\n      if (pos >= this.r1) {\n        // check the character before the matched en/ene AND check for gem\n        if (!isVowel(result[pos - 1]) && result.substr(pos - 3, 3) !== 'gem') {\n          // delete\n          result = removeSuffix(result, match.length)\n          // Undouble the ending\n          result = undoubleEnding(result)\n        }\n      }\n    }\n    if (DEBUG) {\n      console.log('step 1b: ' + result)\n    }\n    return result\n  }\n\n  step1 (word) {\n    let result = word\n    // (1a) heden => replace with heid if in R1\n    if (endsin(result, 'heden') && result.length - 5 >= this.r1) {\n      result = removeSuffix(result, 5)\n      result += 'heid'\n    }\n    if (DEBUG) {\n      console.log('step 1a: ' + result)\n    }\n\n    result = this.step1b(result, ['en', 'ene'])\n\n    // (1c) s   se => delete if in R1 and preceded by a valid s-ending\n    // Define a valid s-ending as a non-vowel other than j.\n    const match = endsinArr(result, ['se', 's'])\n    if (match !== '') {\n      const pos = result.length - match.length\n      if (pos >= this.r1) {\n        // check the character before the matched s/se\n        // HtD: if there is a s before the s/se the suffix should stay\n        // if (!isVowel(result[pos - 1]) && result[pos - 1] != \"j\") {\n        if (!isVowel(result[pos - 1]) && !result.match(/[js]se?$/)) {\n          result = removeSuffix(result, match.length)\n        }\n      }\n    }\n    if (DEBUG) {\n      console.log('step 1c: ' + result)\n    }\n    return result\n  }\n\n  // Delete suffix e if in R1 and preceded by a non-vowel, and then undouble the ending\n  step2 (word) {\n    let result = word\n    if (endsin(result, 'e') && this.r1 < result.length) {\n      if (result.length > 1 && !isVowel(result[result.length - 2])) {\n        // Delete\n        result = removeSuffix(result, 1)\n        this.suffixeRemoved = true\n        // Undouble the ending\n        result = undoubleEnding(result)\n      }\n    }\n\n    if (DEBUG) {\n      console.log('step2: ' + result)\n    }\n    return result\n  }\n\n  // Step 3a: heid => delete heid if in R2 and not preceded by c, and treat a preceding en as in step 1(b)\n  step3a (word) {\n    let result = word\n    if (endsin(result, 'heid') && result.length - 4 >= this.r2 && result[result.length - 5] !== 'c') {\n      // Delete\n      result = removeSuffix(result, 4)\n      // Treat a preceding en as in step 1b\n      result = this.step1b(result, ['en'])\n    }\n    if (DEBUG) {\n      console.log('step 3a: ' + result)\n    }\n    return result\n  }\n\n  // d suffixes: Search for the longest among the following suffixes, and perform the action indicated.\n  step3b (word) {\n    let result = word\n\n    // end   ing => delete if in R2; if preceded by ig, delete if in R2 and not preceded by e, otherwise undouble the ending\n    const suf = endsinArr(result, ['end', 'ing'])\n    if (suf) {\n      if ((result.length - 3) >= this.r2) {\n        // Delete suffix\n        result = removeSuffix(result, 3)\n        // this.regions(result);\n        if (endsin(result, 'ig') && (result.length - 2 >= this.r2) && result[result.length - 3] !== 'e') {\n          // Delete suffix\n          result = removeSuffix(result, 2)\n        } else {\n          result = undoubleEnding(result)\n        }\n      }\n    }\n\n    // ig => delete if in R2 and not preceded by e\n    if (endsin(result, 'ig') && this.r2 <= result.length - 2 && result[result.length - 3] !== 'e') {\n      result = removeSuffix(result, 2)\n    }\n\n    // lijk => delete if in R2, and then repeat step 2\n    if (endsin(result, 'lijk') && this.r2 <= result.length - 4) {\n      result = removeSuffix(result, 4)\n      // repeat step 2\n      result = this.step2(result)\n    }\n\n    // baar => delete if in R2\n    if (endsin(result, 'baar') && this.r2 <= result.length - 4) {\n      result = removeSuffix(result, 4)\n    }\n\n    // bar => delete if in R2 and if step 2 actually removed an e\n    if (endsin(result, 'bar') && this.r2 <= result.length - 3 && this.suffixeRemoved) {\n      result = removeSuffix(result, 3)\n    }\n\n    if (DEBUG) {\n      console.log('step 3b: ' + result)\n    }\n    return result\n  }\n\n  // undouble vowel => If the words ends CVD, where C is a non-vowel,\n  // D is a non-vowel other than I, and V is double a, e, o or u,\n  // remove one of the vowels from V (for example, maan -> man, brood -> brod)\n  step4 (word) {\n    let result = word\n\n    if (result.match(/[bcdfghjklmnpqrstvwxz](aa|ee|oo|uu)[bcdfghjklmnpqrstvwxz]$/)) {\n      result = result.substr(0, result.length - 2) + result[result.length - 1]\n    }\n\n    if (DEBUG) {\n      console.log('step4: ' + result)\n    }\n    return result\n  }\n\n  // Turn I and Y back into lower case.\n  postlude (word) {\n    return word.toLowerCase()\n  }\n\n  stem (word) {\n    return this.postlude(this.step4(this.step3b(this.step3a(this.step2(this.step1(this.prelude(word)))))))\n  }\n}\n\nmodule.exports = new PorterStemmer()\n"]},"metadata":{},"sourceType":"script"}