{"ast":null,"code":"var os = require('os');\n\nvar Threads = null;\n\ntry {\n  Threads = require('webworker-threads');\n} catch (e) {\n  // Since webworker-threads are optional, only thow if the module is found\n  if (e.code !== 'MODULE_NOT_FOUND') throw e;\n}\n\nfunction checkThreadSupport() {\n  if (typeof Threads === 'undefined') {\n    throw new Error('parallel classification requires the optional dependency webworker-threads');\n  }\n}\n\nfunction docsToFeatures(docs) {\n  var parsedDocs = [];\n\n  for (var i = 0; i < docs.length; i++) {\n    var features = [];\n\n    for (var feature in FEATURES) {\n      // eslint-disable-line\n      if (docs[i].observation.indexOf(feature) > -1) {\n        features.push(1);\n      } else {\n        features.push(0);\n      }\n    }\n\n    parsedDocs.push({\n      index: docs[i].index,\n      features: features\n    });\n  }\n\n  return JSON.stringify(parsedDocs);\n} // Convert docs to observation objects\n\n\nfunction docsToObs(docs, lastAdded, stemmer, keepStops) {\n  var obsDocs = [];\n\n  for (var i = lastAdded; i < docs.length; i++) {\n    var observation = this.docs[i].text;\n\n    if (typeof observation === 'string') {\n      observation = stemmer.tokenizeAndStem(observation, keepStops);\n    }\n\n    obsDocs.push({\n      index: i,\n      observation: observation\n    });\n  }\n\n  return obsDocs;\n}\n\nfunction emitEvents(self, docFeatures, totalDocs) {\n  for (var j = self.lastAdded; j < totalDocs; j++) {\n    self.classifier.addExample(docFeatures[j], self.docs[j].label);\n    self.events.emit('trainedWithDocument', {\n      index: j,\n      total: totalDocs,\n      doc: self.docs[j]\n    });\n    self.lastAdded++;\n  }\n}\n\nfunction trainParallel(numThreads, callback) {\n  checkThreadSupport();\n\n  if (!callback) {\n    callback = numThreads;\n    numThreads = undefined;\n  }\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length;\n  }\n\n  var totalDocs = this.docs.length;\n  var threadPool = Threads.createPool(numThreads);\n  var docFeatures = {};\n  var finished = 0;\n  var self = this; // Init pool; send the features array and the parsing function\n\n  threadPool.all.eval('var FEATURES = ' + JSON.stringify(this.features));\n  threadPool.all.eval(docsToFeatures);\n  var obsDocs = docsToObs(this.docs, this.lastAdded, this.stemmer, this.keepStops); // Called when a batch completes processing\n\n  var onFeaturesResult = function onFeaturesResult(docs) {\n    setTimeout(function () {\n      self.events.emit('processedBatch', {\n        size: docs.length,\n        docs: totalDocs,\n        batches: numThreads,\n        index: finished\n      });\n    });\n\n    for (var j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features;\n    }\n  }; // Called when all batches finish processing\n\n\n  var onFinished = function onFinished(err) {\n    if (err) {\n      threadPool.destroy();\n      return callback(err);\n    }\n\n    emitEvents(self, docFeatures, totalDocs);\n    self.events.emit('doneTraining', true);\n    self.classifier.train();\n    threadPool.destroy();\n    callback(null);\n  }; // Split the docs and start processing\n\n\n  var batchSize = Math.ceil(obsDocs.length / numThreads);\n  var lastError;\n\n  for (var i = 0; i < numThreads; i++) {\n    var batchDocs = obsDocs.slice(i * batchSize, (i + 1) * batchSize);\n    var batchJson = JSON.stringify(batchDocs);\n    threadPool.any.eval('docsToFeatures(' + batchJson + ')', function (err, docs) {\n      lastError = err || lastError;\n      finished++;\n\n      if (docs) {\n        docs = JSON.parse(docs);\n        onFeaturesResult(docs);\n      }\n\n      if (finished >= numThreads) {\n        onFinished(lastError);\n      }\n    });\n  }\n}\n\nfunction trainParallelBatches(options) {\n  checkThreadSupport();\n  var numThreads = options && options.numThreads;\n  var batchSize = options && options.batchSize;\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length;\n  }\n\n  if (isNaN(batchSize)) {\n    batchSize = 2500;\n  }\n\n  var totalDocs = this.docs.length;\n  var threadPool = Threads.createPool(numThreads);\n  var docFeatures = {};\n  var finished = 0;\n  var self = this;\n  var abort = false;\n\n  var onError = function onError(err) {\n    if (!err || abort) return;\n    abort = true;\n    threadPool.destroy(true);\n    self.events.emit('doneTrainingError', err);\n  }; // Init pool; send the features array and the parsing function\n\n\n  var str = JSON.stringify(this.features);\n  threadPool.all.eval('var FEATURES = ' + str + ';', onError);\n  threadPool.all.eval(docsToFeatures, onError); // Convert docs to observation objects\n\n  var obsDocs = [];\n\n  for (var _i = this.lastAdded; _i < totalDocs; _i++) {\n    var observation = this.docs[_i].text;\n\n    if (typeof observation === 'string') {\n      observation = this.stemmer.tokenizeAndStem(observation, this.keepStops);\n    }\n\n    obsDocs.push({\n      index: _i,\n      observation: observation\n    });\n  } // Split the docs in batches\n\n\n  var obsBatches = [];\n  var i = 0;\n\n  while (true) {\n    var batch = obsDocs.slice(i * batchSize, (i + 1) * batchSize);\n    if (!batch || !batch.length) break;\n    obsBatches.push(batch);\n    i++;\n  }\n\n  obsDocs = null;\n  self.events.emit('startedTraining', {\n    docs: totalDocs,\n    batches: obsBatches.length\n  }); // Called when a batch completes processing\n\n  var onFeaturesResult = function onFeaturesResult(docs) {\n    self.events.emit('processedBatch', {\n      size: docs.length,\n      docs: totalDocs,\n      batches: obsBatches.length,\n      index: finished\n    });\n\n    for (var j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features;\n    }\n  }; // Called when all batches finish processing\n\n\n  var onFinished = function onFinished() {\n    threadPool.destroy(true);\n    abort = true;\n    emitEvents(self, docFeatures, totalDocs);\n    self.events.emit('doneTraining', true);\n    self.classifier.train();\n  }; // Called to send the next batch to be processed\n\n\n  var batchIndex = 0;\n\n  var sendNext = function sendNext() {\n    if (abort) return;\n\n    if (batchIndex >= obsBatches.length) {\n      return;\n    }\n\n    sendBatch(JSON.stringify(obsBatches[batchIndex]));\n    batchIndex++;\n  }; // Called to send a batch of docs to the threads\n\n\n  var sendBatch = function sendBatch(batchJson) {\n    if (abort) return;\n    threadPool.any.eval('docsToFeatures(' + batchJson + ');', function (err, docs) {\n      if (err) {\n        return onError(err);\n      }\n\n      finished++;\n\n      if (docs) {\n        docs = JSON.parse(docs);\n        setTimeout(onFeaturesResult.bind(null, docs));\n      }\n\n      if (finished >= obsBatches.length) {\n        setTimeout(onFinished);\n      }\n\n      setTimeout(sendNext);\n    });\n  }; // Start processing\n\n\n  for (var _i2 = 0; _i2 < numThreads; _i2++) {\n    sendNext();\n  }\n}\n\nfunction retrainParallel(numThreads, callback) {\n  this.classifier = new this.classifier.constructor();\n  this.lastAdded = 0;\n  this.trainParallel(numThreads, callback);\n}\n\nmodule.exports = {\n  Threads: Threads,\n  trainParallel: trainParallel,\n  trainParallelBatches: trainParallelBatches,\n  retrainParallel: retrainParallel\n};","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/classifiers/classifier_train_parallel.js"],"names":["os","require","Threads","e","code","checkThreadSupport","Error","docsToFeatures","docs","parsedDocs","i","length","features","feature","FEATURES","observation","indexOf","push","index","JSON","stringify","docsToObs","lastAdded","stemmer","keepStops","obsDocs","text","tokenizeAndStem","emitEvents","self","docFeatures","totalDocs","j","classifier","addExample","label","events","emit","total","doc","trainParallel","numThreads","callback","undefined","isNaN","cpus","threadPool","createPool","finished","all","eval","onFeaturesResult","setTimeout","size","batches","onFinished","err","destroy","train","batchSize","Math","ceil","lastError","batchDocs","slice","batchJson","any","parse","trainParallelBatches","options","abort","onError","str","obsBatches","batch","batchIndex","sendNext","sendBatch","bind","retrainParallel","constructor","module","exports"],"mappings":"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","sourcesContent":["const os = require('os')\n\nlet Threads = null\n\ntry {\n  Threads = require('webworker-threads')\n} catch (e) {\n  // Since webworker-threads are optional, only thow if the module is found\n  if (e.code !== 'MODULE_NOT_FOUND') throw e\n}\n\nfunction checkThreadSupport () {\n  if (typeof Threads === 'undefined') {\n    throw new Error('parallel classification requires the optional dependency webworker-threads')\n  }\n}\n\nfunction docsToFeatures (docs) {\n  const parsedDocs = []\n\n  for (let i = 0; i < docs.length; i++) {\n    const features = []\n\n    for (const feature in FEATURES) { // eslint-disable-line\n      if (docs[i].observation.indexOf(feature) > -1) { features.push(1) } else { features.push(0) }\n    }\n\n    parsedDocs.push({\n      index: docs[i].index,\n      features: features\n    })\n  }\n\n  return JSON.stringify(parsedDocs)\n}\n\n// Convert docs to observation objects\nfunction docsToObs (docs, lastAdded, stemmer, keepStops) {\n  const obsDocs = []\n  for (let i = lastAdded; i < docs.length; i++) {\n    let observation = this.docs[i].text\n    if (typeof observation === 'string') {\n      observation = stemmer.tokenizeAndStem(observation, keepStops)\n    }\n    obsDocs.push({\n      index: i,\n      observation: observation\n    })\n  }\n  return obsDocs\n}\n\nfunction emitEvents (self, docFeatures, totalDocs) {\n  for (let j = self.lastAdded; j < totalDocs; j++) {\n    self.classifier.addExample(docFeatures[j], self.docs[j].label)\n    self.events.emit('trainedWithDocument', {\n      index: j,\n      total: totalDocs,\n      doc: self.docs[j]\n    })\n    self.lastAdded++\n  }\n}\n\nfunction trainParallel (numThreads, callback) {\n  checkThreadSupport()\n\n  if (!callback) {\n    callback = numThreads\n    numThreads = undefined\n  }\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length\n  }\n\n  const totalDocs = this.docs.length\n  const threadPool = Threads.createPool(numThreads)\n  const docFeatures = {}\n  let finished = 0\n  const self = this\n\n  // Init pool; send the features array and the parsing function\n  threadPool.all.eval('var FEATURES = ' + JSON.stringify(this.features))\n  threadPool.all.eval(docsToFeatures)\n\n  const obsDocs = docsToObs(this.docs, this.lastAdded, this.stemmer, this.keepStops)\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    setTimeout(function () {\n      self.events.emit('processedBatch', {\n        size: docs.length,\n        docs: totalDocs,\n        batches: numThreads,\n        index: finished\n      })\n    })\n\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features\n    }\n  }\n\n  // Called when all batches finish processing\n  const onFinished = function (err) {\n    if (err) {\n      threadPool.destroy()\n      return callback(err)\n    }\n\n    emitEvents(self, docFeatures, totalDocs)\n    self.events.emit('doneTraining', true)\n    self.classifier.train()\n\n    threadPool.destroy()\n    callback(null)\n  }\n\n  // Split the docs and start processing\n  const batchSize = Math.ceil(obsDocs.length / numThreads)\n  let lastError\n\n  for (let i = 0; i < numThreads; i++) {\n    const batchDocs = obsDocs.slice(i * batchSize, (i + 1) * batchSize)\n    const batchJson = JSON.stringify(batchDocs)\n\n    threadPool.any.eval('docsToFeatures(' + batchJson + ')', function (err, docs) {\n      lastError = err || lastError\n      finished++\n\n      if (docs) {\n        docs = JSON.parse(docs)\n        onFeaturesResult(docs)\n      }\n\n      if (finished >= numThreads) {\n        onFinished(lastError)\n      }\n    })\n  }\n}\n\nfunction trainParallelBatches (options) {\n  checkThreadSupport()\n\n  let numThreads = options && options.numThreads\n  let batchSize = options && options.batchSize\n\n  if (isNaN(numThreads)) {\n    numThreads = os.cpus().length\n  }\n\n  if (isNaN(batchSize)) {\n    batchSize = 2500\n  }\n\n  const totalDocs = this.docs.length\n  const threadPool = Threads.createPool(numThreads)\n  const docFeatures = {}\n  let finished = 0\n  const self = this\n\n  let abort = false\n  const onError = function (err) {\n    if (!err || abort) return\n    abort = true\n    threadPool.destroy(true)\n    self.events.emit('doneTrainingError', err)\n  }\n\n  // Init pool; send the features array and the parsing function\n  const str = JSON.stringify(this.features)\n  threadPool.all.eval('var FEATURES = ' + str + ';', onError)\n  threadPool.all.eval(docsToFeatures, onError)\n\n  // Convert docs to observation objects\n  let obsDocs = []\n  for (let i = this.lastAdded; i < totalDocs; i++) {\n    let observation = this.docs[i].text\n    if (typeof observation === 'string') { observation = this.stemmer.tokenizeAndStem(observation, this.keepStops) }\n    obsDocs.push({\n      index: i,\n      observation: observation\n    })\n  }\n\n  // Split the docs in batches\n  const obsBatches = []\n  let i = 0\n  while (true) {\n    const batch = obsDocs.slice(i * batchSize, (i + 1) * batchSize)\n    if (!batch || !batch.length) break\n    obsBatches.push(batch)\n    i++\n  }\n  obsDocs = null\n  self.events.emit('startedTraining', {\n    docs: totalDocs,\n    batches: obsBatches.length\n  })\n\n  // Called when a batch completes processing\n  const onFeaturesResult = function (docs) {\n    self.events.emit('processedBatch', {\n      size: docs.length,\n      docs: totalDocs,\n      batches: obsBatches.length,\n      index: finished\n    })\n\n    for (let j = 0; j < docs.length; j++) {\n      docFeatures[docs[j].index] = docs[j].features\n    }\n  }\n\n  // Called when all batches finish processing\n  const onFinished = function () {\n    threadPool.destroy(true)\n    abort = true\n\n    emitEvents(self, docFeatures, totalDocs)\n    self.events.emit('doneTraining', true)\n    self.classifier.train()\n  }\n\n  // Called to send the next batch to be processed\n  let batchIndex = 0\n  const sendNext = function () {\n    if (abort) return\n    if (batchIndex >= obsBatches.length) {\n      return\n    }\n\n    sendBatch(JSON.stringify(obsBatches[batchIndex]))\n    batchIndex++\n  }\n\n  // Called to send a batch of docs to the threads\n  const sendBatch = function (batchJson) {\n    if (abort) return\n    threadPool.any.eval('docsToFeatures(' + batchJson + ');', function (err, docs) {\n      if (err) {\n        return onError(err)\n      }\n\n      finished++\n\n      if (docs) {\n        docs = JSON.parse(docs)\n        setTimeout(onFeaturesResult.bind(null, docs))\n      }\n\n      if (finished >= obsBatches.length) {\n        setTimeout(onFinished)\n      }\n\n      setTimeout(sendNext)\n    })\n  }\n\n  // Start processing\n  for (let i = 0; i < numThreads; i++) {\n    sendNext()\n  }\n}\n\nfunction retrainParallel (numThreads, callback) {\n  this.classifier = new (this.classifier.constructor)()\n  this.lastAdded = 0\n  this.trainParallel(numThreads, callback)\n}\n\nmodule.exports = {\n  Threads,\n  trainParallel,\n  trainParallelBatches,\n  retrainParallel\n}\n"]},"metadata":{},"sourceType":"script"}