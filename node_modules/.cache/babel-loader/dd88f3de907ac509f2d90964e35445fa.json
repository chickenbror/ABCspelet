{"ast":null,"code":"/*\n    GISScaler class that finds parameters of features\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n'use strict';\n\nvar Feature = require('./Feature');\n\nvar Distribution = require('./Distribution'); // classes is an array of classes\n// features is an array of feature functions\n\n\nfunction GISScaler(featureSet, sample) {\n  this.featureSet = featureSet;\n  this.sample = sample;\n} // Returns true if a correction feature is necessary\n\n\nGISScaler.prototype.calculateMaxSumOfFeatures = function () {\n  var that = this;\n  this.C = 0;\n  this.featureSums = {};\n  var listOfSumValues = []; // Since feature functions are derived from the sample\n  // we can use the sample to calculate the max sum\n  // We look at each sample element only once\n\n  this.sample.elements.forEach(function (x) {\n    if (!that.featureSums[x.toString()]) {\n      var sum = 0;\n      that.featureSet.getFeatures().forEach(function (f) {\n        sum += f.apply(x);\n      });\n\n      if (sum > that.C) {\n        that.C = sum;\n      }\n\n      that.featureSums[x.toString()] = sum;\n      listOfSumValues.push(sum);\n    }\n  }); // console.log(\"GISScaler:calculateMaxSumOfFeatures:maxSum is \" + this.C);\n  // Check if a correction feature is necessary\n\n  listOfSumValues.sort(function (a, b) {\n    return a - b;\n  });\n  return listOfSumValues[0] !== listOfSumValues[listOfSumValues.length - 1];\n};\n\nGISScaler.prototype.addCorrectionFeature = function () {\n  if (this.calculateMaxSumOfFeatures()) {\n    var f = function f(x) {\n      if (that.featureSums[x.toString()] !== undefined) {\n        return that.C - that.featureSums[x.toString()];\n      }\n\n      return 0;\n    };\n\n    // console.log(\"GISScaler:addCorrectionFeature:C is \" + this.C);\n    var that = this;\n    var correctionFeature = new Feature(f, 'Correction feature', []); // console.log(\"GISScaler:addCorrectionFeature:correctionFeature \" + JSON.stringify(correctionFeature));\n\n    this.featureSet.addFeature(correctionFeature);\n  } else {// console.log(\"Correction feature not needed\");\n  }\n}; // This is the Generalised Iterative Scaling algorithm\n// It ends if the improvement in likelihood of the distribution does not\n// improve more than minImprovement or if the maximum number of iterations is\n// reached.\n\n\nGISScaler.prototype.run = function (maxIterations, minImprovement) {\n  this.iteration = 0;\n  this.improvement = 0;\n  this.addCorrectionFeature(); // Build up the distribution p\n\n  var alpha = new Array(this.featureSet.size());\n\n  for (var i = 0; i < alpha.length; i++) {\n    alpha[i] = 1;\n  }\n\n  var p = new Distribution(alpha, this.featureSet, this.sample); // console.log(\"Distribution created\");\n\n  p.prepare(); // console.log(\"Distribution prepared\");\n\n  var KLDistance = p.KullbackLieblerDistance();\n  var newAlpha = new Array(this.featureSet.size());\n  var observedExpectation = 0;\n  var expectationApprox = 0;\n\n  do {\n    // console.log(\"Iteration \" + this.iteration + \" - Log likelihood of sample: \" + likelihood + \" - Entropy: \" + p.entropy());\n    for (var _i = 0; _i < this.featureSet.size(); _i++) {\n      observedExpectation = this.featureSet.getFeatures()[_i].observedExpectation(this.sample);\n      expectationApprox = this.featureSet.getFeatures()[_i].expectationApprox(p, this.sample); // console.log(\"Iteration \" + this.iteration + \" - Feature \" + i);\n\n      newAlpha[_i] = p.alpha[_i] * Math.pow(observedExpectation / expectationApprox, 1 / this.C); // console.log(\"GISScaler.run: old alpha[\" + i + \"]: \" + p.alpha[i]);\n      // console.log(\"GISScaler.run: new alpha[\" + i + \"]: \" + newAlpha[i]);\n    } // Make the newly calculated parameters current parameters\n\n\n    newAlpha.forEach(function (newAlphaj, j) {\n      p.alpha[j] = newAlphaj;\n    }); // Recalculate a priori and a posteriori probabilities\n\n    p.prepare();\n    this.iteration++;\n    var newKLDistance = p.KullbackLieblerDistance();\n    this.improvement = KLDistance - newKLDistance; // console.log(\"Iteration \" + this.iteration + \" - Old likelihood: \" + likelihood + \" - New likelihood: \" + newLikelihood);\n    // console.log(\"Iteration \" + this.iteration + \" - Old KL: \" + KLDistance + \" - New KL: \" + newKLDistance);\n\n    KLDistance = newKLDistance;\n  } while (this.iteration < maxIterations && this.improvement > minImprovement); // } while (iteration < maxIterations);\n\n  /*\n  var that = this;\n  this.featureSet.getFeatures().forEach(function(f, j) {\n    console.log(\"Observed expectation of feature \" + j + \": \" + f.observedExpectation(that.sample) +\n      \" - Expection of feature according to p: \" + f.expectationApprox(p, that.sample));\n  });\n  */\n\n\n  return p;\n};\n\nmodule.exports = GISScaler;","map":{"version":3,"sources":["C:/CodingProjects/ABCspelet/node_modules/natural/lib/natural/classifiers/maxent/GISScaler.js"],"names":["Feature","require","Distribution","GISScaler","featureSet","sample","prototype","calculateMaxSumOfFeatures","that","C","featureSums","listOfSumValues","elements","forEach","x","toString","sum","getFeatures","f","apply","push","sort","a","b","length","addCorrectionFeature","undefined","correctionFeature","addFeature","run","maxIterations","minImprovement","iteration","improvement","alpha","Array","size","i","p","prepare","KLDistance","KullbackLieblerDistance","newAlpha","observedExpectation","expectationApprox","Math","pow","newAlphaj","j","newKLDistance","module","exports"],"mappings":"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","sourcesContent":["/*\n    GISScaler class that finds parameters of features\n    Copyright (C) 2017 Hugo W.L. ter Doest\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n'use strict'\n\nconst Feature = require('./Feature')\nconst Distribution = require('./Distribution')\n\n// classes is an array of classes\n// features is an array of feature functions\nfunction GISScaler (featureSet, sample) {\n  this.featureSet = featureSet\n  this.sample = sample\n}\n\n// Returns true if a correction feature is necessary\nGISScaler.prototype.calculateMaxSumOfFeatures = function () {\n  const that = this\n  this.C = 0\n  this.featureSums = {}\n  const listOfSumValues = []\n\n  // Since feature functions are derived from the sample\n  // we can use the sample to calculate the max sum\n  // We look at each sample element only once\n  this.sample.elements.forEach(function (x) {\n    if (!that.featureSums[x.toString()]) {\n      let sum = 0\n      that.featureSet.getFeatures().forEach(function (f) {\n        sum += f.apply(x)\n      })\n      if (sum > that.C) {\n        that.C = sum\n      }\n      that.featureSums[x.toString()] = sum\n      listOfSumValues.push(sum)\n    }\n  })\n  // console.log(\"GISScaler:calculateMaxSumOfFeatures:maxSum is \" + this.C);\n\n  // Check if a correction feature is necessary\n  listOfSumValues.sort(function (a, b) {\n    return a - b\n  })\n  return (listOfSumValues[0] !== listOfSumValues[listOfSumValues.length - 1])\n}\n\nGISScaler.prototype.addCorrectionFeature = function () {\n  if (this.calculateMaxSumOfFeatures()) {\n    // console.log(\"GISScaler:addCorrectionFeature:C is \" + this.C);\n    const that = this\n\n    function f (x) {\n      if (that.featureSums[x.toString()] !== undefined) {\n        return that.C - that.featureSums[x.toString()]\n      }\n      return 0\n    }\n\n    const correctionFeature = new Feature(f, 'Correction feature', [])\n    // console.log(\"GISScaler:addCorrectionFeature:correctionFeature \" + JSON.stringify(correctionFeature));\n    this.featureSet.addFeature(correctionFeature)\n  } else {\n    // console.log(\"Correction feature not needed\");\n  }\n}\n\n// This is the Generalised Iterative Scaling algorithm\n// It ends if the improvement in likelihood of the distribution does not\n// improve more than minImprovement or if the maximum number of iterations is\n// reached.\nGISScaler.prototype.run = function (maxIterations, minImprovement) {\n  this.iteration = 0\n  this.improvement = 0\n\n  this.addCorrectionFeature()\n  // Build up the distribution p\n  const alpha = new Array(this.featureSet.size())\n  for (let i = 0; i < alpha.length; i++) {\n    alpha[i] = 1\n  }\n  const p = new Distribution(alpha, this.featureSet, this.sample)\n  // console.log(\"Distribution created\");\n  p.prepare()\n  // console.log(\"Distribution prepared\");\n  let KLDistance = p.KullbackLieblerDistance()\n\n  const newAlpha = new Array(this.featureSet.size())\n  let observedExpectation = 0\n  let expectationApprox = 0\n  do {\n    // console.log(\"Iteration \" + this.iteration + \" - Log likelihood of sample: \" + likelihood + \" - Entropy: \" + p.entropy());\n    for (let i = 0; i < this.featureSet.size(); i++) {\n      observedExpectation = this.featureSet.getFeatures()[i].observedExpectation(this.sample)\n      expectationApprox = this.featureSet.getFeatures()[i].expectationApprox(p, this.sample)\n      // console.log(\"Iteration \" + this.iteration + \" - Feature \" + i);\n      newAlpha[i] = p.alpha[i] * Math.pow(observedExpectation / expectationApprox, 1 / this.C)\n\n      // console.log(\"GISScaler.run: old alpha[\" + i + \"]: \" + p.alpha[i]);\n      // console.log(\"GISScaler.run: new alpha[\" + i + \"]: \" + newAlpha[i]);\n    }\n\n    // Make the newly calculated parameters current parameters\n    newAlpha.forEach(function (newAlphaj, j) {\n      p.alpha[j] = newAlphaj\n    })\n    // Recalculate a priori and a posteriori probabilities\n    p.prepare()\n\n    this.iteration++\n    const newKLDistance = p.KullbackLieblerDistance()\n    this.improvement = KLDistance - newKLDistance\n    // console.log(\"Iteration \" + this.iteration + \" - Old likelihood: \" + likelihood + \" - New likelihood: \" + newLikelihood);\n    // console.log(\"Iteration \" + this.iteration + \" - Old KL: \" + KLDistance + \" - New KL: \" + newKLDistance);\n\n    KLDistance = newKLDistance\n  } while ((this.iteration < maxIterations) && (this.improvement > minImprovement))\n  // } while (iteration < maxIterations);\n  /*\n  var that = this;\n  this.featureSet.getFeatures().forEach(function(f, j) {\n    console.log(\"Observed expectation of feature \" + j + \": \" + f.observedExpectation(that.sample) +\n      \" - Expection of feature according to p: \" + f.expectationApprox(p, that.sample));\n  });\n  */\n\n  return p\n}\n\nmodule.exports = GISScaler\n"]},"metadata":{},"sourceType":"script"}