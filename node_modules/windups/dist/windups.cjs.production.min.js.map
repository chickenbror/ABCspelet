{"version":3,"file":"windups.cjs.production.min.js","sources":["../src/Windup.ts","../src/react/Pace.tsx","../src/react/OnChar.tsx","../src/react/useWindup.ts","../src/react/renderWindup.tsx","../src/react/Pause.tsx","../src/react/WindupChildren.tsx","../src/react/Linebreaker.tsx","../src/react/CharWrapper.tsx","../src/react/Effect.tsx","../src/react/textFromChildren.ts","../src/react/useWindupString.ts"],"sourcesContent":["export type WindupMember<ElementType, MetadataType> =\n  | ElementType\n  | Windup<ElementType, MetadataType>;\nexport type Windup<ElementType, MetadataType> = [\n  Array<WindupMember<ElementType, MetadataType>>,\n  Array<WindupMember<ElementType, MetadataType>>,\n  MetadataType\n];\n\nexport function isPlayedWindup<ElementType, MetadataType>(\n  windup:\n    | PlayedWindup<ElementType, MetadataType>\n    | Windup<ElementType, MetadataType>\n): windup is PlayedWindup<ElementType, MetadataType> {\n  return windup.length === 2;\n}\n\nexport function memberIsWindup<ElementType, MetadataType>(\n  member: WindupMember<ElementType, MetadataType>\n): member is Windup<ElementType, MetadataType> {\n  // If it's not an array it can't be a windup\n  if (!Array.isArray(member)) {\n    return false;\n  }\n\n  // If it has less or more than three members it's not a windup\n  if (member.length !== 3) {\n    return false;\n  }\n\n  // If its first or second members are not arrays it's not a windup\n  if (!Array.isArray(member[0]) || !Array.isArray(member[1])) {\n    return false;\n  }\n\n  // Past here we just have to hope ElementType isn't a windup.\n  return true;\n}\n\nexport function windupFromString<MetadataType>(\n  str: string,\n  metadata: MetadataType\n): Windup<string, MetadataType> {\n  return [[], str.split(\"\"), metadata];\n}\n\nexport function newWindup<ElementType, MetadataType>(\n  arg: Array<WindupMember<ElementType, MetadataType>>,\n  metadata: MetadataType\n): Windup<ElementType, MetadataType> {\n  return [[], arg, metadata];\n}\n\nexport function isUnplayed<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): boolean {\n  const [played, remaining] = windup;\n\n  if (played.length > 0) {\n    return false;\n  }\n\n  return remaining.reduce((unplayed: boolean, member) => {\n    if (memberIsWindup(member))\n      if (memberIsWindup(windup) && unplayed) {\n        return isUnplayed<ElementType, MetadataType>(member);\n      }\n    return unplayed;\n  }, true);\n}\n\nexport function isFinished<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): boolean {\n  return remaining.length === 0;\n}\n\nexport function fastForward<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  const forwardedWindup = next(windup);\n  if (isFinished(forwardedWindup)) {\n    return forwardedWindup;\n  }\n  return fastForward(forwardedWindup);\n}\n\nexport function rewind<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  if (isUnplayed(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n\n  type MemberType = WindupMember<ElementType, MetadataType>;\n\n  const mapRewind = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return rewind(member);\n    }\n    return member;\n  };\n\n  return [\n    [],\n    [...played.map(mapRewind), ...remaining.map(mapRewind)],\n    metadata\n  ];\n}\n\nexport function windupAsString<MetadataType>(\n  windup: Windup<string, MetadataType>\n): string {\n  const [played, remaining] = windup;\n\n  type MemberType = WindupMember<string, MetadataType>;\n  const stringify = (member: MemberType): MemberType => {\n    if (memberIsWindup(member)) {\n      return windupAsString(member);\n    }\n    return member;\n  };\n  return [\n    played.map(stringify).join(\"\"),\n    remaining.map(stringify).join(\"\")\n  ].join(\"\");\n}\n\nexport function lastPlayedMember<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>):\n  | WindupMember<ElementType, MetadataType>\n  | undefined {\n  const playedFromRemaining = remaining.reduce(\n    (playedEl: WindupMember<ElementType, MetadataType> | undefined, member) => {\n      if (memberIsWindup(member)) {\n        if (!isUnplayed(member)) {\n          return lastPlayedElement(member);\n        }\n      }\n      return playedEl;\n    },\n    undefined\n  );\n\n  if (playedFromRemaining) {\n    return playedFromRemaining;\n  }\n\n  const last = played[played.length - 1];\n  return last;\n}\n\nexport function lastPlayedElement<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): ElementType | undefined {\n  const lastPlayed = lastPlayedMember(windup);\n\n  if (memberIsWindup(lastPlayed)) {\n    return lastPlayedElement(lastPlayed);\n  }\n\n  return lastPlayed;\n}\n\nexport type PlayedWindup<ElementType, MetadataType> = [\n  Array<ElementType>,\n  MetadataType\n];\n\nexport function playedElements<ElementType, MetadataType>([\n  played,\n  remaining\n]: Windup<ElementType, MetadataType>): Array<\n  ElementType | PlayedWindup<ElementType, MetadataType>\n> {\n  const playedTransformed = played.map(member => {\n    if (memberIsWindup(member)) {\n      const [, , metadata] = member;\n      return [playedElements(member), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >;\n    }\n    return member;\n  });\n\n  const [firstRemaning] = remaining;\n  if (memberIsWindup(firstRemaning) && !isUnplayed(firstRemaning)) {\n    const [, , metadata] = firstRemaning;\n\n    return [\n      ...playedTransformed,\n      [playedElements(firstRemaning), metadata] as PlayedWindup<\n        ElementType,\n        MetadataType\n      >\n    ];\n  }\n\n  return playedTransformed;\n}\n\nexport function nextElement<ElementType, MetadataType>([\n  _played,\n  remaining\n]: Windup<ElementType, MetadataType>): ElementType | undefined {\n  const [nextVal] = remaining;\n\n  if (memberIsWindup(nextVal)) {\n    return nextElement(nextVal);\n  }\n\n  return nextVal;\n}\n\nexport function next<ElementType, MetadataType>(\n  windup: Windup<ElementType, MetadataType>\n): Windup<ElementType, MetadataType> {\n  // start\n  // [[], [[[], [\"h\", \"i\"]], [[], [\"n\", \"o\"]]]]\n\n  // next\n  // [[], [[[\"h\"], [\"i\"]], [\"\", [\"n\", \"o\"]]]]\n\n  // next\n  // [[\"h\", \"i\"], [[\"n\", \"o\"]]]\n\n  // next\n  // [[\"h\", \"i\"] [\"n\", \"o\"]], []]\n\n  if (isFinished(windup)) {\n    return windup;\n  }\n\n  const [played, remaining, metadata] = windup;\n  const [firstRemaining, ...restRemaining] = remaining;\n\n  if (memberIsWindup(firstRemaining)) {\n    const nextFirstRemaining = next(firstRemaining);\n\n    if (isFinished(nextFirstRemaining)) {\n      return [[...played, nextFirstRemaining], restRemaining, metadata];\n    }\n\n    return [played, [nextFirstRemaining, ...restRemaining], metadata];\n  }\n\n  return [[...played, firstRemaining], restRemaining, metadata];\n}\n","import * as React from \"react\";\nimport { isFinished, memberIsWindup, Windup } from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype MsProp = {\n  ms: number;\n};\n\ntype GetPaceProp = {\n  getPace: (char: string) => number;\n};\n\ntype PaceProps = MsProp | GetPaceProp;\n\nexport function defaultGetPace(\n  lastChar: string,\n  nextChar: string | undefined\n): number {\n  switch (lastChar) {\n    case \"—\":\n    case \"…\":\n      return 200;\n    case \".\":\n    case \",\":\n      return 150;\n    case \"?\":\n    case \"!\":\n      if (nextChar !== \"!\" && nextChar !== \"?\") {\n        return 150;\n      }\n      return 20;\n    case \"-\":\n    case \" \":\n    case \"\\n\":\n      return 0;\n    default:\n      return 20;\n  }\n}\n\nconst Pace: React.FC<PaceProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isPaceElement(\n  element: React.ReactElement\n): element is React.ReactElement<PaceProps> {\n  return element.type === Pace;\n}\n\nexport function isMsProp(props: PaceProps): props is MsProp {\n  if (\"ms\" in props) {\n    return true;\n  }\n  return false;\n}\n\nexport function paceFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(\n  windup: W,\n  parentPace?: (char: string, nextChar: string | undefined) => number\n): ((char: string, nextChar: string | undefined) => number) | undefined {\n  if (isFinished(windup)) {\n    return undefined;\n  }\n\n  const [, remaining, metadata] = windup;\n\n  const [firstRemaining] = remaining;\n\n  if (firstRemaining && memberIsWindup(firstRemaining)) {\n    return paceFromWindup(firstRemaining, metadata.pace || parentPace);\n  }\n\n  return metadata.pace || parentPace;\n}\n\nexport default Pace;\n","import * as React from \"react\";\nimport {\n  memberIsWindup,\n  Windup,\n  lastPlayedMember,\n  isUnplayed\n} from \"../Windup\";\nimport { HookMetadata } from \"./useWindup\";\n\ntype OnCharProps = {\n  fn: (char: string) => void;\n};\n\nconst OnChar: React.FC<OnCharProps> = ({ children }) => {\n  return <>{children}</>;\n};\n\nexport function isOnCharElement(\n  element: React.ReactElement\n): element is React.ReactElement<OnCharProps> {\n  return element.type === OnChar;\n}\n\n// Should return onChars from\n// every just played member that is a windup\n// any first remaining that is played\nexport function onCharsFromWindup<\n  M extends HookMetadata,\n  W extends Windup<string, M>\n>(windup: W): ((char: string) => void)[] {\n  const [, remaining, metadata] = windup;\n  const lastPlayed = lastPlayedMember(windup);\n  const [firstRemaining] = remaining;\n\n  let onChars = [];\n\n  if (lastPlayed && memberIsWindup(lastPlayed)) {\n    onChars.push(...onCharsFromWindup(lastPlayed));\n  }\n\n  if (\n    firstRemaining &&\n    memberIsWindup(firstRemaining) &&\n    !isUnplayed(firstRemaining)\n  ) {\n    onChars.push(...onCharsFromWindup(firstRemaining));\n  }\n\n  if (metadata.onChar) {\n    onChars.push(metadata.onChar);\n  }\n\n  return onChars;\n}\n\nexport default OnChar;\n","import * as React from \"react\";\nimport { defaultGetPace, paceFromWindup } from \"./Pace\";\nimport {\n  isFinished,\n  lastPlayedElement,\n  next,\n  fastForward,\n  rewind,\n  Windup,\n  nextElement\n} from \"../Windup\";\nimport { onCharsFromWindup } from \"./OnChar\";\n\ntype WindupReducerState<M> = {\n  windup: Windup<string, M>;\n  didFinishOnce: boolean;\n};\n\ntype WindupReducerAction<M> =\n  | {\n      type: \"replace\";\n      windup: Windup<string, M>;\n    }\n  | {\n      type: \"next\";\n    }\n  | {\n      type: \"rewind\";\n    }\n  | {\n      type: \"fast-forward\";\n    }\n  | {\n      type: \"finish\";\n    };\n\nfunction initWindupState<M>(windup: Windup<string, M>): WindupReducerState<M> {\n  return { windup, didFinishOnce: false };\n}\n\ntype ReducerType<M> = (\n  prevState: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n) => WindupReducerState<M>;\n\nfunction windupReducer<M>(\n  state: WindupReducerState<M>,\n  action: WindupReducerAction<M>\n): WindupReducerState<M> {\n  switch (action.type) {\n    case \"replace\":\n      return initWindupState(action.windup);\n    case \"next\":\n      return { ...state, windup: next(state.windup) };\n    case \"rewind\":\n      return { windup: rewind(state.windup), didFinishOnce: false };\n    case \"fast-forward\":\n      return { ...state, windup: fastForward(state.windup) };\n    case \"finish\":\n      return { ...state, didFinishOnce: true };\n    default:\n      return state;\n  }\n}\n\nexport interface HookMetadata {\n  onChar?: (char: string) => void;\n  pace?: (char: string, nextChar: string | undefined) => number;\n}\n\nexport default function useWindup<M extends HookMetadata>(\n  windupInit: Windup<string, M>,\n  options: {\n    onFinished?: () => void;\n    skipped?: boolean;\n  }\n): {\n  windup: Windup<string, M>;\n  skip: () => void;\n  rewind: () => void;\n  isFinished: boolean;\n} {\n  const [{ windup, didFinishOnce }, dispatch] = React.useReducer<\n    ReducerType<M>,\n    Windup<string, M>\n  >(windupReducer, windupInit, initWindupState);\n\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\n  const windupIsFinished = isFinished(windup);\n\n  const skip = React.useCallback(() => {\n    if (!windupIsFinished) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n  }, [windupIsFinished]);\n\n  const rewind = React.useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    dispatch({ type: \"rewind\" });\n  }, []);\n\n  // If windup arg changes, we should reset\n  React.useEffect(() => {\n    dispatch({ type: \"replace\", windup: windupInit });\n  }, [windupInit]);\n\n  // If skipped is changes to true, we should skip\n  // And if it's changed to false, we should restart\n  React.useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    if (options.skipped) {\n      dispatch({\n        type: \"fast-forward\"\n      });\n    }\n    if (options.skipped === false) {\n      dispatch({ type: \"rewind\" });\n    }\n  }, [options.skipped]);\n\n  // When the windup changes, onChar should fire\n  React.useEffect(() => {\n    const onChars = onCharsFromWindup(windup);\n    const lastEl = lastPlayedElement(windup);\n    if (onChars.length > 0 && lastEl) {\n      onChars.forEach(onChar => {\n        onChar(lastEl);\n      });\n    }\n  }, [windup]);\n\n  // If windup finishes, the onFinished should fire\n  React.useEffect(() => {\n    // Put this in a new context so that the windup finishes visually before firing this\n    if (didFinishOnce === false && windupIsFinished) {\n      const timeout = setTimeout(() => {\n        if (options.onFinished) {\n          options.onFinished();\n        }\n        dispatch({ type: \"finish\" });\n      }, 0);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [didFinishOnce, windupIsFinished, options]);\n\n  // the windup effect itself\n  React.useEffect(() => {\n    if (!windupIsFinished) {\n      const getPace = paceFromWindup(windup) || defaultGetPace;\n      const lastEl = lastPlayedElement(windup);\n      const nextEl = nextElement(windup);\n      timeoutRef.current = setTimeout(\n        () => {\n          dispatch({ type: \"next\" });\n        },\n        lastEl ? getPace(lastEl, nextEl) : 0\n      );\n      return () => {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n        }\n      };\n    }\n  }, [windup, windupIsFinished]);\n\n  return {\n    windup,\n    skip,\n    rewind,\n    isFinished: windupIsFinished\n  };\n}\n","import * as React from \"react\";\nimport { ChildrenMetadata, ChildrenWindup } from \"./WindupChildren\";\nimport { PlayedWindup, playedElements, isPlayedWindup } from \"../Windup\";\nimport { StringMetadata, StringWindup } from \"./useWindupString\";\n\nexport type PlayedChildrenWindup = PlayedWindup<string, ChildrenMetadata>;\nexport type PlayedStringWindup = PlayedWindup<string, StringMetadata>;\n\nexport function renderStringWindup(\n  windup: StringWindup | PlayedStringWindup\n): string {\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const inner = played.reduce((acc: string, playedEl) => {\n    if (typeof playedEl === \"string\") {\n      return acc + playedEl;\n    }\n\n    return acc + renderStringWindup(playedEl);\n  }, \"\");\n\n  return inner;\n}\n\nconst VOID_TAGS = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"command\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n];\n\nexport function renderChildrenWindup(\n  windup: ChildrenWindup | PlayedChildrenWindup\n): React.ReactNode {\n  const metadata = isPlayedWindup(windup) ? windup[1] : windup[2];\n  const played = isPlayedWindup(windup) ? windup[0] : playedElements(windup);\n\n  const Outer = metadata.element || React.Fragment;\n\n  if (metadata.props && Object.keys(metadata.props).includes(\"children\")) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  const inner = played.reduce((acc: React.ReactNode[], playedEl) => {\n    if (typeof playedEl === \"string\") {\n      const accButLast = acc.slice(0, acc.length - 1);\n      const last = acc[acc.length - 1];\n\n      return last && typeof last === \"string\"\n        ? [...accButLast, last + playedEl]\n        : [...acc, playedEl];\n    }\n\n    return [...acc, renderChildrenWindup(playedEl)];\n  }, []);\n\n  if (\n    typeof metadata.element === \"string\" &&\n    VOID_TAGS.includes(metadata.element)\n  ) {\n    return <Outer key={metadata.key} {...metadata.props} />;\n  }\n\n  return (\n    <Outer key={metadata.key} {...metadata.props}>\n      {inner}\n    </Outer>\n  );\n}\n","import * as React from \"react\";\n\ntype PauseProps = {\n  ms: number;\n};\n\nconst Pause: React.FC<PauseProps> = () => {\n  return null;\n};\n\nexport function isPauseElement(\n  element: React.ReactElement\n): element is React.ReactElement<PauseProps> {\n  return element.type === Pause;\n}\n\nexport default Pause;\n","import * as React from \"react\";\nimport {\n  newWindup,\n  Windup,\n  WindupMember,\n  windupFromString,\n  memberIsWindup\n} from \"../Windup\";\nimport { isPaceElement, isMsProp } from \"./Pace\";\nimport { isOnCharElement } from \"./OnChar\";\nimport { isPauseElement } from \"./Pause\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderChildrenWindup } from \"./renderWindup\";\n\nconst WindupContext = React.createContext({\n  skip: () => {\n    console.warn(\n      \"Tried to use the useSkip hook outside of a WindupChildren component!!\"\n    );\n  },\n  rewind: () => {\n    console.warn(\n      \"Tried to use the useRewind hook outside of a WindupChildren component!\"\n    );\n  },\n  isFinished: false\n});\n\nexport function useSkip() {\n  const { skip } = React.useContext(WindupContext);\n  return skip;\n}\n\nexport function useRewind() {\n  const { rewind } = React.useContext(WindupContext);\n  return rewind;\n}\n\nexport function useIsFinished() {\n  const { isFinished } = React.useContext(WindupContext);\n  return isFinished;\n}\n\nexport interface ChildrenMetadata extends HookMetadata {\n  element: React.ElementType | string | undefined;\n  props?: any;\n  ref?: any;\n  key?: string | number | null;\n}\n\nexport type ChildrenWindup = Windup<string, ChildrenMetadata>;\ntype ChildrenWindupMember = WindupMember<string, ChildrenMetadata>;\n\nfunction reduceWindupArgs(\n  prevArgs: ChildrenWindupMember[],\n  children: React.ReactNode\n) {\n  if (typeof children === \"string\") {\n    return [...prevArgs, ...children.split(\"\")];\n  }\n\n  if (typeof children === \"number\") {\n    return [...prevArgs, ...children.toString().split(\"\")];\n  }\n\n  if (!React.isValidElement(children)) {\n    return prevArgs;\n  }\n\n  const { children: childrenChildren, ...restProps } = children.props;\n\n  const paceMetaData = isPaceElement(children)\n    ? {\n        pace: (char: string) => {\n          if (isMsProp(children.props)) {\n            return children.props.ms;\n          }\n          return children.props.getPace(char);\n        }\n      }\n    : {};\n\n  const onCharMetaData = isOnCharElement(children)\n    ? {\n        onChar: children.props.fn\n      }\n    : {};\n\n  const keyProp = children.key ? { key: children.key } : {};\n\n  if (isPauseElement(children)) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: React.Fragment,\n        ...keyProp,\n        props: { children: undefined },\n        pace: () => children.props.ms\n      })\n    ];\n  }\n\n  if (childrenChildren === undefined) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { ...restProps, children: undefined },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (typeof childrenChildren === \"string\") {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(childrenChildren, {\n        element: children.type,\n        props: restProps,\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  if (childrenChildren instanceof Function) {\n    return [\n      ...prevArgs,\n      windupFromString<ChildrenMetadata>(\" \", {\n        element: children.type,\n        props: { children: childrenChildren, ...restProps },\n        ...keyProp,\n        ...paceMetaData,\n        ...onCharMetaData\n      })\n    ];\n  }\n\n  const newArgs: ChildrenWindupMember[] = React.Children.toArray(\n    childrenChildren\n  ).reduce(reduceWindupArgs, []);\n\n  const argsWithMetadata = newArgs.map(member => {\n    if (memberIsWindup(member)) {\n      const [played, remaining, metadata] = member;\n      return [\n        played,\n        remaining,\n        {\n          ...paceMetaData,\n          ...onCharMetaData,\n          ...metadata\n        }\n      ] as ChildrenWindupMember;\n    }\n    return member;\n  });\n\n  return [\n    ...prevArgs,\n    newWindup<string, ChildrenMetadata>(argsWithMetadata, {\n      element: children.type,\n      props: restProps,\n      ...keyProp,\n      ...paceMetaData,\n      ...onCharMetaData\n    })\n  ];\n}\n\ntype WindupChildrenProps = {\n  onFinished?: () => void;\n  skipped?: boolean;\n};\n\nfunction buildKeyString(children: React.ReactNode): string {\n  if (children === null || children === undefined) {\n    return \"\";\n  }\n\n  const keys = React.Children.map(children, child => {\n    if (typeof child === \"string\") {\n      return child;\n    }\n\n    if (typeof child === \"number\") {\n      return child.toString();\n    }\n\n    if (React.isValidElement(child)) {\n      return `#${child.key || \"\"}<${buildKeyString(child.props.children)}>`;\n    }\n\n    return \"\";\n  });\n\n  if (!keys) {\n    return \"\";\n  }\n\n  return keys.join(\",\");\n}\n\nfunction useChildrenMemo<T>(factory: () => T, children: React.ReactNode) {\n  // Omitting children in favour of using a key instead\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoChildren = React.useMemo(factory, [buildKeyString(children)]);\n\n  return memoChildren;\n}\n\nconst WindupChildren: React.FC<WindupChildrenProps> = ({\n  children,\n  onFinished,\n  skipped\n}) => {\n  const windupInit = useChildrenMemo(() => {\n    return newWindup<string, ChildrenMetadata>(\n      React.Children.toArray(children).reduce(reduceWindupArgs, []),\n      { element: undefined }\n    );\n  }, children);\n\n  const { windup, skip, rewind, isFinished } = useWindup(windupInit, {\n    onFinished,\n    skipped\n  });\n\n  return (\n    <WindupContext.Provider\n      value={{\n        skip,\n        rewind,\n        isFinished\n      }}\n    >\n      {renderChildrenWindup(windup)}\n    </WindupContext.Provider>\n  );\n};\n\nexport default WindupChildren;\n","import * as React from \"react\";\nimport breakLines from \"break-styled-lines\";\n\nfunction makeGetDescriptorsOfChildren(defaultFontStyle: string) {\n  return (\n    descriptors: { text: string; font: string }[],\n    children: React.ReactNode\n  ): { text: string; font: string }[] => {\n    if (typeof children === \"string\") {\n      return [...descriptors, { text: children, font: defaultFontStyle }];\n    }\n\n    if (typeof children === \"number\") {\n      return [\n        ...descriptors,\n        { text: children.toString(), font: defaultFontStyle }\n      ];\n    }\n\n    if (!React.isValidElement(children)) {\n      return descriptors;\n    }\n\n    if (\n      isStyledTextElement(children) &&\n      typeof children.props.children === \"string\"\n    ) {\n      return [\n        ...descriptors,\n        { text: children.props.children, font: children.props.fontStyle }\n      ];\n    }\n\n    if (isStyledTextElement(children)) {\n      return [\n        ...descriptors,\n        ...React.Children.toArray(children.props.children).reduce(\n          makeGetDescriptorsOfChildren(children.props.fontStyle),\n          []\n        )\n      ];\n    }\n\n    return [\n      ...descriptors,\n      ...React.Children.toArray(children.props.children).reduce(\n        makeGetDescriptorsOfChildren(defaultFontStyle),\n        []\n      )\n    ];\n  };\n}\n\nfunction reinsertStringsIntoChildren(\n  [accChildren, accStrings]: [React.ReactNode[], string[]],\n  children: React.ReactNode\n): [React.ReactNode[], string[]] {\n  if (typeof children === \"string\" || typeof children === \"number\") {\n    const [firstString, ...restStrings] = accStrings;\n    return [[...accChildren, firstString], restStrings];\n  }\n\n  if (!React.isValidElement(children)) {\n    return [accChildren, accStrings];\n  }\n\n  const [subChildrenAcc, subStringsAcc] = React.Children.toArray(\n    children.props.children\n  ).reduce(reinsertStringsIntoChildren, [[], accStrings]);\n\n  return [\n    [\n      ...accChildren,\n      React.cloneElement(children, {\n        children: subChildrenAcc\n      })\n    ],\n    subStringsAcc\n  ];\n}\n\ntype StyledTextProps = { children: React.ReactNode; fontStyle: string };\n\nfunction isStyledTextElement(\n  element: React.ReactElement\n): element is React.ReactElement<StyledTextProps> {\n  return element.type === StyledText;\n}\n\nexport function StyledText({ children }: StyledTextProps) {\n  return <>{children}</>;\n}\n\ntype LinebreakerProps = {\n  fontStyle: string;\n  width: number;\n};\n\nconst Linebreaker: React.FC<LinebreakerProps> = ({\n  children,\n  fontStyle,\n  width\n}) => {\n  // CAVEATS:\n  // fontStyle must match the font style of the characters inside\n  // non-character elements must not add width to the line.\n  // must be used OUTSIDE of WindupChildren component\n\n  const childrenArray = React.Children.toArray(children);\n  const descriptors = childrenArray.reduce(\n    makeGetDescriptorsOfChildren(fontStyle),\n    []\n  );\n\n  const transformedStrings = breakLines(descriptors, width, fontStyle);\n\n  const [\n    transformedChildren\n  ] = childrenArray.reduce(reinsertStringsIntoChildren, [\n    [],\n    transformedStrings\n  ]);\n\n  return <div style={{ whiteSpace: \"pre\" }}>{transformedChildren}</div>;\n};\n\nexport default Linebreaker;\n","import * as React from \"react\";\n\ntype CharWrapperProps = {\n  element: React.ElementType;\n};\n\nfunction wrapChildren(children: React.ReactNode, Wrapper: React.ElementType) {\n  if (typeof children === \"string\") {\n    return children\n      .split(\"\")\n      .map((char, i) =>\n        char === \"\\n\" ? char : <Wrapper key={`${char}-${i}`}>{char}</Wrapper>\n      );\n  }\n\n  if (typeof children === \"number\") {\n    return children\n      .toString()\n      .split(\"\")\n      .map(char => <Wrapper>{char}</Wrapper>);\n  }\n\n  if (!React.isValidElement(children)) {\n    return <React.Fragment />;\n  }\n\n  if (children.props.children) {\n    const Outer = children.type;\n\n    if (children.props.children instanceof Function) {\n      return <Outer key={children.key} {...children.props} />;\n    }\n\n    return (\n      <Outer key={children.key} {...children.props}>\n        {React.Children.map(children.props.children, ch => {\n          return wrapChildren(ch, Wrapper);\n        })}\n      </Outer>\n    );\n  }\n\n  return children;\n}\n\nconst CharWrapper: React.FC<CharWrapperProps> = ({ children, element }) => {\n  return (\n    <>\n      {React.Children.map(children, ch => {\n        return wrapChildren(ch, element);\n      })}\n    </>\n  );\n};\n\nexport default CharWrapper;\n","import * as React from \"react\";\n\ntype EffectProps = {\n  fn: () => void;\n};\n\nconst Effect: React.FC<EffectProps> = ({ fn }) => {\n  React.useEffect(() => {\n    fn();\n    // We can safely omit fn from dependencies as if its value changes\n    // the whole windup will be re-rendered anyway\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return null;\n};\n\nexport default Effect;\n","import * as React from \"react\";\n\nexport default function textFromChildren(children: React.ReactNode): string {\n  const text = React.Children.map(children, ch => {\n    if (typeof ch === \"string\") {\n      return ch;\n    }\n\n    if (typeof ch === \"number\") {\n      return ch.toString();\n    }\n\n    if (!React.isValidElement(ch)) {\n      return \"\";\n    }\n\n    if (ch.props.children) {\n      return textFromChildren(ch.props.children);\n    }\n\n    return \"\";\n  });\n\n  if (!text) {\n    return \"\";\n  }\n\n  return text.join(\"\");\n}\n","import * as React from \"react\";\nimport { windupFromString, Windup } from \"../Windup\";\nimport useWindup, { HookMetadata } from \"./useWindup\";\nimport { renderStringWindup } from \"./renderWindup\";\n\nexport type WindupOptions = {\n  onChar?: (char: string) => void;\n  onFinished?: () => void;\n  pace?: (char: string) => number;\n  skipped?: boolean;\n};\n\nexport type StringMetadata = HookMetadata;\n\nexport type StringWindup = Windup<string, StringMetadata>;\n\nexport default function useWindupString(\n  text: string,\n  options: WindupOptions = {}\n): [\n  string,\n  {\n    skip: () => void;\n    rewind: () => void;\n    isFinished: boolean;\n  }\n] {\n  const windupInit = React.useMemo(() => {\n    return windupFromString<StringMetadata>(text, options);\n    // We can omit options as this is used as an initialisation value and options will not change it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [text]);\n\n  const { windup, skip, rewind, isFinished } = useWindup(windupInit, options);\n\n  const rendered = renderStringWindup(windup);\n  React.useDebugValue(rendered);\n\n  return [rendered, { skip, rewind, isFinished }];\n}\n"],"names":["isPlayedWindup","windup","length","memberIsWindup","member","Array","isArray","windupFromString","str","metadata","split","newWindup","arg","isUnplayed","reduce","unplayed","isFinished","fastForward","forwardedWindup","next","rewind","remaining","mapRewind","map","lastPlayedMember","played","playedEl","lastPlayedElement","undefined","lastPlayed","playedElements","playedTransformed","firstRemaning","firstRemaining","restRemaining","nextFirstRemaining","defaultGetPace","lastChar","nextChar","Pace","React","children","OnChar","initWindupState","didFinishOnce","windupReducer","state","action","type","useWindup","windupInit","options","dispatch","timeoutRef","windupIsFinished","skip","current","clearTimeout","skipped","onChars","onCharsFromWindup","push","onChar","lastEl","forEach","timeout","setTimeout","onFinished","getPace","paceFromWindup","parentPace","pace","nextEl","nextElement","nextVal","VOID_TAGS","Pause","WindupContext","console","warn","reduceWindupArgs","prevArgs","toString","props","childrenChildren","restProps","paceMetaData","char","ms","onCharMetaData","element","isOnCharElement","fn","keyProp","key","isPauseElement","Function","argsWithMetadata","toArray","buildKeyString","keys","child","join","reinsertStringsIntoChildren","accChildren","accStrings","firstString","restStrings","subStringsAcc","isStyledTextElement","StyledText","ch","wrapChildren","Wrapper","i","Outer","fontStyle","width","childrenArray","descriptors","makeGetDescriptorsOfChildren","defaultFontStyle","text","font","transformedStrings","breakLines","style","whiteSpace","factory","useChildrenMemo","Provider","value","renderChildrenWindup","Object","includes","inner","acc","accButLast","slice","last","textFromChildren","rendered","renderStringWindup"],"mappings":"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"}